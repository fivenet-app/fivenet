package main

import (
	"slices"
	"strings"
	"text/template"

	dbscannerpb "github.com/fivenet-app/fivenet/v2025/gen/go/proto/codegen/dbscanner"
	pgs "github.com/lyft/protoc-gen-star/v2"
	pgsgo "github.com/lyft/protoc-gen-star/v2/lang/go"
)

// DBScannerModule holds all state for this plugin.
type DBScannerModule struct {
	*pgs.ModuleBase

	ctx pgsgo.Context
	tpl *template.Template
}

// DBScanner returns an initialized DBScannerModule.
func DBScanner() *DBScannerModule { return &DBScannerModule{ModuleBase: &pgs.ModuleBase{}} }

func (p *DBScannerModule) InitContext(c pgs.BuildContext) {
	p.ModuleBase.InitContext(c)
	p.ctx = pgsgo.InitContext(c.Parameters())

	tpl := template.New("dbscanner").Funcs(map[string]any{
		"package": p.ctx.PackageName,
		"name":    p.ctx.Name,
	})

	p.tpl = template.Must(tpl.Parse(dbscannerTpl))
}

// Name satisfies the generator.Plugin interface.
func (p *DBScannerModule) Name() string { return "dbscanner" }

func (p *DBScannerModule) Execute(
	targets map[string]pgs.File,
	pkgs map[string]pgs.Package,
) []pgs.Artifact {
	visited := map[string][]pgs.File{}
	for _, t := range targets {
		key := t.File().InputPath().Dir().String()
		if _, ok := visited[key]; ok {
			visited[key] = append(visited[key], t)
			continue
		}

		visited[key] = []pgs.File{t}
	}

	for _, fs := range visited {
		p.generate(fs)
	}

	return p.Artifacts()
}

func (p *DBScannerModule) generate(fs []pgs.File) {
	slices.SortFunc(fs, func(a, b pgs.File) int {
		return strings.Compare(a.File().InputPath().String(), b.File().InputPath().String())
	})

	for _, f := range fs {
		data := struct {
			F        pgs.File
			Messages map[string]*DBScannerInfo
		}{
			F:        f,
			Messages: map[string]*DBScannerInfo{},
		}

		for _, m := range f.Messages() {
			mName := string(m.Name())
			mName = strings.TrimPrefix(mName, "services.")

			// Check if the field option is present and true
			var val dbscannerpb.MessageOptions
			ok, err := f.Extension(dbscannerpb.E_Dbscanner, &val)
			if err != nil {
				p.Fail("error reading dbscanner extension: %v", err)
			}

			if !ok {
				continue
			}

			if !val.Enabled {
				continue
			}

			dbscanner := &DBScannerInfo{
				Unmarshal: "protojson.Unmarshal",
				Marshal:   "protoutils.MarshalToJSON",
			}

			if val.Partial != nil && *val.Partial {
				dbscanner.Unmarshal = "protoutils.UnmarshalPartialJSON"
				dbscanner.Marshal = "protoutils.MarshalToJSON"
			} else if val.NotJson != nil && *val.NotJson {
				dbscanner.Unmarshal = "proto.Unmarshal"
				dbscanner.Marshal = "proto.Marshal"
			}

			data.Messages[mName] = dbscanner
		}

		if len(data.Messages) == 0 {
			continue
		}

		name := p.ctx.OutputPath(f).SetExt(".dbscanner.go")
		p.AddGeneratorTemplateFile(name.String(), p.tpl, data)
	}
}

type DBScannerInfo struct {
	Unmarshal string
	Marshal   string
}

const dbscannerTpl = `// Code generated by protoc-gen-customizer. DO NOT EDIT.
// source: {{ .F.InputPath }}

package {{ package .F }}

import (
	"database/sql/driver"

	"github.com/fivenet-app/fivenet/v2025/pkg/utils/protoutils"
	"github.com/paulmach/orb"
	"google.golang.org/protobuf/proto"
)

{{- range $message, $info := .Messages }}
// Scan implements driver.Valuer for protobuf {{ $message }}.
func (x *{{ $message }}) Scan(value any) error {
	switch t := value.(type) {
	case string:
		return {{ $info.Unmarshal }}([]byte(t), x)
	case []byte:
		return {{ $info.Unmarshal }}(t, x)
	}
	return nil
}

// Value marshals the {{ $message }} value into driver.Valuer.
func (x *{{ $message }}) Value() (driver.Value, error) {
	if x == nil {
		return nil, nil
	}

	out, err := {{ $info.Marshal }}(x)
	return string(out), err
}
{{- end }}
`
