package main

import (
	"bufio"
	"slices"
	"strings"
	"text/template"

	pgs "github.com/lyft/protoc-gen-star/v2"
	pgsgo "github.com/lyft/protoc-gen-star/v2/lang/go"
)

type DBScannerModule struct {
	*pgs.ModuleBase
	ctx pgsgo.Context
	tpl *template.Template
}

// DBScanner returns an initialized DBScannerModule
func DBScanner() *DBScannerModule { return &DBScannerModule{ModuleBase: &pgs.ModuleBase{}} }

func (p *DBScannerModule) InitContext(c pgs.BuildContext) {
	p.ModuleBase.InitContext(c)
	p.ctx = pgsgo.InitContext(c.Parameters())

	tpl := template.New("dbscanner").Funcs(map[string]any{
		"package": p.ctx.PackageName,
		"name":    p.ctx.Name,
	})

	p.tpl = template.Must(tpl.Parse(dbscannerTpl))
}

// Name satisfies the generator.Plugin interface.
func (p *DBScannerModule) Name() string { return "dbscanner" }

func (p *DBScannerModule) Execute(targets map[string]pgs.File, pkgs map[string]pgs.Package) []pgs.Artifact {
	visited := map[string][]pgs.File{}
	for _, t := range targets {
		key := t.File().InputPath().Dir().String()
		if _, ok := visited[key]; ok {
			visited[key] = append(visited[key], t)
			continue
		}

		visited[key] = []pgs.File{t}
	}

	for _, fs := range visited {
		p.generate(fs)
	}

	return p.Artifacts()
}

func (p *DBScannerModule) generate(fs []pgs.File) {
	slices.SortFunc(fs, func(a, b pgs.File) int {
		return strings.Compare(a.File().InputPath().String(), b.File().InputPath().String())
	})

	for _, f := range fs {
		data := struct {
			F        pgs.File
			Messages map[string]*DBScannerInfo
		}{
			F:        f,
			Messages: map[string]*DBScannerInfo{},
		}

		for _, m := range f.Messages() {
			mName := string(m.Name())
			mName = strings.TrimPrefix(mName, "services.")

			comment := m.SourceCodeInfo().LeadingComments()
			comment = strings.TrimSpace(comment)
			if !strings.Contains(comment, "@dbscanner") {
				continue
			}

			// Find comment in multiline comment
			sc := bufio.NewScanner(strings.NewReader(comment))
			for sc.Scan() {
				text := strings.TrimSpace(sc.Text())
				if strings.HasPrefix(text, "@dbscanner") {
					comment = text
					break
				}
			}

			dbscanner, err := p.parseComment(mName, comment)
			if err != nil {
				p.Failf("failed to parse comment for %s message in file %s (comment: '%s'), error. %w", mName, f.InputPath(), comment, err)
				return
			}
			if dbscanner == nil {
				p.Failf("failed to parse comment for %s message in file %s (comment: '%s')", mName, f.InputPath(), comment)
				return
			}

			data.Messages[mName] = dbscanner
		}

		if len(data.Messages) == 0 {
			continue
		}

		name := p.ctx.OutputPath(f).SetExt(".dbscanner.go")
		p.AddGeneratorTemplateFile(name.String(), p.tpl, data)
	}
}

func (p *DBScannerModule) parseComment(_ string, comment string) (*DBScannerInfo, error) {
	comment = strings.TrimPrefix(comment, "@dbscanner: ")
	comment = strings.TrimPrefix(comment, "@dbscanner")

	perm := &DBScannerInfo{
		Unmarshal: "proto.Unmarshal",
		Marshal:   "proto.Marshal",
	}

	if comment == "" {
		return perm, nil
	}

	split := strings.Split(comment, ",")

	for i := range split {
		k, v, _ := strings.Cut(split[i], "=")
		_ = v

		switch strings.ToLower(k) {
		case "json":
			perm.Unmarshal = "protojson.Unmarshal"
			perm.Marshal = "protoutils.Marshal"
			continue

		case "partial":
			perm.Unmarshal = "protoutils.UnmarshalPartial"
			perm.Marshal = "protoutils.Marshal"
			continue
		}
	}

	return perm, nil
}

type DBScannerInfo struct {
	Unmarshal string
	Marshal   string
}

const dbscannerTpl = `// Code generated by protoc-gen-customizer. DO NOT EDIT.
// source: {{ .F.InputPath }}

package {{ package .F }}

import (
	"database/sql/driver"

	"github.com/fivenet-app/fivenet/v2025/pkg/utils/protoutils"
	"github.com/paulmach/orb"
	"google.golang.org/protobuf/proto"
)

{{- range $message, $info := .Messages }}
// Scan implements driver.Valuer for protobuf {{ $message }}.
func (x *{{ $message }}) Scan(value any) error {
	switch t := value.(type) {
	case string:
		return {{ $info.Unmarshal }}([]byte(t), x)
	case []byte:
		return {{ $info.Unmarshal }}(t, x)
	}
	return nil
}

// Value marshals the {{ $message }} value into driver.Valuer.
func (x *{{ $message }}) Value() (driver.Value, error) {
	if x == nil {
		return nil, nil
	}

	out, err := {{ $info.Marshal }}(x)
	return string(out), err
}
{{- end }}
`
