package main

import (
	"slices"
	"strings"
	"text/template"

	itemslenpb "github.com/fivenet-app/fivenet/v2025/gen/go/proto/codegen/itemslen"
	pgs "github.com/lyft/protoc-gen-star/v2"
	pgsgo "github.com/lyft/protoc-gen-star/v2/lang/go"
)

// ItemsLenModule holds all state for this plugin.
type ItemsLenModule struct {
	*pgs.ModuleBase

	ctx pgsgo.Context
	tpl *template.Template
}

func ItemsLen() *ItemsLenModule { return &ItemsLenModule{ModuleBase: &pgs.ModuleBase{}} }

func (m *ItemsLenModule) InitContext(c pgs.BuildContext) {
	m.ModuleBase.InitContext(c)
	m.ctx = pgsgo.InitContext(c.Parameters())

	// same template pattern & helpers as your dbscanner module
	// (exposes ctx.PackageName for "package ..." and ctx.Name for Go identifiers)
	tpl := template.New("itemslen").Funcs(map[string]any{
		"package": m.ctx.PackageName,
		"name":    m.ctx.Name,
	})
	m.tpl = template.Must(tpl.Parse(itemsLenTpl))
}

func (m *ItemsLenModule) Name() string { return "itemslen" }

func (m *ItemsLenModule) Execute(
	targets map[string]pgs.File,
	_ map[string]pgs.Package,
) []pgs.Artifact {
	// Group files by input directory, mirroring your dbscannerâ€™s approach.
	visited := map[string][]pgs.File{}
	for _, t := range targets {
		key := t.File().InputPath().Dir().String()
		visited[key] = append(visited[key], t)
	}

	for _, fs := range visited {
		m.generate(fs)
	}
	return m.Artifacts()
}

func (m *ItemsLenModule) generate(fs []pgs.File) {
	// deterministic order like your dbscanner
	slices.SortFunc(fs, func(a, b pgs.File) int {
		return strings.Compare(a.File().InputPath().String(), b.File().InputPath().String())
	})

	for _, f := range fs {
		data := struct {
			F       pgs.File
			Targets map[string][]string // message -> annotated repeated fields (Go names)
		}{
			F:       f,
			Targets: map[string][]string{},
		}

		for _, msg := range f.Messages() {
			var fields []string
			for _, fld := range msg.Fields() {
				if !fld.Type().IsRepeated() {
					continue
				}

				// check if the field option is present and true
				var val bool
				ok, err := fld.Extension(itemslenpb.E_ItemsLen, &val)
				if ok && err == nil && val {
					// This field is annotated for ItemsLen
					fields = append(fields, fld.Name().UpperCamelCase().String())
				}
			}

			if len(fields) > 0 {
				data.Targets[msg.Name().UpperCamelCase().String()] = fields
			}
			m.Debugf(
				"ItemsLen: %s has %d annotated repeated fields",
				msg.Name().String(),
				len(fields),
			)
		}

		if len(data.Targets) == 0 {
			continue
		}

		// Write a single sibling file per .proto, same as dbscanner.
		name := m.ctx.OutputPath(f).SetExt(".itemslen.go")
		m.AddGeneratorTemplateFile(name.String(), m.tpl, data)
	}
}

const itemsLenTpl = `// Code generated by protoc-gen-itemslen. DO NOT EDIT.
// source: {{ .F.InputPath }}

package {{ package .F }}

{{- range $msg, $fields := .Targets }}
{{- if eq (len $fields) 1 }}
// ItemsLen returns the length of {{ index $fields 0 }}.
func (m *{{ $msg }}) ItemsLen() int {
	if m == nil { return 0 }
	return len(m.Get{{ index $fields 0 }}())
}
{{- else }}
{{- range $fields }}
// ItemsLen{{ . }} returns the length of {{ . }}.
func (m *{{ $msg }}) ItemsLen{{ . }}() int {
	if m == nil { return 0 }
	return len(m.Get{{ . }}())
}
{{- end }}
{{- end }}
{{ end }}`
