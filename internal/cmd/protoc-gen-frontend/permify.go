package main

import (
	"fmt"
	"path"
	"reflect"
	"slices"
	"strings"
	"text/template"

	permspb "github.com/fivenet-app/fivenet/v2025/gen/go/proto/codegen/perms"
	"github.com/fivenet-app/fivenet/v2025/gen/go/proto/resources/permissions"
	pgs "github.com/lyft/protoc-gen-star/v2"
	pgsgo "github.com/lyft/protoc-gen-star/v2/lang/go"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

// PermifyPlugin is a protoc-gen-star module that generates a TypeScript file
// defining permission types based on comments in the protobuf service methods.
type PermifyModule struct {
	*pgs.ModuleBase

	ctx pgsgo.Context
	tpl *template.Template
}

var fns = template.FuncMap{
	"last": func(x int, a any) bool {
		return x == reflect.ValueOf(a).Len()-1
	},
	"title": func(s string) string {
		c := cases.Title(language.English)
		return c.String(s)
	},
}

// Permify returns an initialized PermifyPlugin.
func Permify() *PermifyModule {
	return &PermifyModule{ModuleBase: &pgs.ModuleBase{}}
}

func (p *PermifyModule) InitContext(c pgs.BuildContext) {
	p.ModuleBase.InitContext(c)
	p.ctx = pgsgo.InitContext(c.Parameters())

	tpl := template.New("permify").Funcs(fns)

	p.tpl = template.Must(tpl.Parse(permsTpl))
}

// Name satisfies the generator.Plugin interface.
func (p *PermifyModule) Name() string { return "permify" }

func (p *PermifyModule) Execute(
	targets map[string]pgs.File,
	pkgs map[string]pgs.Package,
) []pgs.Artifact {
	visited := map[string][]pgs.File{}
	for _, t := range targets {
		key := t.File().InputPath().Dir().String()
		if _, ok := visited[key]; !ok {
			visited[key] = []pgs.File{t}
			continue
		}

		visited[key] = append(visited[key], t)
	}

	data := struct {
		FS          []pgs.File
		Permissions map[string]map[string]*Perm
	}{
		FS:          []pgs.File{},
		Permissions: map[string]map[string]*Perm{},
	}
	for _, fs := range visited {
		slices.SortFunc(fs, func(a, b pgs.File) int {
			return strings.Compare(a.File().InputPath().String(), b.File().InputPath().String())
		})

		for _, f := range fs {
			if len(f.Services()) == 0 {
				continue
			}

			data.FS = append(data.FS, f)
			for _, s := range f.Services() {
				sName := strings.TrimPrefix(string(s.FullyQualifiedName()), ".services.")

				p.Debugf("Service: %s", sName)

				for _, m := range s.Methods() {
					mName := string(m.Name())
					mName = strings.TrimPrefix(mName, "services.")

					// check if the field option is present and true
					var val permspb.FieldOptions
					ok, err := m.Extension(permspb.E_Perms, &val)
					if err != nil {
						p.Fail("error reading perms option:", err)
					}

					var perm *Perm
					if !ok {
						continue
					}

					if !val.Enabled {
						p.Fail("perms option not enabled for method:", sName, mName)
						continue
					}

					perm = &Perm{
						Name: mName,
					}
					if val.Name != nil && *val.Name != "" {
						perm.Name = *val.Name
					}
					if val.Service != nil && *val.Service != "" {
						perm.Service = val.Service
					}

					perm.Attrs = make([]Attr, len(val.Attrs))
					for i, a := range val.Attrs {
						atype := "StringList"
						switch a.Type {
						case permissions.AttributeType_ATTRIBUTE_TYPE_JOB_LIST:
							atype = "JobList"
						case permissions.AttributeType_ATTRIBUTE_TYPE_JOB_GRADE_LIST:
							atype = "JobGradeList"
						}

						perm.Attrs[i] = Attr{
							Key:  a.Key,
							Type: atype,
						}
						if a.ValidStringList != nil {
							perm.Attrs[i].Valid += "[]string{"
							for _, v := range a.ValidStringList {
								perm.Attrs[i].Valid += fmt.Sprintf("%q, ", v)
							}
							perm.Attrs[i].Valid += "}"
						}
					}

					if perm.Name != mName {
						continue
					}

					if perm.Name == "Superuser" || perm.Name == "Any" {
						continue
					}

					if _, ok := data.Permissions[sName]; !ok {
						data.Permissions[sName] = map[string]*Perm{}
					}
					if _, ok := data.Permissions[sName][perm.Name]; !ok {
						data.Permissions[sName][perm.Name] = perm
						p.Debugf("Permission added: %q - %+v\n", mName, perm)
					} else {
						p.Debugf("Permission already in list: %q - %+v\n", mName, perm)
					}
				}
			}
		}
	}

	slices.SortStableFunc(data.FS, func(a, b pgs.File) int {
		return strings.Compare(a.FullyQualifiedName(), b.FullyQualifiedName())
	})

	p.AddGeneratorTemplateFile(path.Join("perms.ts"), p.tpl, data)

	return p.Artifacts()
}

const permsTpl = `// Code generated by protoc-gen-fronthelper. DO NOT EDIT.
{{- range $f := .FS }}
// source: {{ $f.File.InputPath }}
{{- end }}

export type Perms =
    | 'Superuser/CanBeSuperuser'
    | 'Superuser/Superuser'
    | 'TODOService/TODOMethod'
{{- range $sName, $service := $.Permissions -}}
	{{- range $i, $perm := $service }}
	| '{{ $sName }}/{{ $perm.Name }}'
		{{- end }}
{{- end -}};
`

type Perm struct {
	Service *string
	Name    string
	Attrs   []Attr
}

type Attr struct {
	Key     string
	Type    string
	Valid   string
	Default string
}
