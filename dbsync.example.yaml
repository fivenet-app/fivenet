# Debug or release mode (affects performance)
mode: "release"

# Can be "DEBUG", "INFO", "WARN", "ERROR", "FATAL"
logLevel: "INFO"
log:
  logToFile: false
  file:
    path: "dbsync.log"
    rotation:
      compress: false

watchConfig: true

stateFile: "dbsync.state.yaml"

# The target FiveNet instance to sync data to (the instance must have the sync API enabled and you need a valid token)
destination:
  # Host + port to your FiveNet instance (requires HTTPS/valid TLS certs, unless insecure is set to `true`)
  url: "fivenet.example.com"
  token: "YOUR_SYNC_API_TOKEN"
  # Disable TLS verification (not recommended)
  insecure: false
  # Sync Interval can also be specified per table in the `tables:` section
  syncInterval: 5s

# Your gameservers' database details
# Changes to the source require a restart of the dbsync.
source:
  # Refer to https://github.com/go-sql-driver/mysql#dsn-data-source-name for details
  # Please note that the `parseTime` parameter is allows set to true
  dsn: "DB_USER:DB_PASS@tcp(DB_HOST:DB_PORT)/DB_NAME?collation=utf8mb4_unicode_ci&loc=Europe%2FBerlin"
  # For the local test database using `docker-compose`
  #dsn: "fivenet:changeme@tcp(localhost:3306)/fivenet?collation=utf8mb4_unicode_ci&loc=Europe%2FBerlin"
  maxOpenConns: 12
  maxIdleConns: 5
  connMaxIdleTime: 10m
  connMaxLifetime: 45m
  disableLocking: false

# A query for each "piece of data" FiveNet needs to function
tables:
  # The example queries here are for the ESX framework
  jobs:
    enabled: true
    # Name of the table for this data (in case you are using a custom query or are joining
    # multiple tables this should be the primary one)
    tableName: "jobs"
    # Jobs table column names (only used when no custom `query` is specified)
    columns:
      name: "name"
      label: "label"
    # Custom query to retrieve the jobs (you must return the required columns)
    #
    # Must return result columns named: `job.name`, `job.label`
    #query: |
    #  SELECT
    #    `name` AS `job.name`,
    #    `label` AS `job.label`
    #  FROM
    #    `jobs`
    #  OFFSET $offset;
    filters: []
      # Example filter to drop jobs starting with "off_", to enable uncomment this section
      # This is useful in combination with the `users:` jobs filters below if you
      # have "off-duty" jobs that need to be rewritten to their "actual" job name
      #- pattern: '^off_'
      #  action: drop
  jobGrades:
    enabled: true
    # Name of the table for this data (in case you are using a custom query or are joining
    # multiple tables this should be the primary one)
    tableName: "job_grades"
    # Job grades table column names (only used when no custom `query` is specified)
    columns:
      jobName: "job_name"
      grade: "grade"
      name: "name"
      label: "label"
    # Custom query to retrieve the job grades data (you must return the required columns)
    #
    # Must return result columns named: `job_grade.job_name`, `job_grade.grade`, `job_grade.name`, `job_grade.label`
    # (With a `WHERE`-condition for the `job_name` column using the `$jobName` parameter)
    #query: |
    #  SELECT
    #    `job_name` AS `job_grade.job_name`,
    #    `grade` AS `job_grade.grade`,
    #    `name` AS `job_grade.name`,
    #    `label` AS `job_grade.label`
    #  FROM
    #    `job_grades`
    #  WHERE
    #    `job_grades`.`job_name` = $jobName
    #  OFFSET $offset;
  licenses:
    enabled: true
    # Name of the table for this data (in case you are using a custom query or are joining
    # multiple tables this should be the primary one)
    tableName: "licenses"
    # Licenses table column names (only used when no custom `query` is specified)
    columns:
      type: "type"
      label: "label"
    # Custom query to retrieve the available licenses (not per user, see `userLicenses:` below)
    #
    # Must return result columns named: `license.type`, `license.label`
    #query: |
    #  SELECT
    #    `licenses`.`type` AS `license.type`,
    #    `licenses`.`label` AS `license.label`
    #  FROM
    #    `licenses`
    #  LIMIT $limit
    #  OFFSET $offset;
  users:
    enabled: true
    # Name of the table for this data (in case you are using a custom query or are joining
    # multiple tables this should be the primary one)
    tableName: "users"
    # If your "players"/"users" data has a timestamp/datetime column that is updated on update,
    # configure it here so that after the initial sync only the changed data is synced again.
    updatedTimeColumn: "last_seen"
    # Users table column names (used to build the default query if no custom `query` is specified)
    # **NOTE**: The `id` and `identifier` columns are required to be set, even when a custom query is used.
    # They are used to build the where condition for incremental syncs.
    columns:
      id: "id"
      identifier: "identifier"
      group: "group"
      firstname: "firstname"
      lastname: "lastname"
      dateOfBirth: "dateofbirth"
      job: "job"
      jobGrade: "job_grade"
      sex: "sex"
      phoneNumber: "phone_number"
      height: "height"
      visum: "visum"
      playtime: "playtime"
    # Custom query to retrieve users data.
    # The identifier column should be a smart combination of values when using a multichar system.
    # E.g., it is prefered to use a ESX like identifier layout for that case `charX:LICENSE`
    #
    # Must return result columns named: `user.user_id`, `user.identifier`, `user.group`, `user.firstname`,
    # `user.lastname`, `user.dateofbirth`, `user.job`, `user.job_grade`, `user.sex`, `user.phone_number` columns
    # Optional columns: `user.height`, `user.visum`, `user.playtime`
    #query: |
    #  SELECT
    #    `id` AS `user.id`,
    #    `identifier` AS `user.identifier`,
    #    `group` AS `user.group`,
    #    `firstname` AS `user.firstname`,
    #    `lastname` AS `user.lastname`,
    #    `dateofbirth` AS `user.dateofbirth`,
    #    `job` AS `user.job`,
    #    `job_grade` AS `user.job_grade`,
    #    `sex` AS `user.sex`,
    #    `phone_number` AS `user.phone_number`,
    #    `height` AS `user.height`,
    #    `visum` AS `user.visum`,
    #    `playtime` AS `user.playtime`
    #  FROM
    #    `users`
    #  $whereCondition
    #  LIMIT $limit
    #  OFFSET $offset;
    # If a lastname is not returned by the query, attempt to split the firstname into "two" parts
    splitName: true
    # Normalize date of birth value to the output format if possible
    # Please see the Go `time` pkg documentation on potential date format layouts: https://pkg.go.dev/time#Layout
    dateOfBirth:
      formats:
        - "2006-01-02" # 2000-10-18 = YYYY-MM-DD
        - "02/01/2006" # 09/06/1993 = MM/DD/YYYY
        - "02.01.2006" # 01.08.1982 = DD.MM.YYYY
      outputFormat: "02.01.2006" # DD.MM.YYYY
    valueMapping:
      # This allows to map values to different values for FiveNet
      # E.g., the sex of a char must be either `m`, `f`, or `d`
      sex:
        fallback: 'm'
        values:
          '1': 'f'
    # If the firstname or lastname is empty or null, do not sync the user at all
    ignoreEmptyNames: true
    # Filters allow to modify certain values before they are sent to FiveNet
    filters:
      jobs: []
        # Example: `off_police` -> `police`
        #- pattern: '^off_'
        #  action: replace
        #  replacement: ''
        # Example: `ambulance` -> `ems`
        #- pattern: '^ambulance$'
        #  action: replace
        #  replacement: 'ems'
  userLicenses:
    enabled: true
    # Name of the table for this data (in case you are using a custom query or are joining
    # multiple tables this should be the primary one)
    tableName: "user_licenses"
    # User licenses table column names (only used when no custom `query` is specified)
    columns:
      type: "type"
      ownerIdentifier: "owner"
    # Custom query to retrieve the licenses for a **specific** user, the `$identifier` parameter is the placeholder for the user's identifier
    #
    # Must return result columns named: `user_license.type`, `user_license.owner`
    #query: |
    #  SELECT
    #    `type` AS `user_license.type`,
    #    `owner` AS `user_license.owner`
    #  FROM
    #    `user_licenses`
    #  WHERE
    #    `user_licenses`.`owner` = $identifier
    #  LIMIT $limit
    #  OFFSET $offset;
  vehicles:
    enabled: true
    # Name of the table for this data (in case you are using a custom query or are joining
    # multiple tables this should be the primary one)
    tableName: "owned_vehicles"
    # By default the dbsync will attempt to add the column if it does not exist, but you can
    # disable that by commenting this out. It is recommended to leave it enabled, for
    # performance reasons.
    updatedTimeColumn: "last_seen"
    # Vehicles table column names (only used when no custom `query` is specified)
    columns:
      ownerIdentifier: "owner"
      # Use this if vehicles are linked by user DB ID instead of identifier
      #ownerId: "owner"
      plate: "plate"
      type: "type"
      model: "model"
    # Custom query to retrieve all vehicles
    #
    # Must return result columns named: `vehicle.owner_id` (the user's DB ID) or `vehicle.owner_identifier`,
    # `vehicle.plate`, `vehicle.type`
    # Optional columns: `vehicle.model`, `vehicle.job` (for job specific vehicles)
    #query: |
    #  SELECT
    #    `owner` AS `vehicle.owner_identifier`,
    #    `plate` AS `vehicle.plate`,
    #    `type` AS `vehicle.type`,
    #    `model` AS `vehicle.model`
    #  FROM
    #    `owned_vehicles`
    #  LIMIT $limit
    #  OFFSET $offset;
