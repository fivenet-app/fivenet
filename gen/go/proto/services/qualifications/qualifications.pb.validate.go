// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: services/qualifications/qualifications.proto

package qualifications

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"

	qualifications "github.com/fivenet-app/fivenet/gen/go/proto/resources/qualifications"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort

	_ = qualifications.RequestStatus(0)
)

// Validate checks the field values on ListQualificationsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListQualificationsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListQualificationsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListQualificationsRequestMultiError, or nil if none found.
func (m *ListQualificationsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListQualificationsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetPagination() == nil {
		err := ListQualificationsRequestValidationError{
			field:  "Pagination",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetPagination()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListQualificationsRequestValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListQualificationsRequestValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPagination()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListQualificationsRequestValidationError{
				field:  "Pagination",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Sort != nil {

		if all {
			switch v := interface{}(m.GetSort()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListQualificationsRequestValidationError{
						field:  "Sort",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListQualificationsRequestValidationError{
						field:  "Sort",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSort()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListQualificationsRequestValidationError{
					field:  "Sort",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Search != nil {
		// no validation rules for Search
	}

	if len(errors) > 0 {
		return ListQualificationsRequestMultiError(errors)
	}

	return nil
}

// ListQualificationsRequestMultiError is an error wrapping multiple validation
// errors returned by ListQualificationsRequest.ValidateAll() if the
// designated constraints aren't met.
type ListQualificationsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListQualificationsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListQualificationsRequestMultiError) AllErrors() []error { return m }

// ListQualificationsRequestValidationError is the validation error returned by
// ListQualificationsRequest.Validate if the designated constraints aren't met.
type ListQualificationsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListQualificationsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListQualificationsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListQualificationsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListQualificationsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListQualificationsRequestValidationError) ErrorName() string {
	return "ListQualificationsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListQualificationsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListQualificationsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListQualificationsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListQualificationsRequestValidationError{}

// Validate checks the field values on ListQualificationsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListQualificationsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListQualificationsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListQualificationsResponseMultiError, or nil if none found.
func (m *ListQualificationsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListQualificationsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPagination()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListQualificationsResponseValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListQualificationsResponseValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPagination()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListQualificationsResponseValidationError{
				field:  "Pagination",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetQualifications() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListQualificationsResponseValidationError{
						field:  fmt.Sprintf("Qualifications[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListQualificationsResponseValidationError{
						field:  fmt.Sprintf("Qualifications[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListQualificationsResponseValidationError{
					field:  fmt.Sprintf("Qualifications[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListQualificationsResponseMultiError(errors)
	}

	return nil
}

// ListQualificationsResponseMultiError is an error wrapping multiple
// validation errors returned by ListQualificationsResponse.ValidateAll() if
// the designated constraints aren't met.
type ListQualificationsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListQualificationsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListQualificationsResponseMultiError) AllErrors() []error { return m }

// ListQualificationsResponseValidationError is the validation error returned
// by ListQualificationsResponse.Validate if the designated constraints aren't met.
type ListQualificationsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListQualificationsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListQualificationsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListQualificationsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListQualificationsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListQualificationsResponseValidationError) ErrorName() string {
	return "ListQualificationsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListQualificationsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListQualificationsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListQualificationsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListQualificationsResponseValidationError{}

// Validate checks the field values on GetQualificationRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetQualificationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetQualificationRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetQualificationRequestMultiError, or nil if none found.
func (m *GetQualificationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetQualificationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for QualificationId

	if m.WithExam != nil {
		// no validation rules for WithExam
	}

	if len(errors) > 0 {
		return GetQualificationRequestMultiError(errors)
	}

	return nil
}

// GetQualificationRequestMultiError is an error wrapping multiple validation
// errors returned by GetQualificationRequest.ValidateAll() if the designated
// constraints aren't met.
type GetQualificationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetQualificationRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetQualificationRequestMultiError) AllErrors() []error { return m }

// GetQualificationRequestValidationError is the validation error returned by
// GetQualificationRequest.Validate if the designated constraints aren't met.
type GetQualificationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetQualificationRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetQualificationRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetQualificationRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetQualificationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetQualificationRequestValidationError) ErrorName() string {
	return "GetQualificationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetQualificationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetQualificationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetQualificationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetQualificationRequestValidationError{}

// Validate checks the field values on GetQualificationResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetQualificationResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetQualificationResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetQualificationResponseMultiError, or nil if none found.
func (m *GetQualificationResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetQualificationResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetQualification()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetQualificationResponseValidationError{
					field:  "Qualification",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetQualificationResponseValidationError{
					field:  "Qualification",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQualification()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetQualificationResponseValidationError{
				field:  "Qualification",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetQualificationResponseMultiError(errors)
	}

	return nil
}

// GetQualificationResponseMultiError is an error wrapping multiple validation
// errors returned by GetQualificationResponse.ValidateAll() if the designated
// constraints aren't met.
type GetQualificationResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetQualificationResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetQualificationResponseMultiError) AllErrors() []error { return m }

// GetQualificationResponseValidationError is the validation error returned by
// GetQualificationResponse.Validate if the designated constraints aren't met.
type GetQualificationResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetQualificationResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetQualificationResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetQualificationResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetQualificationResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetQualificationResponseValidationError) ErrorName() string {
	return "GetQualificationResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetQualificationResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetQualificationResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetQualificationResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetQualificationResponseValidationError{}

// Validate checks the field values on CreateQualificationRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateQualificationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateQualificationRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateQualificationRequestMultiError, or nil if none found.
func (m *CreateQualificationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateQualificationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetQualification() == nil {
		err := CreateQualificationRequestValidationError{
			field:  "Qualification",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetQualification()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateQualificationRequestValidationError{
					field:  "Qualification",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateQualificationRequestValidationError{
					field:  "Qualification",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQualification()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateQualificationRequestValidationError{
				field:  "Qualification",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateQualificationRequestMultiError(errors)
	}

	return nil
}

// CreateQualificationRequestMultiError is an error wrapping multiple
// validation errors returned by CreateQualificationRequest.ValidateAll() if
// the designated constraints aren't met.
type CreateQualificationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateQualificationRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateQualificationRequestMultiError) AllErrors() []error { return m }

// CreateQualificationRequestValidationError is the validation error returned
// by CreateQualificationRequest.Validate if the designated constraints aren't met.
type CreateQualificationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateQualificationRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateQualificationRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateQualificationRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateQualificationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateQualificationRequestValidationError) ErrorName() string {
	return "CreateQualificationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateQualificationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateQualificationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateQualificationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateQualificationRequestValidationError{}

// Validate checks the field values on CreateQualificationResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateQualificationResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateQualificationResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateQualificationResponseMultiError, or nil if none found.
func (m *CreateQualificationResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateQualificationResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for QualificationId

	if len(errors) > 0 {
		return CreateQualificationResponseMultiError(errors)
	}

	return nil
}

// CreateQualificationResponseMultiError is an error wrapping multiple
// validation errors returned by CreateQualificationResponse.ValidateAll() if
// the designated constraints aren't met.
type CreateQualificationResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateQualificationResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateQualificationResponseMultiError) AllErrors() []error { return m }

// CreateQualificationResponseValidationError is the validation error returned
// by CreateQualificationResponse.Validate if the designated constraints
// aren't met.
type CreateQualificationResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateQualificationResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateQualificationResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateQualificationResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateQualificationResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateQualificationResponseValidationError) ErrorName() string {
	return "CreateQualificationResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateQualificationResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateQualificationResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateQualificationResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateQualificationResponseValidationError{}

// Validate checks the field values on UpdateQualificationRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateQualificationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateQualificationRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateQualificationRequestMultiError, or nil if none found.
func (m *UpdateQualificationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateQualificationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetQualification() == nil {
		err := UpdateQualificationRequestValidationError{
			field:  "Qualification",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetQualification()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateQualificationRequestValidationError{
					field:  "Qualification",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateQualificationRequestValidationError{
					field:  "Qualification",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQualification()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateQualificationRequestValidationError{
				field:  "Qualification",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateQualificationRequestMultiError(errors)
	}

	return nil
}

// UpdateQualificationRequestMultiError is an error wrapping multiple
// validation errors returned by UpdateQualificationRequest.ValidateAll() if
// the designated constraints aren't met.
type UpdateQualificationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateQualificationRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateQualificationRequestMultiError) AllErrors() []error { return m }

// UpdateQualificationRequestValidationError is the validation error returned
// by UpdateQualificationRequest.Validate if the designated constraints aren't met.
type UpdateQualificationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateQualificationRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateQualificationRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateQualificationRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateQualificationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateQualificationRequestValidationError) ErrorName() string {
	return "UpdateQualificationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateQualificationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateQualificationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateQualificationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateQualificationRequestValidationError{}

// Validate checks the field values on UpdateQualificationResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateQualificationResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateQualificationResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateQualificationResponseMultiError, or nil if none found.
func (m *UpdateQualificationResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateQualificationResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for QualificationId

	if len(errors) > 0 {
		return UpdateQualificationResponseMultiError(errors)
	}

	return nil
}

// UpdateQualificationResponseMultiError is an error wrapping multiple
// validation errors returned by UpdateQualificationResponse.ValidateAll() if
// the designated constraints aren't met.
type UpdateQualificationResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateQualificationResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateQualificationResponseMultiError) AllErrors() []error { return m }

// UpdateQualificationResponseValidationError is the validation error returned
// by UpdateQualificationResponse.Validate if the designated constraints
// aren't met.
type UpdateQualificationResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateQualificationResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateQualificationResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateQualificationResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateQualificationResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateQualificationResponseValidationError) ErrorName() string {
	return "UpdateQualificationResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateQualificationResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateQualificationResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateQualificationResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateQualificationResponseValidationError{}

// Validate checks the field values on DeleteQualificationRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteQualificationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteQualificationRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteQualificationRequestMultiError, or nil if none found.
func (m *DeleteQualificationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteQualificationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for QualificationId

	if len(errors) > 0 {
		return DeleteQualificationRequestMultiError(errors)
	}

	return nil
}

// DeleteQualificationRequestMultiError is an error wrapping multiple
// validation errors returned by DeleteQualificationRequest.ValidateAll() if
// the designated constraints aren't met.
type DeleteQualificationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteQualificationRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteQualificationRequestMultiError) AllErrors() []error { return m }

// DeleteQualificationRequestValidationError is the validation error returned
// by DeleteQualificationRequest.Validate if the designated constraints aren't met.
type DeleteQualificationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteQualificationRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteQualificationRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteQualificationRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteQualificationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteQualificationRequestValidationError) ErrorName() string {
	return "DeleteQualificationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteQualificationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteQualificationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteQualificationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteQualificationRequestValidationError{}

// Validate checks the field values on DeleteQualificationResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteQualificationResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteQualificationResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteQualificationResponseMultiError, or nil if none found.
func (m *DeleteQualificationResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteQualificationResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteQualificationResponseMultiError(errors)
	}

	return nil
}

// DeleteQualificationResponseMultiError is an error wrapping multiple
// validation errors returned by DeleteQualificationResponse.ValidateAll() if
// the designated constraints aren't met.
type DeleteQualificationResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteQualificationResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteQualificationResponseMultiError) AllErrors() []error { return m }

// DeleteQualificationResponseValidationError is the validation error returned
// by DeleteQualificationResponse.Validate if the designated constraints
// aren't met.
type DeleteQualificationResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteQualificationResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteQualificationResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteQualificationResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteQualificationResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteQualificationResponseValidationError) ErrorName() string {
	return "DeleteQualificationResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteQualificationResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteQualificationResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteQualificationResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteQualificationResponseValidationError{}

// Validate checks the field values on GetQualificationAccessRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetQualificationAccessRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetQualificationAccessRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetQualificationAccessRequestMultiError, or nil if none found.
func (m *GetQualificationAccessRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetQualificationAccessRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for QualificationId

	if len(errors) > 0 {
		return GetQualificationAccessRequestMultiError(errors)
	}

	return nil
}

// GetQualificationAccessRequestMultiError is an error wrapping multiple
// validation errors returned by GetQualificationAccessRequest.ValidateAll()
// if the designated constraints aren't met.
type GetQualificationAccessRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetQualificationAccessRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetQualificationAccessRequestMultiError) AllErrors() []error { return m }

// GetQualificationAccessRequestValidationError is the validation error
// returned by GetQualificationAccessRequest.Validate if the designated
// constraints aren't met.
type GetQualificationAccessRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetQualificationAccessRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetQualificationAccessRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetQualificationAccessRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetQualificationAccessRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetQualificationAccessRequestValidationError) ErrorName() string {
	return "GetQualificationAccessRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetQualificationAccessRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetQualificationAccessRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetQualificationAccessRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetQualificationAccessRequestValidationError{}

// Validate checks the field values on GetQualificationAccessResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetQualificationAccessResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetQualificationAccessResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetQualificationAccessResponseMultiError, or nil if none found.
func (m *GetQualificationAccessResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetQualificationAccessResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetAccess() == nil {
		err := GetQualificationAccessResponseValidationError{
			field:  "Access",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetAccess()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetQualificationAccessResponseValidationError{
					field:  "Access",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetQualificationAccessResponseValidationError{
					field:  "Access",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAccess()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetQualificationAccessResponseValidationError{
				field:  "Access",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetQualificationAccessResponseMultiError(errors)
	}

	return nil
}

// GetQualificationAccessResponseMultiError is an error wrapping multiple
// validation errors returned by GetQualificationAccessResponse.ValidateAll()
// if the designated constraints aren't met.
type GetQualificationAccessResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetQualificationAccessResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetQualificationAccessResponseMultiError) AllErrors() []error { return m }

// GetQualificationAccessResponseValidationError is the validation error
// returned by GetQualificationAccessResponse.Validate if the designated
// constraints aren't met.
type GetQualificationAccessResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetQualificationAccessResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetQualificationAccessResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetQualificationAccessResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetQualificationAccessResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetQualificationAccessResponseValidationError) ErrorName() string {
	return "GetQualificationAccessResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetQualificationAccessResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetQualificationAccessResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetQualificationAccessResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetQualificationAccessResponseValidationError{}

// Validate checks the field values on SetQualificationAccessRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SetQualificationAccessRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetQualificationAccessRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// SetQualificationAccessRequestMultiError, or nil if none found.
func (m *SetQualificationAccessRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SetQualificationAccessRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for QualificationId

	if m.GetAccess() == nil {
		err := SetQualificationAccessRequestValidationError{
			field:  "Access",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetAccess()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SetQualificationAccessRequestValidationError{
					field:  "Access",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SetQualificationAccessRequestValidationError{
					field:  "Access",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAccess()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SetQualificationAccessRequestValidationError{
				field:  "Access",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SetQualificationAccessRequestMultiError(errors)
	}

	return nil
}

// SetQualificationAccessRequestMultiError is an error wrapping multiple
// validation errors returned by SetQualificationAccessRequest.ValidateAll()
// if the designated constraints aren't met.
type SetQualificationAccessRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetQualificationAccessRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetQualificationAccessRequestMultiError) AllErrors() []error { return m }

// SetQualificationAccessRequestValidationError is the validation error
// returned by SetQualificationAccessRequest.Validate if the designated
// constraints aren't met.
type SetQualificationAccessRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetQualificationAccessRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetQualificationAccessRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetQualificationAccessRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetQualificationAccessRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetQualificationAccessRequestValidationError) ErrorName() string {
	return "SetQualificationAccessRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SetQualificationAccessRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetQualificationAccessRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetQualificationAccessRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetQualificationAccessRequestValidationError{}

// Validate checks the field values on SetQualificationAccessResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SetQualificationAccessResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetQualificationAccessResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// SetQualificationAccessResponseMultiError, or nil if none found.
func (m *SetQualificationAccessResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SetQualificationAccessResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return SetQualificationAccessResponseMultiError(errors)
	}

	return nil
}

// SetQualificationAccessResponseMultiError is an error wrapping multiple
// validation errors returned by SetQualificationAccessResponse.ValidateAll()
// if the designated constraints aren't met.
type SetQualificationAccessResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetQualificationAccessResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetQualificationAccessResponseMultiError) AllErrors() []error { return m }

// SetQualificationAccessResponseValidationError is the validation error
// returned by SetQualificationAccessResponse.Validate if the designated
// constraints aren't met.
type SetQualificationAccessResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetQualificationAccessResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetQualificationAccessResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetQualificationAccessResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetQualificationAccessResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetQualificationAccessResponseValidationError) ErrorName() string {
	return "SetQualificationAccessResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SetQualificationAccessResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetQualificationAccessResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetQualificationAccessResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetQualificationAccessResponseValidationError{}

// Validate checks the field values on ListQualificationRequestsRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ListQualificationRequestsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListQualificationRequestsRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ListQualificationRequestsRequestMultiError, or nil if none found.
func (m *ListQualificationRequestsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListQualificationRequestsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetPagination() == nil {
		err := ListQualificationRequestsRequestValidationError{
			field:  "Pagination",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetPagination()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListQualificationRequestsRequestValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListQualificationRequestsRequestValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPagination()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListQualificationRequestsRequestValidationError{
				field:  "Pagination",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Sort != nil {

		if all {
			switch v := interface{}(m.GetSort()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListQualificationRequestsRequestValidationError{
						field:  "Sort",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListQualificationRequestsRequestValidationError{
						field:  "Sort",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSort()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListQualificationRequestsRequestValidationError{
					field:  "Sort",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.QualificationId != nil {
		// no validation rules for QualificationId
	}

	if m.UserId != nil {

		if m.GetUserId() < 0 {
			err := ListQualificationRequestsRequestValidationError{
				field:  "UserId",
				reason: "value must be greater than or equal to 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return ListQualificationRequestsRequestMultiError(errors)
	}

	return nil
}

// ListQualificationRequestsRequestMultiError is an error wrapping multiple
// validation errors returned by
// ListQualificationRequestsRequest.ValidateAll() if the designated
// constraints aren't met.
type ListQualificationRequestsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListQualificationRequestsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListQualificationRequestsRequestMultiError) AllErrors() []error { return m }

// ListQualificationRequestsRequestValidationError is the validation error
// returned by ListQualificationRequestsRequest.Validate if the designated
// constraints aren't met.
type ListQualificationRequestsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListQualificationRequestsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListQualificationRequestsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListQualificationRequestsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListQualificationRequestsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListQualificationRequestsRequestValidationError) ErrorName() string {
	return "ListQualificationRequestsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListQualificationRequestsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListQualificationRequestsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListQualificationRequestsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListQualificationRequestsRequestValidationError{}

// Validate checks the field values on ListQualificationRequestsResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ListQualificationRequestsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListQualificationRequestsResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ListQualificationRequestsResponseMultiError, or nil if none found.
func (m *ListQualificationRequestsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListQualificationRequestsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPagination()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListQualificationRequestsResponseValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListQualificationRequestsResponseValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPagination()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListQualificationRequestsResponseValidationError{
				field:  "Pagination",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetRequests() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListQualificationRequestsResponseValidationError{
						field:  fmt.Sprintf("Requests[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListQualificationRequestsResponseValidationError{
						field:  fmt.Sprintf("Requests[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListQualificationRequestsResponseValidationError{
					field:  fmt.Sprintf("Requests[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListQualificationRequestsResponseMultiError(errors)
	}

	return nil
}

// ListQualificationRequestsResponseMultiError is an error wrapping multiple
// validation errors returned by
// ListQualificationRequestsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListQualificationRequestsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListQualificationRequestsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListQualificationRequestsResponseMultiError) AllErrors() []error { return m }

// ListQualificationRequestsResponseValidationError is the validation error
// returned by ListQualificationRequestsResponse.Validate if the designated
// constraints aren't met.
type ListQualificationRequestsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListQualificationRequestsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListQualificationRequestsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListQualificationRequestsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListQualificationRequestsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListQualificationRequestsResponseValidationError) ErrorName() string {
	return "ListQualificationRequestsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListQualificationRequestsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListQualificationRequestsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListQualificationRequestsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListQualificationRequestsResponseValidationError{}

// Validate checks the field values on
// CreateOrUpdateQualificationRequestRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreateOrUpdateQualificationRequestRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// CreateOrUpdateQualificationRequestRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// CreateOrUpdateQualificationRequestRequestMultiError, or nil if none found.
func (m *CreateOrUpdateQualificationRequestRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateOrUpdateQualificationRequestRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetRequest() == nil {
		err := CreateOrUpdateQualificationRequestRequestValidationError{
			field:  "Request",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetRequest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateOrUpdateQualificationRequestRequestValidationError{
					field:  "Request",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateOrUpdateQualificationRequestRequestValidationError{
					field:  "Request",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRequest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateOrUpdateQualificationRequestRequestValidationError{
				field:  "Request",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateOrUpdateQualificationRequestRequestMultiError(errors)
	}

	return nil
}

// CreateOrUpdateQualificationRequestRequestMultiError is an error wrapping
// multiple validation errors returned by
// CreateOrUpdateQualificationRequestRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateOrUpdateQualificationRequestRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateOrUpdateQualificationRequestRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateOrUpdateQualificationRequestRequestMultiError) AllErrors() []error { return m }

// CreateOrUpdateQualificationRequestRequestValidationError is the validation
// error returned by CreateOrUpdateQualificationRequestRequest.Validate if the
// designated constraints aren't met.
type CreateOrUpdateQualificationRequestRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateOrUpdateQualificationRequestRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateOrUpdateQualificationRequestRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateOrUpdateQualificationRequestRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateOrUpdateQualificationRequestRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateOrUpdateQualificationRequestRequestValidationError) ErrorName() string {
	return "CreateOrUpdateQualificationRequestRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateOrUpdateQualificationRequestRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateOrUpdateQualificationRequestRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateOrUpdateQualificationRequestRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateOrUpdateQualificationRequestRequestValidationError{}

// Validate checks the field values on
// CreateOrUpdateQualificationRequestResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreateOrUpdateQualificationRequestResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// CreateOrUpdateQualificationRequestResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// CreateOrUpdateQualificationRequestResponseMultiError, or nil if none found.
func (m *CreateOrUpdateQualificationRequestResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateOrUpdateQualificationRequestResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRequest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateOrUpdateQualificationRequestResponseValidationError{
					field:  "Request",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateOrUpdateQualificationRequestResponseValidationError{
					field:  "Request",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRequest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateOrUpdateQualificationRequestResponseValidationError{
				field:  "Request",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateOrUpdateQualificationRequestResponseMultiError(errors)
	}

	return nil
}

// CreateOrUpdateQualificationRequestResponseMultiError is an error wrapping
// multiple validation errors returned by
// CreateOrUpdateQualificationRequestResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateOrUpdateQualificationRequestResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateOrUpdateQualificationRequestResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateOrUpdateQualificationRequestResponseMultiError) AllErrors() []error { return m }

// CreateOrUpdateQualificationRequestResponseValidationError is the validation
// error returned by CreateOrUpdateQualificationRequestResponse.Validate if
// the designated constraints aren't met.
type CreateOrUpdateQualificationRequestResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateOrUpdateQualificationRequestResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateOrUpdateQualificationRequestResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateOrUpdateQualificationRequestResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateOrUpdateQualificationRequestResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateOrUpdateQualificationRequestResponseValidationError) ErrorName() string {
	return "CreateOrUpdateQualificationRequestResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateOrUpdateQualificationRequestResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateOrUpdateQualificationRequestResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateOrUpdateQualificationRequestResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateOrUpdateQualificationRequestResponseValidationError{}

// Validate checks the field values on DeleteQualificationReqRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteQualificationReqRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteQualificationReqRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// DeleteQualificationReqRequestMultiError, or nil if none found.
func (m *DeleteQualificationReqRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteQualificationReqRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for QualificationId

	if m.GetUserId() < 0 {
		err := DeleteQualificationReqRequestValidationError{
			field:  "UserId",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteQualificationReqRequestMultiError(errors)
	}

	return nil
}

// DeleteQualificationReqRequestMultiError is an error wrapping multiple
// validation errors returned by DeleteQualificationReqRequest.ValidateAll()
// if the designated constraints aren't met.
type DeleteQualificationReqRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteQualificationReqRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteQualificationReqRequestMultiError) AllErrors() []error { return m }

// DeleteQualificationReqRequestValidationError is the validation error
// returned by DeleteQualificationReqRequest.Validate if the designated
// constraints aren't met.
type DeleteQualificationReqRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteQualificationReqRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteQualificationReqRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteQualificationReqRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteQualificationReqRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteQualificationReqRequestValidationError) ErrorName() string {
	return "DeleteQualificationReqRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteQualificationReqRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteQualificationReqRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteQualificationReqRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteQualificationReqRequestValidationError{}

// Validate checks the field values on DeleteQualificationReqResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteQualificationReqResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteQualificationReqResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// DeleteQualificationReqResponseMultiError, or nil if none found.
func (m *DeleteQualificationReqResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteQualificationReqResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteQualificationReqResponseMultiError(errors)
	}

	return nil
}

// DeleteQualificationReqResponseMultiError is an error wrapping multiple
// validation errors returned by DeleteQualificationReqResponse.ValidateAll()
// if the designated constraints aren't met.
type DeleteQualificationReqResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteQualificationReqResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteQualificationReqResponseMultiError) AllErrors() []error { return m }

// DeleteQualificationReqResponseValidationError is the validation error
// returned by DeleteQualificationReqResponse.Validate if the designated
// constraints aren't met.
type DeleteQualificationReqResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteQualificationReqResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteQualificationReqResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteQualificationReqResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteQualificationReqResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteQualificationReqResponseValidationError) ErrorName() string {
	return "DeleteQualificationReqResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteQualificationReqResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteQualificationReqResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteQualificationReqResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteQualificationReqResponseValidationError{}

// Validate checks the field values on ListQualificationsResultsRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ListQualificationsResultsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListQualificationsResultsRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ListQualificationsResultsRequestMultiError, or nil if none found.
func (m *ListQualificationsResultsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListQualificationsResultsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetPagination() == nil {
		err := ListQualificationsResultsRequestValidationError{
			field:  "Pagination",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetPagination()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListQualificationsResultsRequestValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListQualificationsResultsRequestValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPagination()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListQualificationsResultsRequestValidationError{
				field:  "Pagination",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Sort != nil {

		if all {
			switch v := interface{}(m.GetSort()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListQualificationsResultsRequestValidationError{
						field:  "Sort",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListQualificationsResultsRequestValidationError{
						field:  "Sort",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSort()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListQualificationsResultsRequestValidationError{
					field:  "Sort",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.QualificationId != nil {
		// no validation rules for QualificationId
	}

	if m.UserId != nil {

		if m.GetUserId() < 0 {
			err := ListQualificationsResultsRequestValidationError{
				field:  "UserId",
				reason: "value must be greater than or equal to 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return ListQualificationsResultsRequestMultiError(errors)
	}

	return nil
}

// ListQualificationsResultsRequestMultiError is an error wrapping multiple
// validation errors returned by
// ListQualificationsResultsRequest.ValidateAll() if the designated
// constraints aren't met.
type ListQualificationsResultsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListQualificationsResultsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListQualificationsResultsRequestMultiError) AllErrors() []error { return m }

// ListQualificationsResultsRequestValidationError is the validation error
// returned by ListQualificationsResultsRequest.Validate if the designated
// constraints aren't met.
type ListQualificationsResultsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListQualificationsResultsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListQualificationsResultsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListQualificationsResultsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListQualificationsResultsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListQualificationsResultsRequestValidationError) ErrorName() string {
	return "ListQualificationsResultsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListQualificationsResultsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListQualificationsResultsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListQualificationsResultsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListQualificationsResultsRequestValidationError{}

// Validate checks the field values on ListQualificationsResultsResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ListQualificationsResultsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListQualificationsResultsResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ListQualificationsResultsResponseMultiError, or nil if none found.
func (m *ListQualificationsResultsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListQualificationsResultsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPagination()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListQualificationsResultsResponseValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListQualificationsResultsResponseValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPagination()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListQualificationsResultsResponseValidationError{
				field:  "Pagination",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetResults() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListQualificationsResultsResponseValidationError{
						field:  fmt.Sprintf("Results[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListQualificationsResultsResponseValidationError{
						field:  fmt.Sprintf("Results[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListQualificationsResultsResponseValidationError{
					field:  fmt.Sprintf("Results[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListQualificationsResultsResponseMultiError(errors)
	}

	return nil
}

// ListQualificationsResultsResponseMultiError is an error wrapping multiple
// validation errors returned by
// ListQualificationsResultsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListQualificationsResultsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListQualificationsResultsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListQualificationsResultsResponseMultiError) AllErrors() []error { return m }

// ListQualificationsResultsResponseValidationError is the validation error
// returned by ListQualificationsResultsResponse.Validate if the designated
// constraints aren't met.
type ListQualificationsResultsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListQualificationsResultsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListQualificationsResultsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListQualificationsResultsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListQualificationsResultsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListQualificationsResultsResponseValidationError) ErrorName() string {
	return "ListQualificationsResultsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListQualificationsResultsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListQualificationsResultsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListQualificationsResultsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListQualificationsResultsResponseValidationError{}

// Validate checks the field values on CreateOrUpdateQualificationResultRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *CreateOrUpdateQualificationResultRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// CreateOrUpdateQualificationResultRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// CreateOrUpdateQualificationResultRequestMultiError, or nil if none found.
func (m *CreateOrUpdateQualificationResultRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateOrUpdateQualificationResultRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetResult() == nil {
		err := CreateOrUpdateQualificationResultRequestValidationError{
			field:  "Result",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateOrUpdateQualificationResultRequestValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateOrUpdateQualificationResultRequestValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateOrUpdateQualificationResultRequestValidationError{
				field:  "Result",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateOrUpdateQualificationResultRequestMultiError(errors)
	}

	return nil
}

// CreateOrUpdateQualificationResultRequestMultiError is an error wrapping
// multiple validation errors returned by
// CreateOrUpdateQualificationResultRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateOrUpdateQualificationResultRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateOrUpdateQualificationResultRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateOrUpdateQualificationResultRequestMultiError) AllErrors() []error { return m }

// CreateOrUpdateQualificationResultRequestValidationError is the validation
// error returned by CreateOrUpdateQualificationResultRequest.Validate if the
// designated constraints aren't met.
type CreateOrUpdateQualificationResultRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateOrUpdateQualificationResultRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateOrUpdateQualificationResultRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateOrUpdateQualificationResultRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateOrUpdateQualificationResultRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateOrUpdateQualificationResultRequestValidationError) ErrorName() string {
	return "CreateOrUpdateQualificationResultRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateOrUpdateQualificationResultRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateOrUpdateQualificationResultRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateOrUpdateQualificationResultRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateOrUpdateQualificationResultRequestValidationError{}

// Validate checks the field values on
// CreateOrUpdateQualificationResultResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreateOrUpdateQualificationResultResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// CreateOrUpdateQualificationResultResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// CreateOrUpdateQualificationResultResponseMultiError, or nil if none found.
func (m *CreateOrUpdateQualificationResultResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateOrUpdateQualificationResultResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateOrUpdateQualificationResultResponseValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateOrUpdateQualificationResultResponseValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateOrUpdateQualificationResultResponseValidationError{
				field:  "Result",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateOrUpdateQualificationResultResponseMultiError(errors)
	}

	return nil
}

// CreateOrUpdateQualificationResultResponseMultiError is an error wrapping
// multiple validation errors returned by
// CreateOrUpdateQualificationResultResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateOrUpdateQualificationResultResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateOrUpdateQualificationResultResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateOrUpdateQualificationResultResponseMultiError) AllErrors() []error { return m }

// CreateOrUpdateQualificationResultResponseValidationError is the validation
// error returned by CreateOrUpdateQualificationResultResponse.Validate if the
// designated constraints aren't met.
type CreateOrUpdateQualificationResultResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateOrUpdateQualificationResultResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateOrUpdateQualificationResultResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateOrUpdateQualificationResultResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateOrUpdateQualificationResultResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateOrUpdateQualificationResultResponseValidationError) ErrorName() string {
	return "CreateOrUpdateQualificationResultResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateOrUpdateQualificationResultResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateOrUpdateQualificationResultResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateOrUpdateQualificationResultResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateOrUpdateQualificationResultResponseValidationError{}

// Validate checks the field values on DeleteQualificationResultRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *DeleteQualificationResultRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteQualificationResultRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// DeleteQualificationResultRequestMultiError, or nil if none found.
func (m *DeleteQualificationResultRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteQualificationResultRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ResultId

	if len(errors) > 0 {
		return DeleteQualificationResultRequestMultiError(errors)
	}

	return nil
}

// DeleteQualificationResultRequestMultiError is an error wrapping multiple
// validation errors returned by
// DeleteQualificationResultRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteQualificationResultRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteQualificationResultRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteQualificationResultRequestMultiError) AllErrors() []error { return m }

// DeleteQualificationResultRequestValidationError is the validation error
// returned by DeleteQualificationResultRequest.Validate if the designated
// constraints aren't met.
type DeleteQualificationResultRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteQualificationResultRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteQualificationResultRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteQualificationResultRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteQualificationResultRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteQualificationResultRequestValidationError) ErrorName() string {
	return "DeleteQualificationResultRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteQualificationResultRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteQualificationResultRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteQualificationResultRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteQualificationResultRequestValidationError{}

// Validate checks the field values on DeleteQualificationResultResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *DeleteQualificationResultResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteQualificationResultResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// DeleteQualificationResultResponseMultiError, or nil if none found.
func (m *DeleteQualificationResultResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteQualificationResultResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteQualificationResultResponseMultiError(errors)
	}

	return nil
}

// DeleteQualificationResultResponseMultiError is an error wrapping multiple
// validation errors returned by
// DeleteQualificationResultResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteQualificationResultResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteQualificationResultResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteQualificationResultResponseMultiError) AllErrors() []error { return m }

// DeleteQualificationResultResponseValidationError is the validation error
// returned by DeleteQualificationResultResponse.Validate if the designated
// constraints aren't met.
type DeleteQualificationResultResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteQualificationResultResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteQualificationResultResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteQualificationResultResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteQualificationResultResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteQualificationResultResponseValidationError) ErrorName() string {
	return "DeleteQualificationResultResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteQualificationResultResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteQualificationResultResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteQualificationResultResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteQualificationResultResponseValidationError{}

// Validate checks the field values on GetExamInfoRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetExamInfoRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetExamInfoRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetExamInfoRequestMultiError, or nil if none found.
func (m *GetExamInfoRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetExamInfoRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for QualificationId

	if len(errors) > 0 {
		return GetExamInfoRequestMultiError(errors)
	}

	return nil
}

// GetExamInfoRequestMultiError is an error wrapping multiple validation errors
// returned by GetExamInfoRequest.ValidateAll() if the designated constraints
// aren't met.
type GetExamInfoRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetExamInfoRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetExamInfoRequestMultiError) AllErrors() []error { return m }

// GetExamInfoRequestValidationError is the validation error returned by
// GetExamInfoRequest.Validate if the designated constraints aren't met.
type GetExamInfoRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetExamInfoRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetExamInfoRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetExamInfoRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetExamInfoRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetExamInfoRequestValidationError) ErrorName() string {
	return "GetExamInfoRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetExamInfoRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetExamInfoRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetExamInfoRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetExamInfoRequestValidationError{}

// Validate checks the field values on GetExamInfoResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetExamInfoResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetExamInfoResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetExamInfoResponseMultiError, or nil if none found.
func (m *GetExamInfoResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetExamInfoResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetQualification()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetExamInfoResponseValidationError{
					field:  "Qualification",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetExamInfoResponseValidationError{
					field:  "Qualification",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQualification()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetExamInfoResponseValidationError{
				field:  "Qualification",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for QuestionCount

	if m.ExamUser != nil {

		if all {
			switch v := interface{}(m.GetExamUser()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetExamInfoResponseValidationError{
						field:  "ExamUser",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetExamInfoResponseValidationError{
						field:  "ExamUser",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetExamUser()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetExamInfoResponseValidationError{
					field:  "ExamUser",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetExamInfoResponseMultiError(errors)
	}

	return nil
}

// GetExamInfoResponseMultiError is an error wrapping multiple validation
// errors returned by GetExamInfoResponse.ValidateAll() if the designated
// constraints aren't met.
type GetExamInfoResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetExamInfoResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetExamInfoResponseMultiError) AllErrors() []error { return m }

// GetExamInfoResponseValidationError is the validation error returned by
// GetExamInfoResponse.Validate if the designated constraints aren't met.
type GetExamInfoResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetExamInfoResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetExamInfoResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetExamInfoResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetExamInfoResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetExamInfoResponseValidationError) ErrorName() string {
	return "GetExamInfoResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetExamInfoResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetExamInfoResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetExamInfoResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetExamInfoResponseValidationError{}

// Validate checks the field values on TakeExamRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TakeExamRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TakeExamRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TakeExamRequestMultiError, or nil if none found.
func (m *TakeExamRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *TakeExamRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for QualificationId

	if m.Cancel != nil {
		// no validation rules for Cancel
	}

	if len(errors) > 0 {
		return TakeExamRequestMultiError(errors)
	}

	return nil
}

// TakeExamRequestMultiError is an error wrapping multiple validation errors
// returned by TakeExamRequest.ValidateAll() if the designated constraints
// aren't met.
type TakeExamRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TakeExamRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TakeExamRequestMultiError) AllErrors() []error { return m }

// TakeExamRequestValidationError is the validation error returned by
// TakeExamRequest.Validate if the designated constraints aren't met.
type TakeExamRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TakeExamRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TakeExamRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TakeExamRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TakeExamRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TakeExamRequestValidationError) ErrorName() string { return "TakeExamRequestValidationError" }

// Error satisfies the builtin error interface
func (e TakeExamRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTakeExamRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TakeExamRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TakeExamRequestValidationError{}

// Validate checks the field values on TakeExamResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TakeExamResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TakeExamResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TakeExamResponseMultiError, or nil if none found.
func (m *TakeExamResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *TakeExamResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetExam()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TakeExamResponseValidationError{
					field:  "Exam",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TakeExamResponseValidationError{
					field:  "Exam",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExam()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TakeExamResponseValidationError{
				field:  "Exam",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetExamUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TakeExamResponseValidationError{
					field:  "ExamUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TakeExamResponseValidationError{
					field:  "ExamUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExamUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TakeExamResponseValidationError{
				field:  "ExamUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TakeExamResponseMultiError(errors)
	}

	return nil
}

// TakeExamResponseMultiError is an error wrapping multiple validation errors
// returned by TakeExamResponse.ValidateAll() if the designated constraints
// aren't met.
type TakeExamResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TakeExamResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TakeExamResponseMultiError) AllErrors() []error { return m }

// TakeExamResponseValidationError is the validation error returned by
// TakeExamResponse.Validate if the designated constraints aren't met.
type TakeExamResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TakeExamResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TakeExamResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TakeExamResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TakeExamResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TakeExamResponseValidationError) ErrorName() string { return "TakeExamResponseValidationError" }

// Error satisfies the builtin error interface
func (e TakeExamResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTakeExamResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TakeExamResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TakeExamResponseValidationError{}

// Validate checks the field values on SubmitExamRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SubmitExamRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubmitExamRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SubmitExamRequestMultiError, or nil if none found.
func (m *SubmitExamRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SubmitExamRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for QualificationId

	if all {
		switch v := interface{}(m.GetResponses()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SubmitExamRequestValidationError{
					field:  "Responses",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SubmitExamRequestValidationError{
					field:  "Responses",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResponses()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SubmitExamRequestValidationError{
				field:  "Responses",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SubmitExamRequestMultiError(errors)
	}

	return nil
}

// SubmitExamRequestMultiError is an error wrapping multiple validation errors
// returned by SubmitExamRequest.ValidateAll() if the designated constraints
// aren't met.
type SubmitExamRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubmitExamRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubmitExamRequestMultiError) AllErrors() []error { return m }

// SubmitExamRequestValidationError is the validation error returned by
// SubmitExamRequest.Validate if the designated constraints aren't met.
type SubmitExamRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubmitExamRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubmitExamRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubmitExamRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubmitExamRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubmitExamRequestValidationError) ErrorName() string {
	return "SubmitExamRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SubmitExamRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubmitExamRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubmitExamRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubmitExamRequestValidationError{}

// Validate checks the field values on SubmitExamResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SubmitExamResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubmitExamResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SubmitExamResponseMultiError, or nil if none found.
func (m *SubmitExamResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SubmitExamResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDuration()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SubmitExamResponseValidationError{
					field:  "Duration",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SubmitExamResponseValidationError{
					field:  "Duration",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDuration()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SubmitExamResponseValidationError{
				field:  "Duration",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SubmitExamResponseMultiError(errors)
	}

	return nil
}

// SubmitExamResponseMultiError is an error wrapping multiple validation errors
// returned by SubmitExamResponse.ValidateAll() if the designated constraints
// aren't met.
type SubmitExamResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubmitExamResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubmitExamResponseMultiError) AllErrors() []error { return m }

// SubmitExamResponseValidationError is the validation error returned by
// SubmitExamResponse.Validate if the designated constraints aren't met.
type SubmitExamResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubmitExamResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubmitExamResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubmitExamResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubmitExamResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubmitExamResponseValidationError) ErrorName() string {
	return "SubmitExamResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SubmitExamResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubmitExamResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubmitExamResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubmitExamResponseValidationError{}

// Validate checks the field values on GetUserExamRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetUserExamRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUserExamRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetUserExamRequestMultiError, or nil if none found.
func (m *GetUserExamRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUserExamRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for QualificationId

	if m.GetUserId() < 0 {
		err := GetUserExamRequestValidationError{
			field:  "UserId",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetUserExamRequestMultiError(errors)
	}

	return nil
}

// GetUserExamRequestMultiError is an error wrapping multiple validation errors
// returned by GetUserExamRequest.ValidateAll() if the designated constraints
// aren't met.
type GetUserExamRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUserExamRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUserExamRequestMultiError) AllErrors() []error { return m }

// GetUserExamRequestValidationError is the validation error returned by
// GetUserExamRequest.Validate if the designated constraints aren't met.
type GetUserExamRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserExamRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserExamRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserExamRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserExamRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserExamRequestValidationError) ErrorName() string {
	return "GetUserExamRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetUserExamRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserExamRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserExamRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserExamRequestValidationError{}

// Validate checks the field values on GetUserExamResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetUserExamResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUserExamResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetUserExamResponseMultiError, or nil if none found.
func (m *GetUserExamResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUserExamResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetExam()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetUserExamResponseValidationError{
					field:  "Exam",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetUserExamResponseValidationError{
					field:  "Exam",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExam()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetUserExamResponseValidationError{
				field:  "Exam",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetExamUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetUserExamResponseValidationError{
					field:  "ExamUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetUserExamResponseValidationError{
					field:  "ExamUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExamUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetUserExamResponseValidationError{
				field:  "ExamUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetResponses()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetUserExamResponseValidationError{
					field:  "Responses",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetUserExamResponseValidationError{
					field:  "Responses",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResponses()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetUserExamResponseValidationError{
				field:  "Responses",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetUserExamResponseMultiError(errors)
	}

	return nil
}

// GetUserExamResponseMultiError is an error wrapping multiple validation
// errors returned by GetUserExamResponse.ValidateAll() if the designated
// constraints aren't met.
type GetUserExamResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUserExamResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUserExamResponseMultiError) AllErrors() []error { return m }

// GetUserExamResponseValidationError is the validation error returned by
// GetUserExamResponse.Validate if the designated constraints aren't met.
type GetUserExamResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserExamResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserExamResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserExamResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserExamResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserExamResponseValidationError) ErrorName() string {
	return "GetUserExamResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetUserExamResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserExamResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserExamResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserExamResponseValidationError{}
