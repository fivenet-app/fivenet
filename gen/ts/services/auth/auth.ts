// @generated by protobuf-ts 2.10.0 with parameter optimize_speed,long_type_number,force_server_none
// @generated from protobuf file "services/auth/auth.proto" (package "services.auth", syntax proto3)
// @ts-nocheck
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { User } from "../../resources/users/users";
import { JobProps } from "../../resources/jobs/job_props";
import { Character } from "../../resources/accounts/accounts";
import { OAuth2Account } from "../../resources/accounts/oauth2";
import { OAuth2Provider } from "../../resources/accounts/oauth2";
import { Account } from "../../resources/accounts/accounts";
import { Timestamp } from "../../resources/timestamp/timestamp";
/**
 * @generated from protobuf message services.auth.CreateAccountRequest
 */
export interface CreateAccountRequest {
    /**
     * @generated from protobuf field: string reg_token = 1;
     */
    regToken: string;
    /**
     * @generated from protobuf field: string username = 2;
     */
    username: string;
    /**
     * @generated from protobuf field: string password = 3;
     */
    password: string;
}
/**
 * @generated from protobuf message services.auth.CreateAccountResponse
 */
export interface CreateAccountResponse {
    /**
     * @generated from protobuf field: uint64 account_id = 1;
     */
    accountId: number;
}
/**
 * @generated from protobuf message services.auth.LoginRequest
 */
export interface LoginRequest {
    /**
     * @generated from protobuf field: string username = 1;
     */
    username: string;
    /**
     * @generated from protobuf field: string password = 2;
     */
    password: string;
}
/**
 * @generated from protobuf message services.auth.LoginResponse
 */
export interface LoginResponse {
    /**
     * @generated from protobuf field: resources.timestamp.Timestamp expires = 1;
     */
    expires?: Timestamp;
    /**
     * @generated from protobuf field: uint64 account_id = 2;
     */
    accountId: number;
    /**
     * @generated from protobuf field: optional services.auth.ChooseCharacterResponse char = 3;
     */
    char?: ChooseCharacterResponse;
}
/**
 * @generated from protobuf message services.auth.ChangePasswordRequest
 */
export interface ChangePasswordRequest {
    /**
     * @generated from protobuf field: string current = 1;
     */
    current: string;
    /**
     * @generated from protobuf field: string new = 2;
     */
    new: string;
}
/**
 * @generated from protobuf message services.auth.ChangePasswordResponse
 */
export interface ChangePasswordResponse {
    /**
     * @generated from protobuf field: resources.timestamp.Timestamp expires = 1;
     */
    expires?: Timestamp;
}
/**
 * @generated from protobuf message services.auth.ChangeUsernameRequest
 */
export interface ChangeUsernameRequest {
    /**
     * @generated from protobuf field: string current = 1;
     */
    current: string;
    /**
     * @generated from protobuf field: string new = 2;
     */
    new: string;
}
/**
 * @generated from protobuf message services.auth.ChangeUsernameResponse
 */
export interface ChangeUsernameResponse {
}
/**
 * @generated from protobuf message services.auth.ForgotPasswordRequest
 */
export interface ForgotPasswordRequest {
    /**
     * @generated from protobuf field: string reg_token = 1;
     */
    regToken: string;
    /**
     * @generated from protobuf field: string new = 2;
     */
    new: string;
}
/**
 * @generated from protobuf message services.auth.ForgotPasswordResponse
 */
export interface ForgotPasswordResponse {
}
/**
 * @generated from protobuf message services.auth.GetAccountInfoRequest
 */
export interface GetAccountInfoRequest {
}
/**
 * @generated from protobuf message services.auth.GetAccountInfoResponse
 */
export interface GetAccountInfoResponse {
    /**
     * @generated from protobuf field: resources.accounts.Account account = 1;
     */
    account?: Account;
    /**
     * @generated from protobuf field: repeated resources.accounts.OAuth2Provider oauth2_providers = 2;
     */
    oauth2Providers: OAuth2Provider[];
    /**
     * @generated from protobuf field: repeated resources.accounts.OAuth2Account oauth2_connections = 3;
     */
    oauth2Connections: OAuth2Account[];
}
/**
 * @generated from protobuf message services.auth.GetCharactersRequest
 */
export interface GetCharactersRequest {
}
/**
 * @generated from protobuf message services.auth.GetCharactersResponse
 */
export interface GetCharactersResponse {
    /**
     * @generated from protobuf field: repeated resources.accounts.Character chars = 1;
     */
    chars: Character[];
}
/**
 * @generated from protobuf message services.auth.ChooseCharacterRequest
 */
export interface ChooseCharacterRequest {
    /**
     * @generated from protobuf field: int32 char_id = 1;
     */
    charId: number;
}
/**
 * @generated from protobuf message services.auth.ChooseCharacterResponse
 */
export interface ChooseCharacterResponse {
    /**
     * @generated from protobuf field: resources.timestamp.Timestamp expires = 1;
     */
    expires?: Timestamp;
    /**
     * @generated from protobuf field: repeated string permissions = 2;
     */
    permissions: string[];
    /**
     * @generated from protobuf field: resources.jobs.JobProps job_props = 3;
     */
    jobProps?: JobProps;
    /**
     * @generated from protobuf field: resources.users.User char = 4;
     */
    char?: User; // @gotags: alias:"user"
    /**
     * @generated from protobuf field: string username = 5;
     */
    username: string;
}
/**
 * @generated from protobuf message services.auth.LogoutRequest
 */
export interface LogoutRequest {
}
/**
 * @generated from protobuf message services.auth.LogoutResponse
 */
export interface LogoutResponse {
    /**
     * @generated from protobuf field: bool success = 1;
     */
    success: boolean;
}
/**
 * @generated from protobuf message services.auth.DeleteOAuth2ConnectionRequest
 */
export interface DeleteOAuth2ConnectionRequest {
    /**
     * @generated from protobuf field: string provider = 1;
     */
    provider: string;
}
/**
 * @generated from protobuf message services.auth.DeleteOAuth2ConnectionResponse
 */
export interface DeleteOAuth2ConnectionResponse {
    /**
     * @generated from protobuf field: bool success = 1;
     */
    success: boolean;
}
/**
 * @generated from protobuf message services.auth.SetSuperuserModeRequest
 */
export interface SetSuperuserModeRequest {
    /**
     * @generated from protobuf field: bool superuser = 1;
     */
    superuser: boolean;
    /**
     * @generated from protobuf field: optional string job = 2;
     */
    job?: string;
}
/**
 * @generated from protobuf message services.auth.SetSuperuserModeResponse
 */
export interface SetSuperuserModeResponse {
    /**
     * @generated from protobuf field: resources.timestamp.Timestamp expires = 1;
     */
    expires?: Timestamp;
    /**
     * @generated from protobuf field: repeated string permissions = 2;
     */
    permissions: string[];
    /**
     * @generated from protobuf field: optional resources.jobs.JobProps job_props = 3;
     */
    jobProps?: JobProps;
    /**
     * @generated from protobuf field: resources.users.User char = 4;
     */
    char?: User; // @gotags: alias:"user"
}
// @generated message type with reflection information, may provide speed optimized methods
class CreateAccountRequest$Type extends MessageType<CreateAccountRequest> {
    constructor() {
        super("services.auth.CreateAccountRequest", [
            { no: 1, name: "reg_token", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { len: "6", pattern: "^[0-9]{6}$" } } } },
            { no: 2, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "3", maxLen: "24", pattern: "(?i)^[0-9A-Z\u00C4\u00D6\u00DC\u00DF_-]{3,24}$" } } } },
            { no: 3, name: "password", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "6", maxBytes: "70" } } } }
        ]);
    }
    create(value?: PartialMessage<CreateAccountRequest>): CreateAccountRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.regToken = "";
        message.username = "";
        message.password = "";
        if (value !== undefined)
            reflectionMergePartial<CreateAccountRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateAccountRequest): CreateAccountRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string reg_token */ 1:
                    message.regToken = reader.string();
                    break;
                case /* string username */ 2:
                    message.username = reader.string();
                    break;
                case /* string password */ 3:
                    message.password = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateAccountRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string reg_token = 1; */
        if (message.regToken !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.regToken);
        /* string username = 2; */
        if (message.username !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.username);
        /* string password = 3; */
        if (message.password !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.password);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.auth.CreateAccountRequest
 */
export const CreateAccountRequest = new CreateAccountRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateAccountResponse$Type extends MessageType<CreateAccountResponse> {
    constructor() {
        super("services.auth.CreateAccountResponse", [
            { no: 1, name: "account_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<CreateAccountResponse>): CreateAccountResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accountId = 0;
        if (value !== undefined)
            reflectionMergePartial<CreateAccountResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateAccountResponse): CreateAccountResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 account_id */ 1:
                    message.accountId = reader.uint64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateAccountResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 account_id = 1; */
        if (message.accountId !== 0)
            writer.tag(1, WireType.Varint).uint64(message.accountId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.auth.CreateAccountResponse
 */
export const CreateAccountResponse = new CreateAccountResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoginRequest$Type extends MessageType<LoginRequest> {
    constructor() {
        super("services.auth.LoginRequest", [
            { no: 1, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "3", maxLen: "24", pattern: "(?i)^[0-9A-Z\u00C4\u00D6\u00DC\u00DF_-]{3,24}$" } } } },
            { no: 2, name: "password", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "6", maxBytes: "70" } } } }
        ]);
    }
    create(value?: PartialMessage<LoginRequest>): LoginRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.username = "";
        message.password = "";
        if (value !== undefined)
            reflectionMergePartial<LoginRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoginRequest): LoginRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string username */ 1:
                    message.username = reader.string();
                    break;
                case /* string password */ 2:
                    message.password = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoginRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string username = 1; */
        if (message.username !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.username);
        /* string password = 2; */
        if (message.password !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.password);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.auth.LoginRequest
 */
export const LoginRequest = new LoginRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoginResponse$Type extends MessageType<LoginResponse> {
    constructor() {
        super("services.auth.LoginResponse", [
            { no: 1, name: "expires", kind: "message", T: () => Timestamp },
            { no: 2, name: "account_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 3, name: "char", kind: "message", T: () => ChooseCharacterResponse }
        ]);
    }
    create(value?: PartialMessage<LoginResponse>): LoginResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accountId = 0;
        if (value !== undefined)
            reflectionMergePartial<LoginResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoginResponse): LoginResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.timestamp.Timestamp expires */ 1:
                    message.expires = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.expires);
                    break;
                case /* uint64 account_id */ 2:
                    message.accountId = reader.uint64().toNumber();
                    break;
                case /* optional services.auth.ChooseCharacterResponse char */ 3:
                    message.char = ChooseCharacterResponse.internalBinaryRead(reader, reader.uint32(), options, message.char);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoginResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.timestamp.Timestamp expires = 1; */
        if (message.expires)
            Timestamp.internalBinaryWrite(message.expires, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint64 account_id = 2; */
        if (message.accountId !== 0)
            writer.tag(2, WireType.Varint).uint64(message.accountId);
        /* optional services.auth.ChooseCharacterResponse char = 3; */
        if (message.char)
            ChooseCharacterResponse.internalBinaryWrite(message.char, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.auth.LoginResponse
 */
export const LoginResponse = new LoginResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChangePasswordRequest$Type extends MessageType<ChangePasswordRequest> {
    constructor() {
        super("services.auth.ChangePasswordRequest", [
            { no: 1, name: "current", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "6", maxBytes: "70" } } } },
            { no: 2, name: "new", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "6", maxBytes: "70" } } } }
        ]);
    }
    create(value?: PartialMessage<ChangePasswordRequest>): ChangePasswordRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.current = "";
        message.new = "";
        if (value !== undefined)
            reflectionMergePartial<ChangePasswordRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChangePasswordRequest): ChangePasswordRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string current */ 1:
                    message.current = reader.string();
                    break;
                case /* string new */ 2:
                    message.new = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChangePasswordRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string current = 1; */
        if (message.current !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.current);
        /* string new = 2; */
        if (message.new !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.new);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.auth.ChangePasswordRequest
 */
export const ChangePasswordRequest = new ChangePasswordRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChangePasswordResponse$Type extends MessageType<ChangePasswordResponse> {
    constructor() {
        super("services.auth.ChangePasswordResponse", [
            { no: 1, name: "expires", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<ChangePasswordResponse>): ChangePasswordResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ChangePasswordResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChangePasswordResponse): ChangePasswordResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.timestamp.Timestamp expires */ 1:
                    message.expires = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.expires);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChangePasswordResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.timestamp.Timestamp expires = 1; */
        if (message.expires)
            Timestamp.internalBinaryWrite(message.expires, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.auth.ChangePasswordResponse
 */
export const ChangePasswordResponse = new ChangePasswordResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChangeUsernameRequest$Type extends MessageType<ChangeUsernameRequest> {
    constructor() {
        super("services.auth.ChangeUsernameRequest", [
            { no: 1, name: "current", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "3", maxLen: "24", pattern: "(?i)^[0-9A-Z\u00C4\u00D6\u00DC\u00DF_-]{3,24}$" } } } },
            { no: 2, name: "new", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "3", maxLen: "24", pattern: "(?i)^[0-9A-Z\u00C4\u00D6\u00DC\u00DF_-]{3,24}$" } } } }
        ]);
    }
    create(value?: PartialMessage<ChangeUsernameRequest>): ChangeUsernameRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.current = "";
        message.new = "";
        if (value !== undefined)
            reflectionMergePartial<ChangeUsernameRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChangeUsernameRequest): ChangeUsernameRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string current */ 1:
                    message.current = reader.string();
                    break;
                case /* string new */ 2:
                    message.new = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChangeUsernameRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string current = 1; */
        if (message.current !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.current);
        /* string new = 2; */
        if (message.new !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.new);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.auth.ChangeUsernameRequest
 */
export const ChangeUsernameRequest = new ChangeUsernameRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChangeUsernameResponse$Type extends MessageType<ChangeUsernameResponse> {
    constructor() {
        super("services.auth.ChangeUsernameResponse", []);
    }
    create(value?: PartialMessage<ChangeUsernameResponse>): ChangeUsernameResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ChangeUsernameResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChangeUsernameResponse): ChangeUsernameResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChangeUsernameResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.auth.ChangeUsernameResponse
 */
export const ChangeUsernameResponse = new ChangeUsernameResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ForgotPasswordRequest$Type extends MessageType<ForgotPasswordRequest> {
    constructor() {
        super("services.auth.ForgotPasswordRequest", [
            { no: 1, name: "reg_token", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { len: "6", pattern: "^[0-9]{6}$" } } } },
            { no: 2, name: "new", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "6", maxBytes: "70" } } } }
        ]);
    }
    create(value?: PartialMessage<ForgotPasswordRequest>): ForgotPasswordRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.regToken = "";
        message.new = "";
        if (value !== undefined)
            reflectionMergePartial<ForgotPasswordRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ForgotPasswordRequest): ForgotPasswordRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string reg_token */ 1:
                    message.regToken = reader.string();
                    break;
                case /* string new */ 2:
                    message.new = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ForgotPasswordRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string reg_token = 1; */
        if (message.regToken !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.regToken);
        /* string new = 2; */
        if (message.new !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.new);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.auth.ForgotPasswordRequest
 */
export const ForgotPasswordRequest = new ForgotPasswordRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ForgotPasswordResponse$Type extends MessageType<ForgotPasswordResponse> {
    constructor() {
        super("services.auth.ForgotPasswordResponse", []);
    }
    create(value?: PartialMessage<ForgotPasswordResponse>): ForgotPasswordResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ForgotPasswordResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ForgotPasswordResponse): ForgotPasswordResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ForgotPasswordResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.auth.ForgotPasswordResponse
 */
export const ForgotPasswordResponse = new ForgotPasswordResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAccountInfoRequest$Type extends MessageType<GetAccountInfoRequest> {
    constructor() {
        super("services.auth.GetAccountInfoRequest", []);
    }
    create(value?: PartialMessage<GetAccountInfoRequest>): GetAccountInfoRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetAccountInfoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAccountInfoRequest): GetAccountInfoRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAccountInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.auth.GetAccountInfoRequest
 */
export const GetAccountInfoRequest = new GetAccountInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAccountInfoResponse$Type extends MessageType<GetAccountInfoResponse> {
    constructor() {
        super("services.auth.GetAccountInfoResponse", [
            { no: 1, name: "account", kind: "message", T: () => Account },
            { no: 2, name: "oauth2_providers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => OAuth2Provider },
            { no: 3, name: "oauth2_connections", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => OAuth2Account }
        ]);
    }
    create(value?: PartialMessage<GetAccountInfoResponse>): GetAccountInfoResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.oauth2Providers = [];
        message.oauth2Connections = [];
        if (value !== undefined)
            reflectionMergePartial<GetAccountInfoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAccountInfoResponse): GetAccountInfoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.accounts.Account account */ 1:
                    message.account = Account.internalBinaryRead(reader, reader.uint32(), options, message.account);
                    break;
                case /* repeated resources.accounts.OAuth2Provider oauth2_providers */ 2:
                    message.oauth2Providers.push(OAuth2Provider.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated resources.accounts.OAuth2Account oauth2_connections */ 3:
                    message.oauth2Connections.push(OAuth2Account.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAccountInfoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.accounts.Account account = 1; */
        if (message.account)
            Account.internalBinaryWrite(message.account, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated resources.accounts.OAuth2Provider oauth2_providers = 2; */
        for (let i = 0; i < message.oauth2Providers.length; i++)
            OAuth2Provider.internalBinaryWrite(message.oauth2Providers[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated resources.accounts.OAuth2Account oauth2_connections = 3; */
        for (let i = 0; i < message.oauth2Connections.length; i++)
            OAuth2Account.internalBinaryWrite(message.oauth2Connections[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.auth.GetAccountInfoResponse
 */
export const GetAccountInfoResponse = new GetAccountInfoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetCharactersRequest$Type extends MessageType<GetCharactersRequest> {
    constructor() {
        super("services.auth.GetCharactersRequest", []);
    }
    create(value?: PartialMessage<GetCharactersRequest>): GetCharactersRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetCharactersRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetCharactersRequest): GetCharactersRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetCharactersRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.auth.GetCharactersRequest
 */
export const GetCharactersRequest = new GetCharactersRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetCharactersResponse$Type extends MessageType<GetCharactersResponse> {
    constructor() {
        super("services.auth.GetCharactersResponse", [
            { no: 1, name: "chars", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Character }
        ]);
    }
    create(value?: PartialMessage<GetCharactersResponse>): GetCharactersResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.chars = [];
        if (value !== undefined)
            reflectionMergePartial<GetCharactersResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetCharactersResponse): GetCharactersResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated resources.accounts.Character chars */ 1:
                    message.chars.push(Character.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetCharactersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated resources.accounts.Character chars = 1; */
        for (let i = 0; i < message.chars.length; i++)
            Character.internalBinaryWrite(message.chars[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.auth.GetCharactersResponse
 */
export const GetCharactersResponse = new GetCharactersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChooseCharacterRequest$Type extends MessageType<ChooseCharacterRequest> {
    constructor() {
        super("services.auth.ChooseCharacterRequest", [
            { no: 1, name: "char_id", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "validate.rules": { int32: { gt: 0 } } } }
        ]);
    }
    create(value?: PartialMessage<ChooseCharacterRequest>): ChooseCharacterRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.charId = 0;
        if (value !== undefined)
            reflectionMergePartial<ChooseCharacterRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChooseCharacterRequest): ChooseCharacterRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 char_id */ 1:
                    message.charId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChooseCharacterRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 char_id = 1; */
        if (message.charId !== 0)
            writer.tag(1, WireType.Varint).int32(message.charId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.auth.ChooseCharacterRequest
 */
export const ChooseCharacterRequest = new ChooseCharacterRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChooseCharacterResponse$Type extends MessageType<ChooseCharacterResponse> {
    constructor() {
        super("services.auth.ChooseCharacterResponse", [
            { no: 1, name: "expires", kind: "message", T: () => Timestamp },
            { no: 2, name: "permissions", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "job_props", kind: "message", T: () => JobProps },
            { no: 4, name: "char", kind: "message", T: () => User },
            { no: 5, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ChooseCharacterResponse>): ChooseCharacterResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.permissions = [];
        message.username = "";
        if (value !== undefined)
            reflectionMergePartial<ChooseCharacterResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChooseCharacterResponse): ChooseCharacterResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.timestamp.Timestamp expires */ 1:
                    message.expires = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.expires);
                    break;
                case /* repeated string permissions */ 2:
                    message.permissions.push(reader.string());
                    break;
                case /* resources.jobs.JobProps job_props */ 3:
                    message.jobProps = JobProps.internalBinaryRead(reader, reader.uint32(), options, message.jobProps);
                    break;
                case /* resources.users.User char */ 4:
                    message.char = User.internalBinaryRead(reader, reader.uint32(), options, message.char);
                    break;
                case /* string username */ 5:
                    message.username = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChooseCharacterResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.timestamp.Timestamp expires = 1; */
        if (message.expires)
            Timestamp.internalBinaryWrite(message.expires, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated string permissions = 2; */
        for (let i = 0; i < message.permissions.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.permissions[i]);
        /* resources.jobs.JobProps job_props = 3; */
        if (message.jobProps)
            JobProps.internalBinaryWrite(message.jobProps, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* resources.users.User char = 4; */
        if (message.char)
            User.internalBinaryWrite(message.char, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string username = 5; */
        if (message.username !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.username);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.auth.ChooseCharacterResponse
 */
export const ChooseCharacterResponse = new ChooseCharacterResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LogoutRequest$Type extends MessageType<LogoutRequest> {
    constructor() {
        super("services.auth.LogoutRequest", []);
    }
    create(value?: PartialMessage<LogoutRequest>): LogoutRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<LogoutRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LogoutRequest): LogoutRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LogoutRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.auth.LogoutRequest
 */
export const LogoutRequest = new LogoutRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LogoutResponse$Type extends MessageType<LogoutResponse> {
    constructor() {
        super("services.auth.LogoutResponse", [
            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<LogoutResponse>): LogoutResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.success = false;
        if (value !== undefined)
            reflectionMergePartial<LogoutResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LogoutResponse): LogoutResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.success = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LogoutResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.auth.LogoutResponse
 */
export const LogoutResponse = new LogoutResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteOAuth2ConnectionRequest$Type extends MessageType<DeleteOAuth2ConnectionRequest> {
    constructor() {
        super("services.auth.DeleteOAuth2ConnectionRequest", [
            { no: 1, name: "provider", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxLen: "50" } } } }
        ]);
    }
    create(value?: PartialMessage<DeleteOAuth2ConnectionRequest>): DeleteOAuth2ConnectionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.provider = "";
        if (value !== undefined)
            reflectionMergePartial<DeleteOAuth2ConnectionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteOAuth2ConnectionRequest): DeleteOAuth2ConnectionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string provider */ 1:
                    message.provider = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteOAuth2ConnectionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string provider = 1; */
        if (message.provider !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.provider);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.auth.DeleteOAuth2ConnectionRequest
 */
export const DeleteOAuth2ConnectionRequest = new DeleteOAuth2ConnectionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteOAuth2ConnectionResponse$Type extends MessageType<DeleteOAuth2ConnectionResponse> {
    constructor() {
        super("services.auth.DeleteOAuth2ConnectionResponse", [
            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteOAuth2ConnectionResponse>): DeleteOAuth2ConnectionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.success = false;
        if (value !== undefined)
            reflectionMergePartial<DeleteOAuth2ConnectionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteOAuth2ConnectionResponse): DeleteOAuth2ConnectionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.success = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteOAuth2ConnectionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.auth.DeleteOAuth2ConnectionResponse
 */
export const DeleteOAuth2ConnectionResponse = new DeleteOAuth2ConnectionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetSuperuserModeRequest$Type extends MessageType<SetSuperuserModeRequest> {
    constructor() {
        super("services.auth.SetSuperuserModeRequest", [
            { no: 1, name: "superuser", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "job", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxLen: "20" } } } }
        ]);
    }
    create(value?: PartialMessage<SetSuperuserModeRequest>): SetSuperuserModeRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.superuser = false;
        if (value !== undefined)
            reflectionMergePartial<SetSuperuserModeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetSuperuserModeRequest): SetSuperuserModeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool superuser */ 1:
                    message.superuser = reader.bool();
                    break;
                case /* optional string job */ 2:
                    message.job = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetSuperuserModeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool superuser = 1; */
        if (message.superuser !== false)
            writer.tag(1, WireType.Varint).bool(message.superuser);
        /* optional string job = 2; */
        if (message.job !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.job);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.auth.SetSuperuserModeRequest
 */
export const SetSuperuserModeRequest = new SetSuperuserModeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetSuperuserModeResponse$Type extends MessageType<SetSuperuserModeResponse> {
    constructor() {
        super("services.auth.SetSuperuserModeResponse", [
            { no: 1, name: "expires", kind: "message", T: () => Timestamp },
            { no: 2, name: "permissions", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "job_props", kind: "message", T: () => JobProps },
            { no: 4, name: "char", kind: "message", T: () => User }
        ]);
    }
    create(value?: PartialMessage<SetSuperuserModeResponse>): SetSuperuserModeResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.permissions = [];
        if (value !== undefined)
            reflectionMergePartial<SetSuperuserModeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetSuperuserModeResponse): SetSuperuserModeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.timestamp.Timestamp expires */ 1:
                    message.expires = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.expires);
                    break;
                case /* repeated string permissions */ 2:
                    message.permissions.push(reader.string());
                    break;
                case /* optional resources.jobs.JobProps job_props */ 3:
                    message.jobProps = JobProps.internalBinaryRead(reader, reader.uint32(), options, message.jobProps);
                    break;
                case /* resources.users.User char */ 4:
                    message.char = User.internalBinaryRead(reader, reader.uint32(), options, message.char);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetSuperuserModeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.timestamp.Timestamp expires = 1; */
        if (message.expires)
            Timestamp.internalBinaryWrite(message.expires, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated string permissions = 2; */
        for (let i = 0; i < message.permissions.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.permissions[i]);
        /* optional resources.jobs.JobProps job_props = 3; */
        if (message.jobProps)
            JobProps.internalBinaryWrite(message.jobProps, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* resources.users.User char = 4; */
        if (message.char)
            User.internalBinaryWrite(message.char, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.auth.SetSuperuserModeResponse
 */
export const SetSuperuserModeResponse = new SetSuperuserModeResponse$Type();
/**
 * @generated ServiceType for protobuf service services.auth.AuthService
 */
export const AuthService = new ServiceType("services.auth.AuthService", [
    { name: "Login", options: {}, I: LoginRequest, O: LoginResponse },
    { name: "Logout", options: {}, I: LogoutRequest, O: LogoutResponse },
    { name: "CreateAccount", options: {}, I: CreateAccountRequest, O: CreateAccountResponse },
    { name: "ChangeUsername", options: {}, I: ChangeUsernameRequest, O: ChangeUsernameResponse },
    { name: "ChangePassword", options: {}, I: ChangePasswordRequest, O: ChangePasswordResponse },
    { name: "ForgotPassword", options: {}, I: ForgotPasswordRequest, O: ForgotPasswordResponse },
    { name: "GetCharacters", options: {}, I: GetCharactersRequest, O: GetCharactersResponse },
    { name: "ChooseCharacter", options: {}, I: ChooseCharacterRequest, O: ChooseCharacterResponse },
    { name: "GetAccountInfo", options: {}, I: GetAccountInfoRequest, O: GetAccountInfoResponse },
    { name: "DeleteOAuth2Connection", options: {}, I: DeleteOAuth2ConnectionRequest, O: DeleteOAuth2ConnectionResponse },
    { name: "SetSuperuserMode", options: {}, I: SetSuperuserModeRequest, O: SetSuperuserModeResponse }
]);
