// @generated by protobuf-ts 2.11.0 with parameter optimize_speed,long_type_number,force_server_none
// @generated from protobuf file "services/livemap/livemap.proto" (package "services.livemap", syntax proto3)
// @ts-nocheck
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { MarkerMarker } from "../../resources/livemap/marker_marker";
import { Job } from "../../resources/jobs/jobs";
import { UserMarker } from "../../resources/livemap/user_marker";
/**
 * @generated from protobuf message services.livemap.StreamRequest
 */
export interface StreamRequest {
}
/**
 * @generated from protobuf message services.livemap.StreamResponse
 */
export interface StreamResponse {
    /**
     * @generated from protobuf field: optional bool user_on_duty = 1
     */
    userOnDuty?: boolean;
    /**
     * @generated from protobuf oneof: data
     */
    data: {
        oneofKind: "jobs";
        /**
         * @generated from protobuf field: services.livemap.JobsList jobs = 2
         */
        jobs: JobsList;
    } | {
        oneofKind: "markers";
        /**
         * @generated from protobuf field: services.livemap.MarkerMarkersUpdates markers = 3
         */
        markers: MarkerMarkersUpdates;
    } | {
        oneofKind: "snapshot";
        /**
         * @generated from protobuf field: services.livemap.Snapshot snapshot = 4
         */
        snapshot: Snapshot;
    } | {
        oneofKind: "userUpdate";
        /**
         * @generated from protobuf field: resources.livemap.UserMarker user_update = 5
         */
        userUpdate: UserMarker;
    } | {
        oneofKind: "userDelete";
        /**
         * @generated from protobuf field: int32 user_delete = 6
         */
        userDelete: number;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message services.livemap.JobsList
 */
export interface JobsList {
    /**
     * @generated from protobuf field: repeated resources.jobs.Job users = 1
     */
    users: Job[];
    /**
     * @generated from protobuf field: repeated resources.jobs.Job markers = 2
     */
    markers: Job[];
}
/**
 * @generated from protobuf message services.livemap.MarkerMarkersUpdates
 */
export interface MarkerMarkersUpdates {
    /**
     * @generated from protobuf field: repeated resources.livemap.MarkerMarker updated = 1
     */
    updated: MarkerMarker[];
    /**
     * @generated from protobuf field: repeated uint64 deleted = 2
     */
    deleted: number[];
    /**
     * @generated from protobuf field: int32 part = 3
     */
    part: number;
    /**
     * @generated from protobuf field: bool partial = 4
     */
    partial: boolean;
}
/**
 * A roll-up of the entire USERLOC bucket.
 * Published every N seconds on `$KV.user_locations._snapshot`
 * with the headers:
 *   Nats-Rollup: all
 *   KV-Operation: ROLLUP
 *
 * @generated from protobuf message services.livemap.Snapshot
 */
export interface Snapshot {
    /**
     * All currently-known user markers, already filtered for
     * obsolete PURGE/DELETE events.
     *
     * @generated from protobuf field: repeated resources.livemap.UserMarker markers = 1
     */
    markers: UserMarker[];
    /**
     * When the snapshot was generated (Unix epoch millis).
     *
     * @generated from protobuf field: int64 generated_at = 2
     */
    generatedAt: number;
    /**
     * Optional monotonic counter so a client can ignore older roll-ups
     * that arrive out-of-order.
     *
     * @generated from protobuf field: uint64 snapshot_seq = 3
     */
    snapshotSeq: number;
    /**
     * Version in case we extend the definition later (e.g. add units).
     *
     * @generated from protobuf field: uint32 schema_version = 4
     */
    schemaVersion: number;
}
/**
 * @generated from protobuf message services.livemap.CreateOrUpdateMarkerRequest
 */
export interface CreateOrUpdateMarkerRequest {
    /**
     * @generated from protobuf field: resources.livemap.MarkerMarker marker = 1
     */
    marker?: MarkerMarker;
}
/**
 * @generated from protobuf message services.livemap.CreateOrUpdateMarkerResponse
 */
export interface CreateOrUpdateMarkerResponse {
    /**
     * @generated from protobuf field: resources.livemap.MarkerMarker marker = 1
     */
    marker?: MarkerMarker;
}
/**
 * @generated from protobuf message services.livemap.DeleteMarkerRequest
 */
export interface DeleteMarkerRequest {
    /**
     * @generated from protobuf field: uint64 id = 1
     */
    id: number;
}
/**
 * @generated from protobuf message services.livemap.DeleteMarkerResponse
 */
export interface DeleteMarkerResponse {
}
// @generated message type with reflection information, may provide speed optimized methods
class StreamRequest$Type extends MessageType<StreamRequest> {
    constructor() {
        super("services.livemap.StreamRequest", []);
    }
    create(value?: PartialMessage<StreamRequest>): StreamRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StreamRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamRequest): StreamRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.livemap.StreamRequest
 */
export const StreamRequest = new StreamRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamResponse$Type extends MessageType<StreamResponse> {
    constructor() {
        super("services.livemap.StreamResponse", [
            { no: 1, name: "user_on_duty", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "jobs", kind: "message", oneof: "data", T: () => JobsList },
            { no: 3, name: "markers", kind: "message", oneof: "data", T: () => MarkerMarkersUpdates },
            { no: 4, name: "snapshot", kind: "message", oneof: "data", T: () => Snapshot },
            { no: 5, name: "user_update", kind: "message", oneof: "data", T: () => UserMarker },
            { no: 6, name: "user_delete", kind: "scalar", oneof: "data", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<StreamResponse>): StreamResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.data = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<StreamResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamResponse): StreamResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool user_on_duty */ 1:
                    message.userOnDuty = reader.bool();
                    break;
                case /* services.livemap.JobsList jobs */ 2:
                    message.data = {
                        oneofKind: "jobs",
                        jobs: JobsList.internalBinaryRead(reader, reader.uint32(), options, (message.data as any).jobs)
                    };
                    break;
                case /* services.livemap.MarkerMarkersUpdates markers */ 3:
                    message.data = {
                        oneofKind: "markers",
                        markers: MarkerMarkersUpdates.internalBinaryRead(reader, reader.uint32(), options, (message.data as any).markers)
                    };
                    break;
                case /* services.livemap.Snapshot snapshot */ 4:
                    message.data = {
                        oneofKind: "snapshot",
                        snapshot: Snapshot.internalBinaryRead(reader, reader.uint32(), options, (message.data as any).snapshot)
                    };
                    break;
                case /* resources.livemap.UserMarker user_update */ 5:
                    message.data = {
                        oneofKind: "userUpdate",
                        userUpdate: UserMarker.internalBinaryRead(reader, reader.uint32(), options, (message.data as any).userUpdate)
                    };
                    break;
                case /* int32 user_delete */ 6:
                    message.data = {
                        oneofKind: "userDelete",
                        userDelete: reader.int32()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool user_on_duty = 1; */
        if (message.userOnDuty !== undefined)
            writer.tag(1, WireType.Varint).bool(message.userOnDuty);
        /* services.livemap.JobsList jobs = 2; */
        if (message.data.oneofKind === "jobs")
            JobsList.internalBinaryWrite(message.data.jobs, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* services.livemap.MarkerMarkersUpdates markers = 3; */
        if (message.data.oneofKind === "markers")
            MarkerMarkersUpdates.internalBinaryWrite(message.data.markers, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* services.livemap.Snapshot snapshot = 4; */
        if (message.data.oneofKind === "snapshot")
            Snapshot.internalBinaryWrite(message.data.snapshot, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* resources.livemap.UserMarker user_update = 5; */
        if (message.data.oneofKind === "userUpdate")
            UserMarker.internalBinaryWrite(message.data.userUpdate, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* int32 user_delete = 6; */
        if (message.data.oneofKind === "userDelete")
            writer.tag(6, WireType.Varint).int32(message.data.userDelete);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.livemap.StreamResponse
 */
export const StreamResponse = new StreamResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JobsList$Type extends MessageType<JobsList> {
    constructor() {
        super("services.livemap.JobsList", [
            { no: 1, name: "users", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Job },
            { no: 2, name: "markers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Job }
        ]);
    }
    create(value?: PartialMessage<JobsList>): JobsList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.users = [];
        message.markers = [];
        if (value !== undefined)
            reflectionMergePartial<JobsList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JobsList): JobsList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated resources.jobs.Job users */ 1:
                    message.users.push(Job.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated resources.jobs.Job markers */ 2:
                    message.markers.push(Job.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JobsList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated resources.jobs.Job users = 1; */
        for (let i = 0; i < message.users.length; i++)
            Job.internalBinaryWrite(message.users[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated resources.jobs.Job markers = 2; */
        for (let i = 0; i < message.markers.length; i++)
            Job.internalBinaryWrite(message.markers[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.livemap.JobsList
 */
export const JobsList = new JobsList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MarkerMarkersUpdates$Type extends MessageType<MarkerMarkersUpdates> {
    constructor() {
        super("services.livemap.MarkerMarkersUpdates", [
            { no: 1, name: "updated", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => MarkerMarker },
            { no: 2, name: "deleted", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 3, name: "part", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "partial", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<MarkerMarkersUpdates>): MarkerMarkersUpdates {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.updated = [];
        message.deleted = [];
        message.part = 0;
        message.partial = false;
        if (value !== undefined)
            reflectionMergePartial<MarkerMarkersUpdates>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MarkerMarkersUpdates): MarkerMarkersUpdates {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated resources.livemap.MarkerMarker updated */ 1:
                    message.updated.push(MarkerMarker.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated uint64 deleted */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.deleted.push(reader.uint64().toNumber());
                    else
                        message.deleted.push(reader.uint64().toNumber());
                    break;
                case /* int32 part */ 3:
                    message.part = reader.int32();
                    break;
                case /* bool partial */ 4:
                    message.partial = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MarkerMarkersUpdates, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated resources.livemap.MarkerMarker updated = 1; */
        for (let i = 0; i < message.updated.length; i++)
            MarkerMarker.internalBinaryWrite(message.updated[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated uint64 deleted = 2; */
        if (message.deleted.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.deleted.length; i++)
                writer.uint64(message.deleted[i]);
            writer.join();
        }
        /* int32 part = 3; */
        if (message.part !== 0)
            writer.tag(3, WireType.Varint).int32(message.part);
        /* bool partial = 4; */
        if (message.partial !== false)
            writer.tag(4, WireType.Varint).bool(message.partial);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.livemap.MarkerMarkersUpdates
 */
export const MarkerMarkersUpdates = new MarkerMarkersUpdates$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Snapshot$Type extends MessageType<Snapshot> {
    constructor() {
        super("services.livemap.Snapshot", [
            { no: 1, name: "markers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => UserMarker },
            { no: 2, name: "generated_at", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 3, name: "snapshot_seq", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 4, name: "schema_version", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Snapshot>): Snapshot {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.markers = [];
        message.generatedAt = 0;
        message.snapshotSeq = 0;
        message.schemaVersion = 0;
        if (value !== undefined)
            reflectionMergePartial<Snapshot>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Snapshot): Snapshot {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated resources.livemap.UserMarker markers */ 1:
                    message.markers.push(UserMarker.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int64 generated_at */ 2:
                    message.generatedAt = reader.int64().toNumber();
                    break;
                case /* uint64 snapshot_seq */ 3:
                    message.snapshotSeq = reader.uint64().toNumber();
                    break;
                case /* uint32 schema_version */ 4:
                    message.schemaVersion = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Snapshot, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated resources.livemap.UserMarker markers = 1; */
        for (let i = 0; i < message.markers.length; i++)
            UserMarker.internalBinaryWrite(message.markers[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int64 generated_at = 2; */
        if (message.generatedAt !== 0)
            writer.tag(2, WireType.Varint).int64(message.generatedAt);
        /* uint64 snapshot_seq = 3; */
        if (message.snapshotSeq !== 0)
            writer.tag(3, WireType.Varint).uint64(message.snapshotSeq);
        /* uint32 schema_version = 4; */
        if (message.schemaVersion !== 0)
            writer.tag(4, WireType.Varint).uint32(message.schemaVersion);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.livemap.Snapshot
 */
export const Snapshot = new Snapshot$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateOrUpdateMarkerRequest$Type extends MessageType<CreateOrUpdateMarkerRequest> {
    constructor() {
        super("services.livemap.CreateOrUpdateMarkerRequest", [
            { no: 1, name: "marker", kind: "message", T: () => MarkerMarker, options: { "validate.rules": { message: { required: true } } } }
        ]);
    }
    create(value?: PartialMessage<CreateOrUpdateMarkerRequest>): CreateOrUpdateMarkerRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CreateOrUpdateMarkerRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateOrUpdateMarkerRequest): CreateOrUpdateMarkerRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.livemap.MarkerMarker marker */ 1:
                    message.marker = MarkerMarker.internalBinaryRead(reader, reader.uint32(), options, message.marker);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateOrUpdateMarkerRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.livemap.MarkerMarker marker = 1; */
        if (message.marker)
            MarkerMarker.internalBinaryWrite(message.marker, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.livemap.CreateOrUpdateMarkerRequest
 */
export const CreateOrUpdateMarkerRequest = new CreateOrUpdateMarkerRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateOrUpdateMarkerResponse$Type extends MessageType<CreateOrUpdateMarkerResponse> {
    constructor() {
        super("services.livemap.CreateOrUpdateMarkerResponse", [
            { no: 1, name: "marker", kind: "message", T: () => MarkerMarker }
        ]);
    }
    create(value?: PartialMessage<CreateOrUpdateMarkerResponse>): CreateOrUpdateMarkerResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CreateOrUpdateMarkerResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateOrUpdateMarkerResponse): CreateOrUpdateMarkerResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.livemap.MarkerMarker marker */ 1:
                    message.marker = MarkerMarker.internalBinaryRead(reader, reader.uint32(), options, message.marker);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateOrUpdateMarkerResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.livemap.MarkerMarker marker = 1; */
        if (message.marker)
            MarkerMarker.internalBinaryWrite(message.marker, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.livemap.CreateOrUpdateMarkerResponse
 */
export const CreateOrUpdateMarkerResponse = new CreateOrUpdateMarkerResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteMarkerRequest$Type extends MessageType<DeleteMarkerRequest> {
    constructor() {
        super("services.livemap.DeleteMarkerRequest", [
            { no: 1, name: "id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteMarkerRequest>): DeleteMarkerRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        if (value !== undefined)
            reflectionMergePartial<DeleteMarkerRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteMarkerRequest): DeleteMarkerRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 id */ 1:
                    message.id = reader.uint64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteMarkerRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).uint64(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.livemap.DeleteMarkerRequest
 */
export const DeleteMarkerRequest = new DeleteMarkerRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteMarkerResponse$Type extends MessageType<DeleteMarkerResponse> {
    constructor() {
        super("services.livemap.DeleteMarkerResponse", []);
    }
    create(value?: PartialMessage<DeleteMarkerResponse>): DeleteMarkerResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DeleteMarkerResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteMarkerResponse): DeleteMarkerResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteMarkerResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.livemap.DeleteMarkerResponse
 */
export const DeleteMarkerResponse = new DeleteMarkerResponse$Type();
/**
 * @generated ServiceType for protobuf service services.livemap.LivemapService
 */
export const LivemapService = new ServiceType("services.livemap.LivemapService", [
    { name: "Stream", serverStreaming: true, options: {}, I: StreamRequest, O: StreamResponse },
    { name: "CreateOrUpdateMarker", options: {}, I: CreateOrUpdateMarkerRequest, O: CreateOrUpdateMarkerResponse },
    { name: "DeleteMarker", options: {}, I: DeleteMarkerRequest, O: DeleteMarkerResponse }
]);
