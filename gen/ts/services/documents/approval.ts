// @generated by protobuf-ts 2.11.1 with parameter force_server_none,long_type_number,optimize_speed,ts_nocheck
// @generated from protobuf file "services/documents/approval.proto" (package "services.documents", syntax proto3)
// tslint:disable
// @ts-nocheck
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { PaginationResponse } from "../../resources/common/database/database";
import { ApprovalTaskStatus } from "../../resources/documents/approval";
import { PaginationRequest } from "../../resources/common/database/database";
import { ApprovalAccess } from "../../resources/documents/approval";
import { ApprovalTask } from "../../resources/documents/approval";
import { Timestamp } from "../../resources/timestamp/timestamp";
import { OnEditBehavior } from "../../resources/documents/approval";
import { ApprovalRuleKind } from "../../resources/documents/approval";
import { ApprovalPolicy } from "../../resources/documents/approval";
/**
 * @generated from protobuf message services.documents.GetPolicyRequest
 */
export interface GetPolicyRequest {
    /**
     * @generated from protobuf field: int64 document_id = 1
     */
    documentId: number;
}
/**
 * @generated from protobuf message services.documents.GetPolicyResponse
 */
export interface GetPolicyResponse {
    /**
     * @generated from protobuf field: resources.documents.ApprovalPolicy policy = 1
     */
    policy?: ApprovalPolicy;
}
/**
 * @generated from protobuf message services.documents.UpsertPolicyRequest
 */
export interface UpsertPolicyRequest {
    /**
     * @generated from protobuf field: int64 document_id = 1
     */
    documentId: number;
    /**
     * @generated from protobuf field: resources.documents.ApprovalRuleKind rule_kind = 2
     */
    ruleKind: ApprovalRuleKind;
    /**
     * @generated from protobuf field: int32 required_count = 3
     */
    requiredCount: number; // used if QUORUM_ANY
    /**
     * @generated from protobuf field: resources.documents.OnEditBehavior on_edit_behavior = 4
     */
    onEditBehavior: OnEditBehavior;
    /**
     * @generated from protobuf field: resources.timestamp.Timestamp due_at = 5
     */
    dueAt?: Timestamp;
}
/**
 * @generated from protobuf message services.documents.UpsertPolicyResponse
 */
export interface UpsertPolicyResponse {
    /**
     * @generated from protobuf field: resources.documents.ApprovalPolicy policy = 1
     */
    policy?: ApprovalPolicy;
}
/**
 * @generated from protobuf message services.documents.StartApprovalRoundRequest
 */
export interface StartApprovalRoundRequest {
    /**
     * @generated from protobuf field: int64 document_id = 1
     */
    documentId: number;
    /**
     * @generated from protobuf field: resources.timestamp.Timestamp snapshot_date = 2
     */
    snapshotDate?: Timestamp; // if omitted, server uses now
    /**
     * @generated from protobuf field: bool regen_tasks = 3
     */
    regenTasks: boolean; // re-materialize tasks from ACL
}
/**
 * @generated from protobuf message services.documents.StartApprovalRoundResponse
 */
export interface StartApprovalRoundResponse {
    /**
     * @generated from protobuf field: resources.documents.ApprovalPolicy policy = 1
     */
    policy?: ApprovalPolicy;
    /**
     * @generated from protobuf field: repeated resources.documents.ApprovalTask tasks = 2
     */
    tasks: ApprovalTask[];
}
/**
 * @generated from protobuf message services.documents.CompleteApprovalRoundRequest
 */
export interface CompleteApprovalRoundRequest {
    /**
     * @generated from protobuf field: int64 document_id = 1
     */
    documentId: number;
}
/**
 * @generated from protobuf message services.documents.CompleteApprovalRoundResponse
 */
export interface CompleteApprovalRoundResponse {
    /**
     * @generated from protobuf field: resources.documents.ApprovalPolicy policy = 1
     */
    policy?: ApprovalPolicy;
}
/**
 * @generated from protobuf message services.documents.RecomputePolicyCountersRequest
 */
export interface RecomputePolicyCountersRequest {
    /**
     * @generated from protobuf field: int64 document_id = 1
     */
    documentId: number;
}
/**
 * @generated from protobuf message services.documents.RecomputePolicyCountersResponse
 */
export interface RecomputePolicyCountersResponse {
    /**
     * @generated from protobuf field: resources.documents.ApprovalPolicy policy = 1
     */
    policy?: ApprovalPolicy;
}
/**
 * @generated from protobuf message services.documents.ListApprovalAccessRequest
 */
export interface ListApprovalAccessRequest {
    /**
     * @generated from protobuf field: int64 policy_id = 1
     */
    policyId: number;
}
/**
 * @generated from protobuf message services.documents.ListApprovalAccessResponse
 */
export interface ListApprovalAccessResponse {
    /**
     * @generated from protobuf field: resources.documents.ApprovalAccess access = 1
     */
    access?: ApprovalAccess;
}
/**
 * @generated from protobuf message services.documents.UpsertApprovalAccessRequest
 */
export interface UpsertApprovalAccessRequest {
    /**
     * @generated from protobuf field: int64 document_id = 1
     */
    documentId: number;
    /**
     * @generated from protobuf field: resources.documents.ApprovalAccess access = 2
     */
    access?: ApprovalAccess;
}
/**
 * @generated from protobuf message services.documents.UpsertApprovalAccessResponse
 */
export interface UpsertApprovalAccessResponse {
    /**
     * @generated from protobuf field: resources.documents.ApprovalAccess access = 1
     */
    access?: ApprovalAccess;
}
/**
 * @generated from protobuf message services.documents.DeleteApprovalAccessRequest
 */
export interface DeleteApprovalAccessRequest {
    /**
     * @generated from protobuf field: int64 id = 1
     */
    id: number;
}
/**
 * @generated from protobuf message services.documents.DeleteApprovalAccessResponse
 */
export interface DeleteApprovalAccessResponse {
}
/**
 * @generated from protobuf message services.documents.ListApprovalTasksRequest
 */
export interface ListApprovalTasksRequest {
    /**
     * @generated from protobuf field: resources.common.database.PaginationRequest pagination = 1
     */
    pagination?: PaginationRequest;
    /**
     * Search
     *
     * @generated from protobuf field: int64 document_id = 2
     */
    documentId: number;
    /**
     * @generated from protobuf field: repeated resources.documents.ApprovalTaskStatus statuses = 3
     */
    statuses: ApprovalTaskStatus[];
}
/**
 * @generated from protobuf message services.documents.ListApprovalTasksResponse
 */
export interface ListApprovalTasksResponse {
    /**
     * @generated from protobuf field: resources.common.database.PaginationResponse pagination = 1
     */
    pagination?: PaginationResponse;
    /**
     * @generated from protobuf field: repeated resources.documents.ApprovalTask tasks = 2
     */
    tasks: ApprovalTask[];
}
/**
 * @generated from protobuf message services.documents.DecideTaskRequest
 */
export interface DecideTaskRequest {
    /**
     * @generated from protobuf field: int64 task_id = 1
     */
    taskId: number;
    /**
     * @generated from protobuf field: resources.documents.ApprovalTaskStatus new_status = 2
     */
    newStatus: ApprovalTaskStatus; // APPROVED or DECLINED
    /**
     * @generated from protobuf field: string comment = 3
     */
    comment: string;
    /**
     * @generated from protobuf field: string idempotency_key = 10
     */
    idempotencyKey: string;
}
/**
 * @generated from protobuf message services.documents.DecideTaskResponse
 */
export interface DecideTaskResponse {
    /**
     * @generated from protobuf field: resources.documents.ApprovalTask task = 1
     */
    task?: ApprovalTask;
    /**
     * @generated from protobuf field: resources.documents.ApprovalPolicy policy = 2
     */
    policy?: ApprovalPolicy; // counters updated
}
/**
 * @generated from protobuf message services.documents.ReopenTaskRequest
 */
export interface ReopenTaskRequest {
    /**
     * @generated from protobuf field: int64 task_id = 1
     */
    taskId: number;
    /**
     * @generated from protobuf field: string reason = 2
     */
    reason: string;
}
/**
 * @generated from protobuf message services.documents.ReopenTaskResponse
 */
export interface ReopenTaskResponse {
    /**
     * @generated from protobuf field: resources.documents.ApprovalTask task = 1
     */
    task?: ApprovalTask;
    /**
     * @generated from protobuf field: resources.documents.ApprovalPolicy policy = 2
     */
    policy?: ApprovalPolicy;
}
// @generated message type with reflection information, may provide speed optimized methods
class GetPolicyRequest$Type extends MessageType<GetPolicyRequest> {
    constructor() {
        super("services.documents.GetPolicyRequest", [
            { no: 1, name: "document_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/, options: { "buf.validate.field": { int64: { gt: "0" } } } }
        ]);
    }
    create(value?: PartialMessage<GetPolicyRequest>): GetPolicyRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.documentId = 0;
        if (value !== undefined)
            reflectionMergePartial<GetPolicyRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPolicyRequest): GetPolicyRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 document_id */ 1:
                    message.documentId = reader.int64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPolicyRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 document_id = 1; */
        if (message.documentId !== 0)
            writer.tag(1, WireType.Varint).int64(message.documentId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.documents.GetPolicyRequest
 */
export const GetPolicyRequest = new GetPolicyRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPolicyResponse$Type extends MessageType<GetPolicyResponse> {
    constructor() {
        super("services.documents.GetPolicyResponse", [
            { no: 1, name: "policy", kind: "message", T: () => ApprovalPolicy }
        ]);
    }
    create(value?: PartialMessage<GetPolicyResponse>): GetPolicyResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetPolicyResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPolicyResponse): GetPolicyResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.documents.ApprovalPolicy policy */ 1:
                    message.policy = ApprovalPolicy.internalBinaryRead(reader, reader.uint32(), options, message.policy);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPolicyResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.documents.ApprovalPolicy policy = 1; */
        if (message.policy)
            ApprovalPolicy.internalBinaryWrite(message.policy, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.documents.GetPolicyResponse
 */
export const GetPolicyResponse = new GetPolicyResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpsertPolicyRequest$Type extends MessageType<UpsertPolicyRequest> {
    constructor() {
        super("services.documents.UpsertPolicyRequest", [
            { no: 1, name: "document_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/, options: { "buf.validate.field": { int64: { gt: "0" } } } },
            { no: 2, name: "rule_kind", kind: "enum", T: () => ["resources.documents.ApprovalRuleKind", ApprovalRuleKind, "APPROVAL_RULE_KIND_"], options: { "buf.validate.field": { enum: { definedOnly: true } } } },
            { no: 3, name: "required_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "on_edit_behavior", kind: "enum", T: () => ["resources.documents.OnEditBehavior", OnEditBehavior, "ON_EDIT_BEHAVIOR_"], options: { "buf.validate.field": { enum: { definedOnly: true } } } },
            { no: 5, name: "due_at", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<UpsertPolicyRequest>): UpsertPolicyRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.documentId = 0;
        message.ruleKind = 0;
        message.requiredCount = 0;
        message.onEditBehavior = 0;
        if (value !== undefined)
            reflectionMergePartial<UpsertPolicyRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpsertPolicyRequest): UpsertPolicyRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 document_id */ 1:
                    message.documentId = reader.int64().toNumber();
                    break;
                case /* resources.documents.ApprovalRuleKind rule_kind */ 2:
                    message.ruleKind = reader.int32();
                    break;
                case /* int32 required_count */ 3:
                    message.requiredCount = reader.int32();
                    break;
                case /* resources.documents.OnEditBehavior on_edit_behavior */ 4:
                    message.onEditBehavior = reader.int32();
                    break;
                case /* resources.timestamp.Timestamp due_at */ 5:
                    message.dueAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.dueAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpsertPolicyRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 document_id = 1; */
        if (message.documentId !== 0)
            writer.tag(1, WireType.Varint).int64(message.documentId);
        /* resources.documents.ApprovalRuleKind rule_kind = 2; */
        if (message.ruleKind !== 0)
            writer.tag(2, WireType.Varint).int32(message.ruleKind);
        /* int32 required_count = 3; */
        if (message.requiredCount !== 0)
            writer.tag(3, WireType.Varint).int32(message.requiredCount);
        /* resources.documents.OnEditBehavior on_edit_behavior = 4; */
        if (message.onEditBehavior !== 0)
            writer.tag(4, WireType.Varint).int32(message.onEditBehavior);
        /* resources.timestamp.Timestamp due_at = 5; */
        if (message.dueAt)
            Timestamp.internalBinaryWrite(message.dueAt, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.documents.UpsertPolicyRequest
 */
export const UpsertPolicyRequest = new UpsertPolicyRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpsertPolicyResponse$Type extends MessageType<UpsertPolicyResponse> {
    constructor() {
        super("services.documents.UpsertPolicyResponse", [
            { no: 1, name: "policy", kind: "message", T: () => ApprovalPolicy }
        ]);
    }
    create(value?: PartialMessage<UpsertPolicyResponse>): UpsertPolicyResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UpsertPolicyResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpsertPolicyResponse): UpsertPolicyResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.documents.ApprovalPolicy policy */ 1:
                    message.policy = ApprovalPolicy.internalBinaryRead(reader, reader.uint32(), options, message.policy);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpsertPolicyResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.documents.ApprovalPolicy policy = 1; */
        if (message.policy)
            ApprovalPolicy.internalBinaryWrite(message.policy, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.documents.UpsertPolicyResponse
 */
export const UpsertPolicyResponse = new UpsertPolicyResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StartApprovalRoundRequest$Type extends MessageType<StartApprovalRoundRequest> {
    constructor() {
        super("services.documents.StartApprovalRoundRequest", [
            { no: 1, name: "document_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/, options: { "buf.validate.field": { int64: { gt: "0" } } } },
            { no: 2, name: "snapshot_date", kind: "message", T: () => Timestamp },
            { no: 3, name: "regen_tasks", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<StartApprovalRoundRequest>): StartApprovalRoundRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.documentId = 0;
        message.regenTasks = false;
        if (value !== undefined)
            reflectionMergePartial<StartApprovalRoundRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StartApprovalRoundRequest): StartApprovalRoundRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 document_id */ 1:
                    message.documentId = reader.int64().toNumber();
                    break;
                case /* resources.timestamp.Timestamp snapshot_date */ 2:
                    message.snapshotDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.snapshotDate);
                    break;
                case /* bool regen_tasks */ 3:
                    message.regenTasks = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StartApprovalRoundRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 document_id = 1; */
        if (message.documentId !== 0)
            writer.tag(1, WireType.Varint).int64(message.documentId);
        /* resources.timestamp.Timestamp snapshot_date = 2; */
        if (message.snapshotDate)
            Timestamp.internalBinaryWrite(message.snapshotDate, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bool regen_tasks = 3; */
        if (message.regenTasks !== false)
            writer.tag(3, WireType.Varint).bool(message.regenTasks);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.documents.StartApprovalRoundRequest
 */
export const StartApprovalRoundRequest = new StartApprovalRoundRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StartApprovalRoundResponse$Type extends MessageType<StartApprovalRoundResponse> {
    constructor() {
        super("services.documents.StartApprovalRoundResponse", [
            { no: 1, name: "policy", kind: "message", T: () => ApprovalPolicy },
            { no: 2, name: "tasks", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ApprovalTask, options: { "codegen.itemslen.enabled": true } }
        ]);
    }
    create(value?: PartialMessage<StartApprovalRoundResponse>): StartApprovalRoundResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tasks = [];
        if (value !== undefined)
            reflectionMergePartial<StartApprovalRoundResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StartApprovalRoundResponse): StartApprovalRoundResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.documents.ApprovalPolicy policy */ 1:
                    message.policy = ApprovalPolicy.internalBinaryRead(reader, reader.uint32(), options, message.policy);
                    break;
                case /* repeated resources.documents.ApprovalTask tasks */ 2:
                    message.tasks.push(ApprovalTask.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StartApprovalRoundResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.documents.ApprovalPolicy policy = 1; */
        if (message.policy)
            ApprovalPolicy.internalBinaryWrite(message.policy, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated resources.documents.ApprovalTask tasks = 2; */
        for (let i = 0; i < message.tasks.length; i++)
            ApprovalTask.internalBinaryWrite(message.tasks[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.documents.StartApprovalRoundResponse
 */
export const StartApprovalRoundResponse = new StartApprovalRoundResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CompleteApprovalRoundRequest$Type extends MessageType<CompleteApprovalRoundRequest> {
    constructor() {
        super("services.documents.CompleteApprovalRoundRequest", [
            { no: 1, name: "document_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/, options: { "buf.validate.field": { int64: { gt: "0" } } } }
        ]);
    }
    create(value?: PartialMessage<CompleteApprovalRoundRequest>): CompleteApprovalRoundRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.documentId = 0;
        if (value !== undefined)
            reflectionMergePartial<CompleteApprovalRoundRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CompleteApprovalRoundRequest): CompleteApprovalRoundRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 document_id */ 1:
                    message.documentId = reader.int64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CompleteApprovalRoundRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 document_id = 1; */
        if (message.documentId !== 0)
            writer.tag(1, WireType.Varint).int64(message.documentId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.documents.CompleteApprovalRoundRequest
 */
export const CompleteApprovalRoundRequest = new CompleteApprovalRoundRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CompleteApprovalRoundResponse$Type extends MessageType<CompleteApprovalRoundResponse> {
    constructor() {
        super("services.documents.CompleteApprovalRoundResponse", [
            { no: 1, name: "policy", kind: "message", T: () => ApprovalPolicy }
        ]);
    }
    create(value?: PartialMessage<CompleteApprovalRoundResponse>): CompleteApprovalRoundResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CompleteApprovalRoundResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CompleteApprovalRoundResponse): CompleteApprovalRoundResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.documents.ApprovalPolicy policy */ 1:
                    message.policy = ApprovalPolicy.internalBinaryRead(reader, reader.uint32(), options, message.policy);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CompleteApprovalRoundResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.documents.ApprovalPolicy policy = 1; */
        if (message.policy)
            ApprovalPolicy.internalBinaryWrite(message.policy, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.documents.CompleteApprovalRoundResponse
 */
export const CompleteApprovalRoundResponse = new CompleteApprovalRoundResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RecomputePolicyCountersRequest$Type extends MessageType<RecomputePolicyCountersRequest> {
    constructor() {
        super("services.documents.RecomputePolicyCountersRequest", [
            { no: 1, name: "document_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/, options: { "buf.validate.field": { int64: { gt: "0" } } } }
        ]);
    }
    create(value?: PartialMessage<RecomputePolicyCountersRequest>): RecomputePolicyCountersRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.documentId = 0;
        if (value !== undefined)
            reflectionMergePartial<RecomputePolicyCountersRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RecomputePolicyCountersRequest): RecomputePolicyCountersRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 document_id */ 1:
                    message.documentId = reader.int64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RecomputePolicyCountersRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 document_id = 1; */
        if (message.documentId !== 0)
            writer.tag(1, WireType.Varint).int64(message.documentId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.documents.RecomputePolicyCountersRequest
 */
export const RecomputePolicyCountersRequest = new RecomputePolicyCountersRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RecomputePolicyCountersResponse$Type extends MessageType<RecomputePolicyCountersResponse> {
    constructor() {
        super("services.documents.RecomputePolicyCountersResponse", [
            { no: 1, name: "policy", kind: "message", T: () => ApprovalPolicy }
        ]);
    }
    create(value?: PartialMessage<RecomputePolicyCountersResponse>): RecomputePolicyCountersResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RecomputePolicyCountersResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RecomputePolicyCountersResponse): RecomputePolicyCountersResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.documents.ApprovalPolicy policy */ 1:
                    message.policy = ApprovalPolicy.internalBinaryRead(reader, reader.uint32(), options, message.policy);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RecomputePolicyCountersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.documents.ApprovalPolicy policy = 1; */
        if (message.policy)
            ApprovalPolicy.internalBinaryWrite(message.policy, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.documents.RecomputePolicyCountersResponse
 */
export const RecomputePolicyCountersResponse = new RecomputePolicyCountersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListApprovalAccessRequest$Type extends MessageType<ListApprovalAccessRequest> {
    constructor() {
        super("services.documents.ListApprovalAccessRequest", [
            { no: 1, name: "policy_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/, options: { "buf.validate.field": { int64: { gt: "0" } } } }
        ]);
    }
    create(value?: PartialMessage<ListApprovalAccessRequest>): ListApprovalAccessRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.policyId = 0;
        if (value !== undefined)
            reflectionMergePartial<ListApprovalAccessRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListApprovalAccessRequest): ListApprovalAccessRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 policy_id */ 1:
                    message.policyId = reader.int64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListApprovalAccessRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 policy_id = 1; */
        if (message.policyId !== 0)
            writer.tag(1, WireType.Varint).int64(message.policyId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.documents.ListApprovalAccessRequest
 */
export const ListApprovalAccessRequest = new ListApprovalAccessRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListApprovalAccessResponse$Type extends MessageType<ListApprovalAccessResponse> {
    constructor() {
        super("services.documents.ListApprovalAccessResponse", [
            { no: 1, name: "access", kind: "message", T: () => ApprovalAccess }
        ]);
    }
    create(value?: PartialMessage<ListApprovalAccessResponse>): ListApprovalAccessResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ListApprovalAccessResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListApprovalAccessResponse): ListApprovalAccessResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.documents.ApprovalAccess access */ 1:
                    message.access = ApprovalAccess.internalBinaryRead(reader, reader.uint32(), options, message.access);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListApprovalAccessResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.documents.ApprovalAccess access = 1; */
        if (message.access)
            ApprovalAccess.internalBinaryWrite(message.access, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.documents.ListApprovalAccessResponse
 */
export const ListApprovalAccessResponse = new ListApprovalAccessResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpsertApprovalAccessRequest$Type extends MessageType<UpsertApprovalAccessRequest> {
    constructor() {
        super("services.documents.UpsertApprovalAccessRequest", [
            { no: 1, name: "document_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/, options: { "buf.validate.field": { int64: { gt: "0" } } } },
            { no: 2, name: "access", kind: "message", T: () => ApprovalAccess, options: { "buf.validate.field": { required: true } } }
        ]);
    }
    create(value?: PartialMessage<UpsertApprovalAccessRequest>): UpsertApprovalAccessRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.documentId = 0;
        if (value !== undefined)
            reflectionMergePartial<UpsertApprovalAccessRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpsertApprovalAccessRequest): UpsertApprovalAccessRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 document_id */ 1:
                    message.documentId = reader.int64().toNumber();
                    break;
                case /* resources.documents.ApprovalAccess access */ 2:
                    message.access = ApprovalAccess.internalBinaryRead(reader, reader.uint32(), options, message.access);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpsertApprovalAccessRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 document_id = 1; */
        if (message.documentId !== 0)
            writer.tag(1, WireType.Varint).int64(message.documentId);
        /* resources.documents.ApprovalAccess access = 2; */
        if (message.access)
            ApprovalAccess.internalBinaryWrite(message.access, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.documents.UpsertApprovalAccessRequest
 */
export const UpsertApprovalAccessRequest = new UpsertApprovalAccessRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpsertApprovalAccessResponse$Type extends MessageType<UpsertApprovalAccessResponse> {
    constructor() {
        super("services.documents.UpsertApprovalAccessResponse", [
            { no: 1, name: "access", kind: "message", T: () => ApprovalAccess }
        ]);
    }
    create(value?: PartialMessage<UpsertApprovalAccessResponse>): UpsertApprovalAccessResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UpsertApprovalAccessResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpsertApprovalAccessResponse): UpsertApprovalAccessResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.documents.ApprovalAccess access */ 1:
                    message.access = ApprovalAccess.internalBinaryRead(reader, reader.uint32(), options, message.access);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpsertApprovalAccessResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.documents.ApprovalAccess access = 1; */
        if (message.access)
            ApprovalAccess.internalBinaryWrite(message.access, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.documents.UpsertApprovalAccessResponse
 */
export const UpsertApprovalAccessResponse = new UpsertApprovalAccessResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteApprovalAccessRequest$Type extends MessageType<DeleteApprovalAccessRequest> {
    constructor() {
        super("services.documents.DeleteApprovalAccessRequest", [
            { no: 1, name: "id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/, options: { "buf.validate.field": { int64: { gt: "0" } } } }
        ]);
    }
    create(value?: PartialMessage<DeleteApprovalAccessRequest>): DeleteApprovalAccessRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        if (value !== undefined)
            reflectionMergePartial<DeleteApprovalAccessRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteApprovalAccessRequest): DeleteApprovalAccessRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 id */ 1:
                    message.id = reader.int64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteApprovalAccessRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int64(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.documents.DeleteApprovalAccessRequest
 */
export const DeleteApprovalAccessRequest = new DeleteApprovalAccessRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteApprovalAccessResponse$Type extends MessageType<DeleteApprovalAccessResponse> {
    constructor() {
        super("services.documents.DeleteApprovalAccessResponse", []);
    }
    create(value?: PartialMessage<DeleteApprovalAccessResponse>): DeleteApprovalAccessResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DeleteApprovalAccessResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteApprovalAccessResponse): DeleteApprovalAccessResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteApprovalAccessResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.documents.DeleteApprovalAccessResponse
 */
export const DeleteApprovalAccessResponse = new DeleteApprovalAccessResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListApprovalTasksRequest$Type extends MessageType<ListApprovalTasksRequest> {
    constructor() {
        super("services.documents.ListApprovalTasksRequest", [
            { no: 1, name: "pagination", kind: "message", T: () => PaginationRequest, options: { "buf.validate.field": { required: true } } },
            { no: 2, name: "document_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/, options: { "buf.validate.field": { int64: { gt: "0" } } } },
            { no: 3, name: "statuses", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["resources.documents.ApprovalTaskStatus", ApprovalTaskStatus, "APPROVAL_TASK_STATUS_"], options: { "buf.validate.field": { repeated: { maxItems: "4" } } } }
        ]);
    }
    create(value?: PartialMessage<ListApprovalTasksRequest>): ListApprovalTasksRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.documentId = 0;
        message.statuses = [];
        if (value !== undefined)
            reflectionMergePartial<ListApprovalTasksRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListApprovalTasksRequest): ListApprovalTasksRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.common.database.PaginationRequest pagination */ 1:
                    message.pagination = PaginationRequest.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                case /* int64 document_id */ 2:
                    message.documentId = reader.int64().toNumber();
                    break;
                case /* repeated resources.documents.ApprovalTaskStatus statuses */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.statuses.push(reader.int32());
                    else
                        message.statuses.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListApprovalTasksRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.common.database.PaginationRequest pagination = 1; */
        if (message.pagination)
            PaginationRequest.internalBinaryWrite(message.pagination, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int64 document_id = 2; */
        if (message.documentId !== 0)
            writer.tag(2, WireType.Varint).int64(message.documentId);
        /* repeated resources.documents.ApprovalTaskStatus statuses = 3; */
        if (message.statuses.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.statuses.length; i++)
                writer.int32(message.statuses[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.documents.ListApprovalTasksRequest
 */
export const ListApprovalTasksRequest = new ListApprovalTasksRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListApprovalTasksResponse$Type extends MessageType<ListApprovalTasksResponse> {
    constructor() {
        super("services.documents.ListApprovalTasksResponse", [
            { no: 1, name: "pagination", kind: "message", T: () => PaginationResponse, options: { "buf.validate.field": { required: true } } },
            { no: 2, name: "tasks", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ApprovalTask, options: { "codegen.itemslen.enabled": true } }
        ]);
    }
    create(value?: PartialMessage<ListApprovalTasksResponse>): ListApprovalTasksResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tasks = [];
        if (value !== undefined)
            reflectionMergePartial<ListApprovalTasksResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListApprovalTasksResponse): ListApprovalTasksResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.common.database.PaginationResponse pagination */ 1:
                    message.pagination = PaginationResponse.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                case /* repeated resources.documents.ApprovalTask tasks */ 2:
                    message.tasks.push(ApprovalTask.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListApprovalTasksResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.common.database.PaginationResponse pagination = 1; */
        if (message.pagination)
            PaginationResponse.internalBinaryWrite(message.pagination, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated resources.documents.ApprovalTask tasks = 2; */
        for (let i = 0; i < message.tasks.length; i++)
            ApprovalTask.internalBinaryWrite(message.tasks[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.documents.ListApprovalTasksResponse
 */
export const ListApprovalTasksResponse = new ListApprovalTasksResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DecideTaskRequest$Type extends MessageType<DecideTaskRequest> {
    constructor() {
        super("services.documents.DecideTaskRequest", [
            { no: 1, name: "task_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/, options: { "buf.validate.field": { int64: { gt: "0" } } } },
            { no: 2, name: "new_status", kind: "enum", T: () => ["resources.documents.ApprovalTaskStatus", ApprovalTaskStatus, "APPROVAL_TASK_STATUS_"], options: { "buf.validate.field": { enum: { definedOnly: true } } } },
            { no: 3, name: "comment", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { string: { maxLen: "500" } } } },
            { no: 10, name: "idempotency_key", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { string: { maxLen: "64" } } } }
        ]);
    }
    create(value?: PartialMessage<DecideTaskRequest>): DecideTaskRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.taskId = 0;
        message.newStatus = 0;
        message.comment = "";
        message.idempotencyKey = "";
        if (value !== undefined)
            reflectionMergePartial<DecideTaskRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DecideTaskRequest): DecideTaskRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 task_id */ 1:
                    message.taskId = reader.int64().toNumber();
                    break;
                case /* resources.documents.ApprovalTaskStatus new_status */ 2:
                    message.newStatus = reader.int32();
                    break;
                case /* string comment */ 3:
                    message.comment = reader.string();
                    break;
                case /* string idempotency_key */ 10:
                    message.idempotencyKey = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DecideTaskRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 task_id = 1; */
        if (message.taskId !== 0)
            writer.tag(1, WireType.Varint).int64(message.taskId);
        /* resources.documents.ApprovalTaskStatus new_status = 2; */
        if (message.newStatus !== 0)
            writer.tag(2, WireType.Varint).int32(message.newStatus);
        /* string comment = 3; */
        if (message.comment !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.comment);
        /* string idempotency_key = 10; */
        if (message.idempotencyKey !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.idempotencyKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.documents.DecideTaskRequest
 */
export const DecideTaskRequest = new DecideTaskRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DecideTaskResponse$Type extends MessageType<DecideTaskResponse> {
    constructor() {
        super("services.documents.DecideTaskResponse", [
            { no: 1, name: "task", kind: "message", T: () => ApprovalTask },
            { no: 2, name: "policy", kind: "message", T: () => ApprovalPolicy }
        ]);
    }
    create(value?: PartialMessage<DecideTaskResponse>): DecideTaskResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DecideTaskResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DecideTaskResponse): DecideTaskResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.documents.ApprovalTask task */ 1:
                    message.task = ApprovalTask.internalBinaryRead(reader, reader.uint32(), options, message.task);
                    break;
                case /* resources.documents.ApprovalPolicy policy */ 2:
                    message.policy = ApprovalPolicy.internalBinaryRead(reader, reader.uint32(), options, message.policy);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DecideTaskResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.documents.ApprovalTask task = 1; */
        if (message.task)
            ApprovalTask.internalBinaryWrite(message.task, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* resources.documents.ApprovalPolicy policy = 2; */
        if (message.policy)
            ApprovalPolicy.internalBinaryWrite(message.policy, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.documents.DecideTaskResponse
 */
export const DecideTaskResponse = new DecideTaskResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReopenTaskRequest$Type extends MessageType<ReopenTaskRequest> {
    constructor() {
        super("services.documents.ReopenTaskRequest", [
            { no: 1, name: "task_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/, options: { "buf.validate.field": { int64: { gt: "0" } } } },
            { no: 2, name: "reason", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { string: { maxLen: "255" } } } }
        ]);
    }
    create(value?: PartialMessage<ReopenTaskRequest>): ReopenTaskRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.taskId = 0;
        message.reason = "";
        if (value !== undefined)
            reflectionMergePartial<ReopenTaskRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReopenTaskRequest): ReopenTaskRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 task_id */ 1:
                    message.taskId = reader.int64().toNumber();
                    break;
                case /* string reason */ 2:
                    message.reason = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReopenTaskRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 task_id = 1; */
        if (message.taskId !== 0)
            writer.tag(1, WireType.Varint).int64(message.taskId);
        /* string reason = 2; */
        if (message.reason !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.reason);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.documents.ReopenTaskRequest
 */
export const ReopenTaskRequest = new ReopenTaskRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReopenTaskResponse$Type extends MessageType<ReopenTaskResponse> {
    constructor() {
        super("services.documents.ReopenTaskResponse", [
            { no: 1, name: "task", kind: "message", T: () => ApprovalTask },
            { no: 2, name: "policy", kind: "message", T: () => ApprovalPolicy }
        ]);
    }
    create(value?: PartialMessage<ReopenTaskResponse>): ReopenTaskResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ReopenTaskResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReopenTaskResponse): ReopenTaskResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.documents.ApprovalTask task */ 1:
                    message.task = ApprovalTask.internalBinaryRead(reader, reader.uint32(), options, message.task);
                    break;
                case /* resources.documents.ApprovalPolicy policy */ 2:
                    message.policy = ApprovalPolicy.internalBinaryRead(reader, reader.uint32(), options, message.policy);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReopenTaskResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.documents.ApprovalTask task = 1; */
        if (message.task)
            ApprovalTask.internalBinaryWrite(message.task, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* resources.documents.ApprovalPolicy policy = 2; */
        if (message.policy)
            ApprovalPolicy.internalBinaryWrite(message.policy, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.documents.ReopenTaskResponse
 */
export const ReopenTaskResponse = new ReopenTaskResponse$Type();
/**
 * @generated ServiceType for protobuf service services.documents.ApprovalService
 */
export const ApprovalService = new ServiceType("services.documents.ApprovalService", [
    { name: "GetPolicy", options: { "codegen.perms.perms": { enabled: true, service: "DocumentsService", name: "ListDocuments" } }, I: GetPolicyRequest, O: GetPolicyResponse },
    { name: "UpsertPolicy", options: { "codegen.perms.perms": { enabled: true } }, I: UpsertPolicyRequest, O: UpsertPolicyResponse },
    { name: "StartApprovalRound", options: { "codegen.perms.perms": { enabled: true, service: "DocumentsService", name: "ListDocuments" } }, I: StartApprovalRoundRequest, O: StartApprovalRoundResponse },
    { name: "CompleteApprovalRound", options: { "codegen.perms.perms": { enabled: true, service: "DocumentsService", name: "ListDocuments" } }, I: CompleteApprovalRoundRequest, O: CompleteApprovalRoundResponse },
    { name: "RecomputePolicyCounters", options: { "codegen.perms.perms": { enabled: true, name: "DeleteApprovalAccess" } }, I: RecomputePolicyCountersRequest, O: RecomputePolicyCountersResponse },
    { name: "ListApprovalAccess", options: { "codegen.perms.perms": { enabled: true, service: "DocumentsService", name: "ListDocuments" } }, I: ListApprovalAccessRequest, O: ListApprovalAccessResponse },
    { name: "UpsertApprovalAccess", options: { "codegen.perms.perms": { enabled: true, service: "DocumentsService", name: "ListDocuments" } }, I: UpsertApprovalAccessRequest, O: UpsertApprovalAccessResponse },
    { name: "DeleteApprovalAccess", options: { "codegen.perms.perms": { enabled: true } }, I: DeleteApprovalAccessRequest, O: DeleteApprovalAccessResponse },
    { name: "ListApprovalTasks", options: { "codegen.perms.perms": { enabled: true, service: "DocumentsService", name: "ListDocuments" } }, I: ListApprovalTasksRequest, O: ListApprovalTasksResponse },
    { name: "DecideTask", options: { "codegen.perms.perms": { enabled: true, service: "DocumentsService", name: "ListDocuments" } }, I: DecideTaskRequest, O: DecideTaskResponse },
    { name: "ReopenTask", options: { "codegen.perms.perms": { enabled: true } }, I: ReopenTaskRequest, O: ReopenTaskResponse }
], { "codegen.perms.perms_svc": { order: 52, icon: "i-mdi-approval" } });
