// @generated by protobuf-ts 2.11.1 with parameter optimize_speed,long_type_number,force_server_none
// @generated from protobuf file "services/calendar/calendar.proto" (package "services.calendar", syntax proto3)
// @ts-nocheck
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { CalendarSub } from "../../resources/calendar/calendar";
import { CalendarEntryRSVP } from "../../resources/calendar/calendar";
import { CalendarEntry } from "../../resources/calendar/calendar";
import { Calendar } from "../../resources/calendar/calendar";
import { PaginationResponse } from "../../resources/common/database/database";
import { Timestamp } from "../../resources/timestamp/timestamp";
import { AccessLevel } from "../../resources/calendar/access";
import { PaginationRequest } from "../../resources/common/database/database";
// Calendar

/**
 * @generated from protobuf message services.calendar.ListCalendarsRequest
 */
export interface ListCalendarsRequest {
    /**
     * @generated from protobuf field: resources.common.database.PaginationRequest pagination = 1
     */
    pagination?: PaginationRequest;
    /**
     * @generated from protobuf field: bool only_public = 2
     */
    onlyPublic: boolean;
    /**
     * @generated from protobuf field: optional resources.calendar.AccessLevel min_access_level = 3
     */
    minAccessLevel?: AccessLevel;
    /**
     * @generated from protobuf field: optional resources.timestamp.Timestamp after = 4
     */
    after?: Timestamp;
}
/**
 * @generated from protobuf message services.calendar.ListCalendarsResponse
 */
export interface ListCalendarsResponse {
    /**
     * @generated from protobuf field: resources.common.database.PaginationResponse pagination = 1
     */
    pagination?: PaginationResponse;
    /**
     * @generated from protobuf field: repeated resources.calendar.Calendar calendars = 2
     */
    calendars: Calendar[];
}
/**
 * @generated from protobuf message services.calendar.GetCalendarRequest
 */
export interface GetCalendarRequest {
    /**
     * @generated from protobuf field: uint64 calendar_id = 1
     */
    calendarId: number;
}
/**
 * @generated from protobuf message services.calendar.GetCalendarResponse
 */
export interface GetCalendarResponse {
    /**
     * @generated from protobuf field: resources.calendar.Calendar calendar = 1
     */
    calendar?: Calendar;
}
/**
 * @generated from protobuf message services.calendar.CreateCalendarRequest
 */
export interface CreateCalendarRequest {
    /**
     * @generated from protobuf field: resources.calendar.Calendar calendar = 1
     */
    calendar?: Calendar;
}
/**
 * @generated from protobuf message services.calendar.CreateCalendarResponse
 */
export interface CreateCalendarResponse {
    /**
     * @generated from protobuf field: resources.calendar.Calendar calendar = 1
     */
    calendar?: Calendar;
}
/**
 * @generated from protobuf message services.calendar.UpdateCalendarRequest
 */
export interface UpdateCalendarRequest {
    /**
     * @generated from protobuf field: resources.calendar.Calendar calendar = 1
     */
    calendar?: Calendar;
}
/**
 * @generated from protobuf message services.calendar.UpdateCalendarResponse
 */
export interface UpdateCalendarResponse {
    /**
     * @generated from protobuf field: resources.calendar.Calendar calendar = 1
     */
    calendar?: Calendar;
}
/**
 * @generated from protobuf message services.calendar.DeleteCalendarRequest
 */
export interface DeleteCalendarRequest {
    /**
     * @generated from protobuf field: uint64 calendar_id = 1
     */
    calendarId: number;
}
/**
 * @generated from protobuf message services.calendar.DeleteCalendarResponse
 */
export interface DeleteCalendarResponse {
}
// Calendar Entries

/**
 * @generated from protobuf message services.calendar.ListCalendarEntriesRequest
 */
export interface ListCalendarEntriesRequest {
    /**
     * @generated from protobuf field: int32 year = 1
     */
    year: number;
    /**
     * @generated from protobuf field: int32 month = 2
     */
    month: number;
    /**
     * @generated from protobuf field: repeated uint64 calendar_ids = 3
     */
    calendarIds: number[];
    /**
     * @generated from protobuf field: optional bool show_hidden = 4
     */
    showHidden?: boolean;
    /**
     * @generated from protobuf field: optional resources.timestamp.Timestamp after = 5
     */
    after?: Timestamp;
}
/**
 * @generated from protobuf message services.calendar.ListCalendarEntriesResponse
 */
export interface ListCalendarEntriesResponse {
    /**
     * @generated from protobuf field: repeated resources.calendar.CalendarEntry entries = 1
     */
    entries: CalendarEntry[];
}
/**
 * @generated from protobuf message services.calendar.GetUpcomingEntriesRequest
 */
export interface GetUpcomingEntriesRequest {
    /**
     * @generated from protobuf field: int32 seconds = 1
     */
    seconds: number;
}
/**
 * @generated from protobuf message services.calendar.GetUpcomingEntriesResponse
 */
export interface GetUpcomingEntriesResponse {
    /**
     * @generated from protobuf field: repeated resources.calendar.CalendarEntry entries = 1
     */
    entries: CalendarEntry[];
}
/**
 * @generated from protobuf message services.calendar.GetCalendarEntryRequest
 */
export interface GetCalendarEntryRequest {
    /**
     * @generated from protobuf field: uint64 entry_id = 1
     */
    entryId: number;
}
/**
 * @generated from protobuf message services.calendar.GetCalendarEntryResponse
 */
export interface GetCalendarEntryResponse {
    /**
     * @generated from protobuf field: resources.calendar.CalendarEntry entry = 1
     */
    entry?: CalendarEntry;
}
/**
 * @generated from protobuf message services.calendar.CreateOrUpdateCalendarEntryRequest
 */
export interface CreateOrUpdateCalendarEntryRequest {
    /**
     * @generated from protobuf field: resources.calendar.CalendarEntry entry = 1
     */
    entry?: CalendarEntry;
    /**
     * @generated from protobuf field: repeated int32 user_ids = 2
     */
    userIds: number[];
}
/**
 * @generated from protobuf message services.calendar.CreateOrUpdateCalendarEntryResponse
 */
export interface CreateOrUpdateCalendarEntryResponse {
    /**
     * @generated from protobuf field: resources.calendar.CalendarEntry entry = 1
     */
    entry?: CalendarEntry;
}
/**
 * @generated from protobuf message services.calendar.DeleteCalendarEntryRequest
 */
export interface DeleteCalendarEntryRequest {
    /**
     * @generated from protobuf field: uint64 entry_id = 1
     */
    entryId: number;
}
/**
 * @generated from protobuf message services.calendar.DeleteCalendarEntryResponse
 */
export interface DeleteCalendarEntryResponse {
}
/**
 * @generated from protobuf message services.calendar.ShareCalendarEntryRequest
 */
export interface ShareCalendarEntryRequest {
    /**
     * @generated from protobuf field: uint64 entry_id = 1
     */
    entryId: number;
    /**
     * @generated from protobuf field: repeated int32 user_ids = 2
     */
    userIds: number[];
}
/**
 * @generated from protobuf message services.calendar.ShareCalendarEntryResponse
 */
export interface ShareCalendarEntryResponse {
}
// RSVP

/**
 * @generated from protobuf message services.calendar.ListCalendarEntryRSVPRequest
 */
export interface ListCalendarEntryRSVPRequest {
    /**
     * @generated from protobuf field: resources.common.database.PaginationRequest pagination = 1
     */
    pagination?: PaginationRequest;
    /**
     * @generated from protobuf field: uint64 entry_id = 2
     */
    entryId: number;
}
/**
 * @generated from protobuf message services.calendar.ListCalendarEntryRSVPResponse
 */
export interface ListCalendarEntryRSVPResponse {
    /**
     * @generated from protobuf field: resources.common.database.PaginationResponse pagination = 1
     */
    pagination?: PaginationResponse;
    /**
     * @generated from protobuf field: repeated resources.calendar.CalendarEntryRSVP entries = 2
     */
    entries: CalendarEntryRSVP[];
}
/**
 * @generated from protobuf message services.calendar.RSVPCalendarEntryRequest
 */
export interface RSVPCalendarEntryRequest {
    /**
     * @generated from protobuf field: resources.calendar.CalendarEntryRSVP entry = 1
     */
    entry?: CalendarEntryRSVP;
    /**
     * @generated from protobuf field: bool subscribe = 2
     */
    subscribe: boolean;
    /**
     * @generated from protobuf field: optional bool remove = 3
     */
    remove?: boolean;
}
/**
 * @generated from protobuf message services.calendar.RSVPCalendarEntryResponse
 */
export interface RSVPCalendarEntryResponse {
    /**
     * @generated from protobuf field: optional resources.calendar.CalendarEntryRSVP entry = 1
     */
    entry?: CalendarEntryRSVP;
}
// Subs

/**
 * @generated from protobuf message services.calendar.ListSubscriptionsRequest
 */
export interface ListSubscriptionsRequest {
    /**
     * @generated from protobuf field: resources.common.database.PaginationRequest pagination = 1
     */
    pagination?: PaginationRequest;
}
/**
 * @generated from protobuf message services.calendar.ListSubscriptionsResponse
 */
export interface ListSubscriptionsResponse {
    /**
     * @generated from protobuf field: resources.common.database.PaginationResponse pagination = 1
     */
    pagination?: PaginationResponse;
    /**
     * @generated from protobuf field: repeated resources.calendar.CalendarSub subs = 2
     */
    subs: CalendarSub[];
}
/**
 * @generated from protobuf message services.calendar.SubscribeToCalendarRequest
 */
export interface SubscribeToCalendarRequest {
    /**
     * @generated from protobuf field: resources.calendar.CalendarSub sub = 1
     */
    sub?: CalendarSub;
    /**
     * @generated from protobuf field: bool delete = 2
     */
    delete: boolean;
}
/**
 * @generated from protobuf message services.calendar.SubscribeToCalendarResponse
 */
export interface SubscribeToCalendarResponse {
    /**
     * @generated from protobuf field: resources.calendar.CalendarSub sub = 1
     */
    sub?: CalendarSub;
}
// @generated message type with reflection information, may provide speed optimized methods
class ListCalendarsRequest$Type extends MessageType<ListCalendarsRequest> {
    constructor() {
        super("services.calendar.ListCalendarsRequest", [
            { no: 1, name: "pagination", kind: "message", T: () => PaginationRequest, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "only_public", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "min_access_level", kind: "enum", opt: true, T: () => ["resources.calendar.AccessLevel", AccessLevel, "ACCESS_LEVEL_"] },
            { no: 4, name: "after", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<ListCalendarsRequest>): ListCalendarsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.onlyPublic = false;
        if (value !== undefined)
            reflectionMergePartial<ListCalendarsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListCalendarsRequest): ListCalendarsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.common.database.PaginationRequest pagination */ 1:
                    message.pagination = PaginationRequest.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                case /* bool only_public */ 2:
                    message.onlyPublic = reader.bool();
                    break;
                case /* optional resources.calendar.AccessLevel min_access_level */ 3:
                    message.minAccessLevel = reader.int32();
                    break;
                case /* optional resources.timestamp.Timestamp after */ 4:
                    message.after = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.after);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListCalendarsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.common.database.PaginationRequest pagination = 1; */
        if (message.pagination)
            PaginationRequest.internalBinaryWrite(message.pagination, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool only_public = 2; */
        if (message.onlyPublic !== false)
            writer.tag(2, WireType.Varint).bool(message.onlyPublic);
        /* optional resources.calendar.AccessLevel min_access_level = 3; */
        if (message.minAccessLevel !== undefined)
            writer.tag(3, WireType.Varint).int32(message.minAccessLevel);
        /* optional resources.timestamp.Timestamp after = 4; */
        if (message.after)
            Timestamp.internalBinaryWrite(message.after, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.calendar.ListCalendarsRequest
 */
export const ListCalendarsRequest = new ListCalendarsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListCalendarsResponse$Type extends MessageType<ListCalendarsResponse> {
    constructor() {
        super("services.calendar.ListCalendarsResponse", [
            { no: 1, name: "pagination", kind: "message", T: () => PaginationResponse, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "calendars", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Calendar }
        ]);
    }
    create(value?: PartialMessage<ListCalendarsResponse>): ListCalendarsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.calendars = [];
        if (value !== undefined)
            reflectionMergePartial<ListCalendarsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListCalendarsResponse): ListCalendarsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.common.database.PaginationResponse pagination */ 1:
                    message.pagination = PaginationResponse.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                case /* repeated resources.calendar.Calendar calendars */ 2:
                    message.calendars.push(Calendar.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListCalendarsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.common.database.PaginationResponse pagination = 1; */
        if (message.pagination)
            PaginationResponse.internalBinaryWrite(message.pagination, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated resources.calendar.Calendar calendars = 2; */
        for (let i = 0; i < message.calendars.length; i++)
            Calendar.internalBinaryWrite(message.calendars[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.calendar.ListCalendarsResponse
 */
export const ListCalendarsResponse = new ListCalendarsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetCalendarRequest$Type extends MessageType<GetCalendarRequest> {
    constructor() {
        super("services.calendar.GetCalendarRequest", [
            { no: 1, name: "calendar_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<GetCalendarRequest>): GetCalendarRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.calendarId = 0;
        if (value !== undefined)
            reflectionMergePartial<GetCalendarRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetCalendarRequest): GetCalendarRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 calendar_id */ 1:
                    message.calendarId = reader.uint64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetCalendarRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 calendar_id = 1; */
        if (message.calendarId !== 0)
            writer.tag(1, WireType.Varint).uint64(message.calendarId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.calendar.GetCalendarRequest
 */
export const GetCalendarRequest = new GetCalendarRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetCalendarResponse$Type extends MessageType<GetCalendarResponse> {
    constructor() {
        super("services.calendar.GetCalendarResponse", [
            { no: 1, name: "calendar", kind: "message", T: () => Calendar }
        ]);
    }
    create(value?: PartialMessage<GetCalendarResponse>): GetCalendarResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetCalendarResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetCalendarResponse): GetCalendarResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.calendar.Calendar calendar */ 1:
                    message.calendar = Calendar.internalBinaryRead(reader, reader.uint32(), options, message.calendar);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetCalendarResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.calendar.Calendar calendar = 1; */
        if (message.calendar)
            Calendar.internalBinaryWrite(message.calendar, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.calendar.GetCalendarResponse
 */
export const GetCalendarResponse = new GetCalendarResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateCalendarRequest$Type extends MessageType<CreateCalendarRequest> {
    constructor() {
        super("services.calendar.CreateCalendarRequest", [
            { no: 1, name: "calendar", kind: "message", T: () => Calendar, options: { "validate.rules": { message: { required: true } } } }
        ]);
    }
    create(value?: PartialMessage<CreateCalendarRequest>): CreateCalendarRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CreateCalendarRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateCalendarRequest): CreateCalendarRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.calendar.Calendar calendar */ 1:
                    message.calendar = Calendar.internalBinaryRead(reader, reader.uint32(), options, message.calendar);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateCalendarRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.calendar.Calendar calendar = 1; */
        if (message.calendar)
            Calendar.internalBinaryWrite(message.calendar, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.calendar.CreateCalendarRequest
 */
export const CreateCalendarRequest = new CreateCalendarRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateCalendarResponse$Type extends MessageType<CreateCalendarResponse> {
    constructor() {
        super("services.calendar.CreateCalendarResponse", [
            { no: 1, name: "calendar", kind: "message", T: () => Calendar }
        ]);
    }
    create(value?: PartialMessage<CreateCalendarResponse>): CreateCalendarResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CreateCalendarResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateCalendarResponse): CreateCalendarResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.calendar.Calendar calendar */ 1:
                    message.calendar = Calendar.internalBinaryRead(reader, reader.uint32(), options, message.calendar);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateCalendarResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.calendar.Calendar calendar = 1; */
        if (message.calendar)
            Calendar.internalBinaryWrite(message.calendar, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.calendar.CreateCalendarResponse
 */
export const CreateCalendarResponse = new CreateCalendarResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateCalendarRequest$Type extends MessageType<UpdateCalendarRequest> {
    constructor() {
        super("services.calendar.UpdateCalendarRequest", [
            { no: 1, name: "calendar", kind: "message", T: () => Calendar, options: { "validate.rules": { message: { required: true } } } }
        ]);
    }
    create(value?: PartialMessage<UpdateCalendarRequest>): UpdateCalendarRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UpdateCalendarRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateCalendarRequest): UpdateCalendarRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.calendar.Calendar calendar */ 1:
                    message.calendar = Calendar.internalBinaryRead(reader, reader.uint32(), options, message.calendar);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateCalendarRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.calendar.Calendar calendar = 1; */
        if (message.calendar)
            Calendar.internalBinaryWrite(message.calendar, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.calendar.UpdateCalendarRequest
 */
export const UpdateCalendarRequest = new UpdateCalendarRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateCalendarResponse$Type extends MessageType<UpdateCalendarResponse> {
    constructor() {
        super("services.calendar.UpdateCalendarResponse", [
            { no: 1, name: "calendar", kind: "message", T: () => Calendar }
        ]);
    }
    create(value?: PartialMessage<UpdateCalendarResponse>): UpdateCalendarResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UpdateCalendarResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateCalendarResponse): UpdateCalendarResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.calendar.Calendar calendar */ 1:
                    message.calendar = Calendar.internalBinaryRead(reader, reader.uint32(), options, message.calendar);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateCalendarResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.calendar.Calendar calendar = 1; */
        if (message.calendar)
            Calendar.internalBinaryWrite(message.calendar, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.calendar.UpdateCalendarResponse
 */
export const UpdateCalendarResponse = new UpdateCalendarResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteCalendarRequest$Type extends MessageType<DeleteCalendarRequest> {
    constructor() {
        super("services.calendar.DeleteCalendarRequest", [
            { no: 1, name: "calendar_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteCalendarRequest>): DeleteCalendarRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.calendarId = 0;
        if (value !== undefined)
            reflectionMergePartial<DeleteCalendarRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteCalendarRequest): DeleteCalendarRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 calendar_id */ 1:
                    message.calendarId = reader.uint64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteCalendarRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 calendar_id = 1; */
        if (message.calendarId !== 0)
            writer.tag(1, WireType.Varint).uint64(message.calendarId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.calendar.DeleteCalendarRequest
 */
export const DeleteCalendarRequest = new DeleteCalendarRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteCalendarResponse$Type extends MessageType<DeleteCalendarResponse> {
    constructor() {
        super("services.calendar.DeleteCalendarResponse", []);
    }
    create(value?: PartialMessage<DeleteCalendarResponse>): DeleteCalendarResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DeleteCalendarResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteCalendarResponse): DeleteCalendarResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteCalendarResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.calendar.DeleteCalendarResponse
 */
export const DeleteCalendarResponse = new DeleteCalendarResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListCalendarEntriesRequest$Type extends MessageType<ListCalendarEntriesRequest> {
    constructor() {
        super("services.calendar.ListCalendarEntriesRequest", [
            { no: 1, name: "year", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "validate.rules": { int32: { gte: 2023 } } } },
            { no: 2, name: "month", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "validate.rules": { int32: { lte: 12, gte: 1 } } } },
            { no: 3, name: "calendar_ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 4, name: "show_hidden", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "after", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<ListCalendarEntriesRequest>): ListCalendarEntriesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.year = 0;
        message.month = 0;
        message.calendarIds = [];
        if (value !== undefined)
            reflectionMergePartial<ListCalendarEntriesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListCalendarEntriesRequest): ListCalendarEntriesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 year */ 1:
                    message.year = reader.int32();
                    break;
                case /* int32 month */ 2:
                    message.month = reader.int32();
                    break;
                case /* repeated uint64 calendar_ids */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.calendarIds.push(reader.uint64().toNumber());
                    else
                        message.calendarIds.push(reader.uint64().toNumber());
                    break;
                case /* optional bool show_hidden */ 4:
                    message.showHidden = reader.bool();
                    break;
                case /* optional resources.timestamp.Timestamp after */ 5:
                    message.after = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.after);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListCalendarEntriesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 year = 1; */
        if (message.year !== 0)
            writer.tag(1, WireType.Varint).int32(message.year);
        /* int32 month = 2; */
        if (message.month !== 0)
            writer.tag(2, WireType.Varint).int32(message.month);
        /* repeated uint64 calendar_ids = 3; */
        if (message.calendarIds.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.calendarIds.length; i++)
                writer.uint64(message.calendarIds[i]);
            writer.join();
        }
        /* optional bool show_hidden = 4; */
        if (message.showHidden !== undefined)
            writer.tag(4, WireType.Varint).bool(message.showHidden);
        /* optional resources.timestamp.Timestamp after = 5; */
        if (message.after)
            Timestamp.internalBinaryWrite(message.after, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.calendar.ListCalendarEntriesRequest
 */
export const ListCalendarEntriesRequest = new ListCalendarEntriesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListCalendarEntriesResponse$Type extends MessageType<ListCalendarEntriesResponse> {
    constructor() {
        super("services.calendar.ListCalendarEntriesResponse", [
            { no: 1, name: "entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CalendarEntry }
        ]);
    }
    create(value?: PartialMessage<ListCalendarEntriesResponse>): ListCalendarEntriesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.entries = [];
        if (value !== undefined)
            reflectionMergePartial<ListCalendarEntriesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListCalendarEntriesResponse): ListCalendarEntriesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated resources.calendar.CalendarEntry entries */ 1:
                    message.entries.push(CalendarEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListCalendarEntriesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated resources.calendar.CalendarEntry entries = 1; */
        for (let i = 0; i < message.entries.length; i++)
            CalendarEntry.internalBinaryWrite(message.entries[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.calendar.ListCalendarEntriesResponse
 */
export const ListCalendarEntriesResponse = new ListCalendarEntriesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetUpcomingEntriesRequest$Type extends MessageType<GetUpcomingEntriesRequest> {
    constructor() {
        super("services.calendar.GetUpcomingEntriesRequest", [
            { no: 1, name: "seconds", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetUpcomingEntriesRequest>): GetUpcomingEntriesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.seconds = 0;
        if (value !== undefined)
            reflectionMergePartial<GetUpcomingEntriesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetUpcomingEntriesRequest): GetUpcomingEntriesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 seconds */ 1:
                    message.seconds = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetUpcomingEntriesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 seconds = 1; */
        if (message.seconds !== 0)
            writer.tag(1, WireType.Varint).int32(message.seconds);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.calendar.GetUpcomingEntriesRequest
 */
export const GetUpcomingEntriesRequest = new GetUpcomingEntriesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetUpcomingEntriesResponse$Type extends MessageType<GetUpcomingEntriesResponse> {
    constructor() {
        super("services.calendar.GetUpcomingEntriesResponse", [
            { no: 1, name: "entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CalendarEntry }
        ]);
    }
    create(value?: PartialMessage<GetUpcomingEntriesResponse>): GetUpcomingEntriesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.entries = [];
        if (value !== undefined)
            reflectionMergePartial<GetUpcomingEntriesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetUpcomingEntriesResponse): GetUpcomingEntriesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated resources.calendar.CalendarEntry entries */ 1:
                    message.entries.push(CalendarEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetUpcomingEntriesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated resources.calendar.CalendarEntry entries = 1; */
        for (let i = 0; i < message.entries.length; i++)
            CalendarEntry.internalBinaryWrite(message.entries[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.calendar.GetUpcomingEntriesResponse
 */
export const GetUpcomingEntriesResponse = new GetUpcomingEntriesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetCalendarEntryRequest$Type extends MessageType<GetCalendarEntryRequest> {
    constructor() {
        super("services.calendar.GetCalendarEntryRequest", [
            { no: 1, name: "entry_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<GetCalendarEntryRequest>): GetCalendarEntryRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.entryId = 0;
        if (value !== undefined)
            reflectionMergePartial<GetCalendarEntryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetCalendarEntryRequest): GetCalendarEntryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 entry_id */ 1:
                    message.entryId = reader.uint64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetCalendarEntryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 entry_id = 1; */
        if (message.entryId !== 0)
            writer.tag(1, WireType.Varint).uint64(message.entryId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.calendar.GetCalendarEntryRequest
 */
export const GetCalendarEntryRequest = new GetCalendarEntryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetCalendarEntryResponse$Type extends MessageType<GetCalendarEntryResponse> {
    constructor() {
        super("services.calendar.GetCalendarEntryResponse", [
            { no: 1, name: "entry", kind: "message", T: () => CalendarEntry }
        ]);
    }
    create(value?: PartialMessage<GetCalendarEntryResponse>): GetCalendarEntryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetCalendarEntryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetCalendarEntryResponse): GetCalendarEntryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.calendar.CalendarEntry entry */ 1:
                    message.entry = CalendarEntry.internalBinaryRead(reader, reader.uint32(), options, message.entry);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetCalendarEntryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.calendar.CalendarEntry entry = 1; */
        if (message.entry)
            CalendarEntry.internalBinaryWrite(message.entry, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.calendar.GetCalendarEntryResponse
 */
export const GetCalendarEntryResponse = new GetCalendarEntryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateOrUpdateCalendarEntryRequest$Type extends MessageType<CreateOrUpdateCalendarEntryRequest> {
    constructor() {
        super("services.calendar.CreateOrUpdateCalendarEntryRequest", [
            { no: 1, name: "entry", kind: "message", T: () => CalendarEntry, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "user_ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CreateOrUpdateCalendarEntryRequest>): CreateOrUpdateCalendarEntryRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userIds = [];
        if (value !== undefined)
            reflectionMergePartial<CreateOrUpdateCalendarEntryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateOrUpdateCalendarEntryRequest): CreateOrUpdateCalendarEntryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.calendar.CalendarEntry entry */ 1:
                    message.entry = CalendarEntry.internalBinaryRead(reader, reader.uint32(), options, message.entry);
                    break;
                case /* repeated int32 user_ids */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.userIds.push(reader.int32());
                    else
                        message.userIds.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateOrUpdateCalendarEntryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.calendar.CalendarEntry entry = 1; */
        if (message.entry)
            CalendarEntry.internalBinaryWrite(message.entry, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated int32 user_ids = 2; */
        if (message.userIds.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.userIds.length; i++)
                writer.int32(message.userIds[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.calendar.CreateOrUpdateCalendarEntryRequest
 */
export const CreateOrUpdateCalendarEntryRequest = new CreateOrUpdateCalendarEntryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateOrUpdateCalendarEntryResponse$Type extends MessageType<CreateOrUpdateCalendarEntryResponse> {
    constructor() {
        super("services.calendar.CreateOrUpdateCalendarEntryResponse", [
            { no: 1, name: "entry", kind: "message", T: () => CalendarEntry }
        ]);
    }
    create(value?: PartialMessage<CreateOrUpdateCalendarEntryResponse>): CreateOrUpdateCalendarEntryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CreateOrUpdateCalendarEntryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateOrUpdateCalendarEntryResponse): CreateOrUpdateCalendarEntryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.calendar.CalendarEntry entry */ 1:
                    message.entry = CalendarEntry.internalBinaryRead(reader, reader.uint32(), options, message.entry);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateOrUpdateCalendarEntryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.calendar.CalendarEntry entry = 1; */
        if (message.entry)
            CalendarEntry.internalBinaryWrite(message.entry, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.calendar.CreateOrUpdateCalendarEntryResponse
 */
export const CreateOrUpdateCalendarEntryResponse = new CreateOrUpdateCalendarEntryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteCalendarEntryRequest$Type extends MessageType<DeleteCalendarEntryRequest> {
    constructor() {
        super("services.calendar.DeleteCalendarEntryRequest", [
            { no: 1, name: "entry_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteCalendarEntryRequest>): DeleteCalendarEntryRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.entryId = 0;
        if (value !== undefined)
            reflectionMergePartial<DeleteCalendarEntryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteCalendarEntryRequest): DeleteCalendarEntryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 entry_id */ 1:
                    message.entryId = reader.uint64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteCalendarEntryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 entry_id = 1; */
        if (message.entryId !== 0)
            writer.tag(1, WireType.Varint).uint64(message.entryId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.calendar.DeleteCalendarEntryRequest
 */
export const DeleteCalendarEntryRequest = new DeleteCalendarEntryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteCalendarEntryResponse$Type extends MessageType<DeleteCalendarEntryResponse> {
    constructor() {
        super("services.calendar.DeleteCalendarEntryResponse", []);
    }
    create(value?: PartialMessage<DeleteCalendarEntryResponse>): DeleteCalendarEntryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DeleteCalendarEntryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteCalendarEntryResponse): DeleteCalendarEntryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteCalendarEntryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.calendar.DeleteCalendarEntryResponse
 */
export const DeleteCalendarEntryResponse = new DeleteCalendarEntryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShareCalendarEntryRequest$Type extends MessageType<ShareCalendarEntryRequest> {
    constructor() {
        super("services.calendar.ShareCalendarEntryRequest", [
            { no: 1, name: "entry_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 2, name: "user_ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ShareCalendarEntryRequest>): ShareCalendarEntryRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.entryId = 0;
        message.userIds = [];
        if (value !== undefined)
            reflectionMergePartial<ShareCalendarEntryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShareCalendarEntryRequest): ShareCalendarEntryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 entry_id */ 1:
                    message.entryId = reader.uint64().toNumber();
                    break;
                case /* repeated int32 user_ids */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.userIds.push(reader.int32());
                    else
                        message.userIds.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShareCalendarEntryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 entry_id = 1; */
        if (message.entryId !== 0)
            writer.tag(1, WireType.Varint).uint64(message.entryId);
        /* repeated int32 user_ids = 2; */
        if (message.userIds.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.userIds.length; i++)
                writer.int32(message.userIds[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.calendar.ShareCalendarEntryRequest
 */
export const ShareCalendarEntryRequest = new ShareCalendarEntryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShareCalendarEntryResponse$Type extends MessageType<ShareCalendarEntryResponse> {
    constructor() {
        super("services.calendar.ShareCalendarEntryResponse", []);
    }
    create(value?: PartialMessage<ShareCalendarEntryResponse>): ShareCalendarEntryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ShareCalendarEntryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShareCalendarEntryResponse): ShareCalendarEntryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShareCalendarEntryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.calendar.ShareCalendarEntryResponse
 */
export const ShareCalendarEntryResponse = new ShareCalendarEntryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListCalendarEntryRSVPRequest$Type extends MessageType<ListCalendarEntryRSVPRequest> {
    constructor() {
        super("services.calendar.ListCalendarEntryRSVPRequest", [
            { no: 1, name: "pagination", kind: "message", T: () => PaginationRequest, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "entry_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<ListCalendarEntryRSVPRequest>): ListCalendarEntryRSVPRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.entryId = 0;
        if (value !== undefined)
            reflectionMergePartial<ListCalendarEntryRSVPRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListCalendarEntryRSVPRequest): ListCalendarEntryRSVPRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.common.database.PaginationRequest pagination */ 1:
                    message.pagination = PaginationRequest.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                case /* uint64 entry_id */ 2:
                    message.entryId = reader.uint64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListCalendarEntryRSVPRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.common.database.PaginationRequest pagination = 1; */
        if (message.pagination)
            PaginationRequest.internalBinaryWrite(message.pagination, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint64 entry_id = 2; */
        if (message.entryId !== 0)
            writer.tag(2, WireType.Varint).uint64(message.entryId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.calendar.ListCalendarEntryRSVPRequest
 */
export const ListCalendarEntryRSVPRequest = new ListCalendarEntryRSVPRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListCalendarEntryRSVPResponse$Type extends MessageType<ListCalendarEntryRSVPResponse> {
    constructor() {
        super("services.calendar.ListCalendarEntryRSVPResponse", [
            { no: 1, name: "pagination", kind: "message", T: () => PaginationResponse, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CalendarEntryRSVP }
        ]);
    }
    create(value?: PartialMessage<ListCalendarEntryRSVPResponse>): ListCalendarEntryRSVPResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.entries = [];
        if (value !== undefined)
            reflectionMergePartial<ListCalendarEntryRSVPResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListCalendarEntryRSVPResponse): ListCalendarEntryRSVPResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.common.database.PaginationResponse pagination */ 1:
                    message.pagination = PaginationResponse.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                case /* repeated resources.calendar.CalendarEntryRSVP entries */ 2:
                    message.entries.push(CalendarEntryRSVP.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListCalendarEntryRSVPResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.common.database.PaginationResponse pagination = 1; */
        if (message.pagination)
            PaginationResponse.internalBinaryWrite(message.pagination, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated resources.calendar.CalendarEntryRSVP entries = 2; */
        for (let i = 0; i < message.entries.length; i++)
            CalendarEntryRSVP.internalBinaryWrite(message.entries[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.calendar.ListCalendarEntryRSVPResponse
 */
export const ListCalendarEntryRSVPResponse = new ListCalendarEntryRSVPResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RSVPCalendarEntryRequest$Type extends MessageType<RSVPCalendarEntryRequest> {
    constructor() {
        super("services.calendar.RSVPCalendarEntryRequest", [
            { no: 1, name: "entry", kind: "message", T: () => CalendarEntryRSVP },
            { no: 2, name: "subscribe", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "remove", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<RSVPCalendarEntryRequest>): RSVPCalendarEntryRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subscribe = false;
        if (value !== undefined)
            reflectionMergePartial<RSVPCalendarEntryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RSVPCalendarEntryRequest): RSVPCalendarEntryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.calendar.CalendarEntryRSVP entry */ 1:
                    message.entry = CalendarEntryRSVP.internalBinaryRead(reader, reader.uint32(), options, message.entry);
                    break;
                case /* bool subscribe */ 2:
                    message.subscribe = reader.bool();
                    break;
                case /* optional bool remove */ 3:
                    message.remove = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RSVPCalendarEntryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.calendar.CalendarEntryRSVP entry = 1; */
        if (message.entry)
            CalendarEntryRSVP.internalBinaryWrite(message.entry, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool subscribe = 2; */
        if (message.subscribe !== false)
            writer.tag(2, WireType.Varint).bool(message.subscribe);
        /* optional bool remove = 3; */
        if (message.remove !== undefined)
            writer.tag(3, WireType.Varint).bool(message.remove);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.calendar.RSVPCalendarEntryRequest
 */
export const RSVPCalendarEntryRequest = new RSVPCalendarEntryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RSVPCalendarEntryResponse$Type extends MessageType<RSVPCalendarEntryResponse> {
    constructor() {
        super("services.calendar.RSVPCalendarEntryResponse", [
            { no: 1, name: "entry", kind: "message", T: () => CalendarEntryRSVP }
        ]);
    }
    create(value?: PartialMessage<RSVPCalendarEntryResponse>): RSVPCalendarEntryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RSVPCalendarEntryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RSVPCalendarEntryResponse): RSVPCalendarEntryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional resources.calendar.CalendarEntryRSVP entry */ 1:
                    message.entry = CalendarEntryRSVP.internalBinaryRead(reader, reader.uint32(), options, message.entry);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RSVPCalendarEntryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional resources.calendar.CalendarEntryRSVP entry = 1; */
        if (message.entry)
            CalendarEntryRSVP.internalBinaryWrite(message.entry, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.calendar.RSVPCalendarEntryResponse
 */
export const RSVPCalendarEntryResponse = new RSVPCalendarEntryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListSubscriptionsRequest$Type extends MessageType<ListSubscriptionsRequest> {
    constructor() {
        super("services.calendar.ListSubscriptionsRequest", [
            { no: 1, name: "pagination", kind: "message", T: () => PaginationRequest, options: { "validate.rules": { message: { required: true } } } }
        ]);
    }
    create(value?: PartialMessage<ListSubscriptionsRequest>): ListSubscriptionsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ListSubscriptionsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListSubscriptionsRequest): ListSubscriptionsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.common.database.PaginationRequest pagination */ 1:
                    message.pagination = PaginationRequest.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListSubscriptionsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.common.database.PaginationRequest pagination = 1; */
        if (message.pagination)
            PaginationRequest.internalBinaryWrite(message.pagination, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.calendar.ListSubscriptionsRequest
 */
export const ListSubscriptionsRequest = new ListSubscriptionsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListSubscriptionsResponse$Type extends MessageType<ListSubscriptionsResponse> {
    constructor() {
        super("services.calendar.ListSubscriptionsResponse", [
            { no: 1, name: "pagination", kind: "message", T: () => PaginationResponse, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "subs", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CalendarSub }
        ]);
    }
    create(value?: PartialMessage<ListSubscriptionsResponse>): ListSubscriptionsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subs = [];
        if (value !== undefined)
            reflectionMergePartial<ListSubscriptionsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListSubscriptionsResponse): ListSubscriptionsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.common.database.PaginationResponse pagination */ 1:
                    message.pagination = PaginationResponse.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                case /* repeated resources.calendar.CalendarSub subs */ 2:
                    message.subs.push(CalendarSub.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListSubscriptionsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.common.database.PaginationResponse pagination = 1; */
        if (message.pagination)
            PaginationResponse.internalBinaryWrite(message.pagination, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated resources.calendar.CalendarSub subs = 2; */
        for (let i = 0; i < message.subs.length; i++)
            CalendarSub.internalBinaryWrite(message.subs[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.calendar.ListSubscriptionsResponse
 */
export const ListSubscriptionsResponse = new ListSubscriptionsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeToCalendarRequest$Type extends MessageType<SubscribeToCalendarRequest> {
    constructor() {
        super("services.calendar.SubscribeToCalendarRequest", [
            { no: 1, name: "sub", kind: "message", T: () => CalendarSub },
            { no: 2, name: "delete", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SubscribeToCalendarRequest>): SubscribeToCalendarRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.delete = false;
        if (value !== undefined)
            reflectionMergePartial<SubscribeToCalendarRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeToCalendarRequest): SubscribeToCalendarRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.calendar.CalendarSub sub */ 1:
                    message.sub = CalendarSub.internalBinaryRead(reader, reader.uint32(), options, message.sub);
                    break;
                case /* bool delete */ 2:
                    message.delete = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeToCalendarRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.calendar.CalendarSub sub = 1; */
        if (message.sub)
            CalendarSub.internalBinaryWrite(message.sub, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool delete = 2; */
        if (message.delete !== false)
            writer.tag(2, WireType.Varint).bool(message.delete);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.calendar.SubscribeToCalendarRequest
 */
export const SubscribeToCalendarRequest = new SubscribeToCalendarRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeToCalendarResponse$Type extends MessageType<SubscribeToCalendarResponse> {
    constructor() {
        super("services.calendar.SubscribeToCalendarResponse", [
            { no: 1, name: "sub", kind: "message", T: () => CalendarSub }
        ]);
    }
    create(value?: PartialMessage<SubscribeToCalendarResponse>): SubscribeToCalendarResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeToCalendarResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeToCalendarResponse): SubscribeToCalendarResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.calendar.CalendarSub sub */ 1:
                    message.sub = CalendarSub.internalBinaryRead(reader, reader.uint32(), options, message.sub);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeToCalendarResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.calendar.CalendarSub sub = 1; */
        if (message.sub)
            CalendarSub.internalBinaryWrite(message.sub, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.calendar.SubscribeToCalendarResponse
 */
export const SubscribeToCalendarResponse = new SubscribeToCalendarResponse$Type();
/**
 * @generated ServiceType for protobuf service services.calendar.CalendarService
 */
export const CalendarService = new ServiceType("services.calendar.CalendarService", [
    { name: "ListCalendars", options: {}, I: ListCalendarsRequest, O: ListCalendarsResponse },
    { name: "GetCalendar", options: {}, I: GetCalendarRequest, O: GetCalendarResponse },
    { name: "CreateCalendar", options: {}, I: CreateCalendarRequest, O: CreateCalendarResponse },
    { name: "UpdateCalendar", options: {}, I: UpdateCalendarRequest, O: UpdateCalendarResponse },
    { name: "DeleteCalendar", options: {}, I: DeleteCalendarRequest, O: DeleteCalendarResponse },
    { name: "ListCalendarEntries", options: {}, I: ListCalendarEntriesRequest, O: ListCalendarEntriesResponse },
    { name: "GetUpcomingEntries", options: {}, I: GetUpcomingEntriesRequest, O: GetUpcomingEntriesResponse },
    { name: "GetCalendarEntry", options: {}, I: GetCalendarEntryRequest, O: GetCalendarEntryResponse },
    { name: "CreateOrUpdateCalendarEntry", options: {}, I: CreateOrUpdateCalendarEntryRequest, O: CreateOrUpdateCalendarEntryResponse },
    { name: "DeleteCalendarEntry", options: {}, I: DeleteCalendarEntryRequest, O: DeleteCalendarEntryResponse },
    { name: "ShareCalendarEntry", options: {}, I: ShareCalendarEntryRequest, O: ShareCalendarEntryResponse },
    { name: "ListCalendarEntryRSVP", options: {}, I: ListCalendarEntryRSVPRequest, O: ListCalendarEntryRSVPResponse },
    { name: "RSVPCalendarEntry", options: {}, I: RSVPCalendarEntryRequest, O: RSVPCalendarEntryResponse },
    { name: "ListSubscriptions", options: {}, I: ListSubscriptionsRequest, O: ListSubscriptionsResponse },
    { name: "SubscribeToCalendar", options: {}, I: SubscribeToCalendarRequest, O: SubscribeToCalendarResponse }
]);
