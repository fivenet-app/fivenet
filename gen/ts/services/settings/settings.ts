// @generated by protobuf-ts 2.11.1 with parameter force_server_none,long_type_number,optimize_speed,ts_nocheck
// @generated from protobuf file "services/settings/settings.proto" (package "services.settings", syntax proto3)
// tslint:disable
// @ts-nocheck
import { UploadFileResponse } from "../../resources/file/filestore";
import { UploadFileRequest } from "../../resources/file/filestore";
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Guild } from "../../resources/discord/discord";
import { Channel } from "../../resources/discord/discord";
import { AuditEntry } from "../../resources/audit/audit";
import { PaginationResponse } from "../../resources/common/database/database";
import { EventType } from "../../resources/audit/audit";
import { Timestamp } from "../../resources/timestamp/timestamp";
import { Sort } from "../../resources/common/database/database";
import { PaginationRequest } from "../../resources/common/database/database";
import { RoleAttribute } from "../../resources/permissions/attributes";
import { Permission } from "../../resources/permissions/permissions";
import { AttrsUpdate } from "../../resources/settings/perms";
import { PermsUpdate } from "../../resources/settings/perms";
import { Role } from "../../resources/permissions/permissions";
import { JobProps } from "../../resources/jobs/job_props";
/**
 * @generated from protobuf message services.settings.GetJobPropsRequest
 */
export interface GetJobPropsRequest {
}
/**
 * @generated from protobuf message services.settings.GetJobPropsResponse
 */
export interface GetJobPropsResponse {
    /**
     * @generated from protobuf field: resources.jobs.JobProps job_props = 1
     */
    jobProps?: JobProps;
}
/**
 * @generated from protobuf message services.settings.SetJobPropsRequest
 */
export interface SetJobPropsRequest {
    /**
     * @generated from protobuf field: resources.jobs.JobProps job_props = 1
     */
    jobProps?: JobProps;
}
/**
 * @generated from protobuf message services.settings.SetJobPropsResponse
 */
export interface SetJobPropsResponse {
    /**
     * @generated from protobuf field: resources.jobs.JobProps job_props = 1
     */
    jobProps?: JobProps;
}
/**
 * @generated from protobuf message services.settings.GetRolesRequest
 */
export interface GetRolesRequest {
    /**
     * @generated from protobuf field: optional bool lowest_rank = 1
     */
    lowestRank?: boolean;
}
/**
 * @generated from protobuf message services.settings.GetRolesResponse
 */
export interface GetRolesResponse {
    /**
     * @generated from protobuf field: repeated resources.permissions.Role roles = 1
     */
    roles: Role[];
}
/**
 * @generated from protobuf message services.settings.GetRoleRequest
 */
export interface GetRoleRequest {
    /**
     * @generated from protobuf field: int64 id = 1
     */
    id: number;
}
/**
 * @generated from protobuf message services.settings.GetRoleResponse
 */
export interface GetRoleResponse {
    /**
     * @generated from protobuf field: resources.permissions.Role role = 1
     */
    role?: Role;
}
/**
 * @generated from protobuf message services.settings.CreateRoleRequest
 */
export interface CreateRoleRequest {
    /**
     * @generated from protobuf field: string job = 1
     */
    job: string;
    /**
     * @generated from protobuf field: int32 grade = 2
     */
    grade: number;
}
/**
 * @generated from protobuf message services.settings.CreateRoleResponse
 */
export interface CreateRoleResponse {
    /**
     * @generated from protobuf field: resources.permissions.Role role = 1
     */
    role?: Role;
}
/**
 * @generated from protobuf message services.settings.DeleteRoleRequest
 */
export interface DeleteRoleRequest {
    /**
     * @generated from protobuf field: int64 id = 1
     */
    id: number;
}
/**
 * @generated from protobuf message services.settings.DeleteRoleResponse
 */
export interface DeleteRoleResponse {
}
/**
 * @generated from protobuf message services.settings.UpdateRolePermsRequest
 */
export interface UpdateRolePermsRequest {
    /**
     * @generated from protobuf field: int64 id = 1
     */
    id: number;
    /**
     * @generated from protobuf field: optional resources.settings.PermsUpdate perms = 2
     */
    perms?: PermsUpdate;
    /**
     * @generated from protobuf field: optional resources.settings.AttrsUpdate attrs = 3
     */
    attrs?: AttrsUpdate;
}
/**
 * @generated from protobuf message services.settings.UpdateRolePermsResponse
 */
export interface UpdateRolePermsResponse {
}
/**
 * @generated from protobuf message services.settings.GetPermissionsRequest
 */
export interface GetPermissionsRequest {
    /**
     * @generated from protobuf field: int64 role_id = 1
     */
    roleId: number;
}
/**
 * @generated from protobuf message services.settings.GetPermissionsResponse
 */
export interface GetPermissionsResponse {
    /**
     * @generated from protobuf field: repeated resources.permissions.Permission permissions = 1
     */
    permissions: Permission[];
    /**
     * @generated from protobuf field: repeated resources.permissions.RoleAttribute attributes = 2
     */
    attributes: RoleAttribute[];
}
/**
 * @generated from protobuf message services.settings.GetEffectivePermissionsRequest
 */
export interface GetEffectivePermissionsRequest {
    /**
     * @generated from protobuf field: int64 role_id = 1
     */
    roleId: number;
}
/**
 * @generated from protobuf message services.settings.GetEffectivePermissionsResponse
 */
export interface GetEffectivePermissionsResponse {
    /**
     * @generated from protobuf field: resources.permissions.Role role = 1
     */
    role?: Role;
    /**
     * @generated from protobuf field: repeated resources.permissions.Permission permissions = 2
     */
    permissions: Permission[];
    /**
     * @generated from protobuf field: repeated resources.permissions.RoleAttribute attributes = 3
     */
    attributes: RoleAttribute[];
}
/**
 * @generated from protobuf message services.settings.ViewAuditLogRequest
 */
export interface ViewAuditLogRequest {
    /**
     * @generated from protobuf field: resources.common.database.PaginationRequest pagination = 1
     */
    pagination?: PaginationRequest;
    /**
     * @generated from protobuf field: optional resources.common.database.Sort sort = 2
     */
    sort?: Sort;
    /**
     * Search params
     *
     * @generated from protobuf field: repeated int32 user_ids = 3
     */
    userIds: number[];
    /**
     * @generated from protobuf field: optional resources.timestamp.Timestamp from = 4
     */
    from?: Timestamp;
    /**
     * @generated from protobuf field: optional resources.timestamp.Timestamp to = 5
     */
    to?: Timestamp;
    /**
     * @generated from protobuf field: repeated string services = 6
     */
    services: string[];
    /**
     * @generated from protobuf field: repeated string methods = 7
     */
    methods: string[];
    /**
     * @generated from protobuf field: optional string search = 8
     */
    search?: string;
    /**
     * @generated from protobuf field: repeated resources.audit.EventType states = 9
     */
    states: EventType[];
}
/**
 * @generated from protobuf message services.settings.ViewAuditLogResponse
 */
export interface ViewAuditLogResponse {
    /**
     * @generated from protobuf field: resources.common.database.PaginationResponse pagination = 1
     */
    pagination?: PaginationResponse;
    /**
     * @generated from protobuf field: repeated resources.audit.AuditEntry logs = 2
     */
    logs: AuditEntry[];
}
/**
 * @generated from protobuf message services.settings.ListDiscordChannelsRequest
 */
export interface ListDiscordChannelsRequest {
}
/**
 * @generated from protobuf message services.settings.ListDiscordChannelsResponse
 */
export interface ListDiscordChannelsResponse {
    /**
     * @generated from protobuf field: repeated resources.discord.Channel channels = 1
     */
    channels: Channel[];
}
/**
 * @generated from protobuf message services.settings.ListUserGuildsRequest
 */
export interface ListUserGuildsRequest {
}
/**
 * @generated from protobuf message services.settings.ListUserGuildsResponse
 */
export interface ListUserGuildsResponse {
    /**
     * @generated from protobuf field: repeated resources.discord.Guild guilds = 1
     */
    guilds: Guild[];
}
/**
 * @generated from protobuf message services.settings.DeleteJobLogoRequest
 */
export interface DeleteJobLogoRequest {
}
/**
 * @generated from protobuf message services.settings.DeleteJobLogoResponse
 */
export interface DeleteJobLogoResponse {
}
// @generated message type with reflection information, may provide speed optimized methods
class GetJobPropsRequest$Type extends MessageType<GetJobPropsRequest> {
    constructor() {
        super("services.settings.GetJobPropsRequest", []);
    }
    create(value?: PartialMessage<GetJobPropsRequest>): GetJobPropsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetJobPropsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetJobPropsRequest): GetJobPropsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetJobPropsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.settings.GetJobPropsRequest
 */
export const GetJobPropsRequest = new GetJobPropsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetJobPropsResponse$Type extends MessageType<GetJobPropsResponse> {
    constructor() {
        super("services.settings.GetJobPropsResponse", [
            { no: 1, name: "job_props", kind: "message", T: () => JobProps }
        ]);
    }
    create(value?: PartialMessage<GetJobPropsResponse>): GetJobPropsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetJobPropsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetJobPropsResponse): GetJobPropsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.jobs.JobProps job_props */ 1:
                    message.jobProps = JobProps.internalBinaryRead(reader, reader.uint32(), options, message.jobProps);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetJobPropsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.jobs.JobProps job_props = 1; */
        if (message.jobProps)
            JobProps.internalBinaryWrite(message.jobProps, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.settings.GetJobPropsResponse
 */
export const GetJobPropsResponse = new GetJobPropsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetJobPropsRequest$Type extends MessageType<SetJobPropsRequest> {
    constructor() {
        super("services.settings.SetJobPropsRequest", [
            { no: 1, name: "job_props", kind: "message", T: () => JobProps }
        ]);
    }
    create(value?: PartialMessage<SetJobPropsRequest>): SetJobPropsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetJobPropsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetJobPropsRequest): SetJobPropsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.jobs.JobProps job_props */ 1:
                    message.jobProps = JobProps.internalBinaryRead(reader, reader.uint32(), options, message.jobProps);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetJobPropsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.jobs.JobProps job_props = 1; */
        if (message.jobProps)
            JobProps.internalBinaryWrite(message.jobProps, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.settings.SetJobPropsRequest
 */
export const SetJobPropsRequest = new SetJobPropsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetJobPropsResponse$Type extends MessageType<SetJobPropsResponse> {
    constructor() {
        super("services.settings.SetJobPropsResponse", [
            { no: 1, name: "job_props", kind: "message", T: () => JobProps }
        ]);
    }
    create(value?: PartialMessage<SetJobPropsResponse>): SetJobPropsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetJobPropsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetJobPropsResponse): SetJobPropsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.jobs.JobProps job_props */ 1:
                    message.jobProps = JobProps.internalBinaryRead(reader, reader.uint32(), options, message.jobProps);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetJobPropsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.jobs.JobProps job_props = 1; */
        if (message.jobProps)
            JobProps.internalBinaryWrite(message.jobProps, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.settings.SetJobPropsResponse
 */
export const SetJobPropsResponse = new SetJobPropsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetRolesRequest$Type extends MessageType<GetRolesRequest> {
    constructor() {
        super("services.settings.GetRolesRequest", [
            { no: 1, name: "lowest_rank", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<GetRolesRequest>): GetRolesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetRolesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetRolesRequest): GetRolesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool lowest_rank */ 1:
                    message.lowestRank = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetRolesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool lowest_rank = 1; */
        if (message.lowestRank !== undefined)
            writer.tag(1, WireType.Varint).bool(message.lowestRank);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.settings.GetRolesRequest
 */
export const GetRolesRequest = new GetRolesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetRolesResponse$Type extends MessageType<GetRolesResponse> {
    constructor() {
        super("services.settings.GetRolesResponse", [
            { no: 1, name: "roles", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Role }
        ]);
    }
    create(value?: PartialMessage<GetRolesResponse>): GetRolesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.roles = [];
        if (value !== undefined)
            reflectionMergePartial<GetRolesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetRolesResponse): GetRolesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated resources.permissions.Role roles */ 1:
                    message.roles.push(Role.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetRolesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated resources.permissions.Role roles = 1; */
        for (let i = 0; i < message.roles.length; i++)
            Role.internalBinaryWrite(message.roles[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.settings.GetRolesResponse
 */
export const GetRolesResponse = new GetRolesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetRoleRequest$Type extends MessageType<GetRoleRequest> {
    constructor() {
        super("services.settings.GetRoleRequest", [
            { no: 1, name: "id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<GetRoleRequest>): GetRoleRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        if (value !== undefined)
            reflectionMergePartial<GetRoleRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetRoleRequest): GetRoleRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 id */ 1:
                    message.id = reader.int64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetRoleRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int64(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.settings.GetRoleRequest
 */
export const GetRoleRequest = new GetRoleRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetRoleResponse$Type extends MessageType<GetRoleResponse> {
    constructor() {
        super("services.settings.GetRoleResponse", [
            { no: 1, name: "role", kind: "message", T: () => Role }
        ]);
    }
    create(value?: PartialMessage<GetRoleResponse>): GetRoleResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetRoleResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetRoleResponse): GetRoleResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.permissions.Role role */ 1:
                    message.role = Role.internalBinaryRead(reader, reader.uint32(), options, message.role);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetRoleResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.permissions.Role role = 1; */
        if (message.role)
            Role.internalBinaryWrite(message.role, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.settings.GetRoleResponse
 */
export const GetRoleResponse = new GetRoleResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateRoleRequest$Type extends MessageType<CreateRoleRequest> {
    constructor() {
        super("services.settings.CreateRoleRequest", [
            { no: 1, name: "job", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { string: { maxLen: "20" } } } },
            { no: 2, name: "grade", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "buf.validate.field": { int32: { gte: 0 } } } }
        ]);
    }
    create(value?: PartialMessage<CreateRoleRequest>): CreateRoleRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.job = "";
        message.grade = 0;
        if (value !== undefined)
            reflectionMergePartial<CreateRoleRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateRoleRequest): CreateRoleRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string job */ 1:
                    message.job = reader.string();
                    break;
                case /* int32 grade */ 2:
                    message.grade = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateRoleRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string job = 1; */
        if (message.job !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.job);
        /* int32 grade = 2; */
        if (message.grade !== 0)
            writer.tag(2, WireType.Varint).int32(message.grade);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.settings.CreateRoleRequest
 */
export const CreateRoleRequest = new CreateRoleRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateRoleResponse$Type extends MessageType<CreateRoleResponse> {
    constructor() {
        super("services.settings.CreateRoleResponse", [
            { no: 1, name: "role", kind: "message", T: () => Role }
        ]);
    }
    create(value?: PartialMessage<CreateRoleResponse>): CreateRoleResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CreateRoleResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateRoleResponse): CreateRoleResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.permissions.Role role */ 1:
                    message.role = Role.internalBinaryRead(reader, reader.uint32(), options, message.role);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateRoleResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.permissions.Role role = 1; */
        if (message.role)
            Role.internalBinaryWrite(message.role, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.settings.CreateRoleResponse
 */
export const CreateRoleResponse = new CreateRoleResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteRoleRequest$Type extends MessageType<DeleteRoleRequest> {
    constructor() {
        super("services.settings.DeleteRoleRequest", [
            { no: 1, name: "id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteRoleRequest>): DeleteRoleRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        if (value !== undefined)
            reflectionMergePartial<DeleteRoleRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteRoleRequest): DeleteRoleRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 id */ 1:
                    message.id = reader.int64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteRoleRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int64(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.settings.DeleteRoleRequest
 */
export const DeleteRoleRequest = new DeleteRoleRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteRoleResponse$Type extends MessageType<DeleteRoleResponse> {
    constructor() {
        super("services.settings.DeleteRoleResponse", []);
    }
    create(value?: PartialMessage<DeleteRoleResponse>): DeleteRoleResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DeleteRoleResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteRoleResponse): DeleteRoleResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteRoleResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.settings.DeleteRoleResponse
 */
export const DeleteRoleResponse = new DeleteRoleResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateRolePermsRequest$Type extends MessageType<UpdateRolePermsRequest> {
    constructor() {
        super("services.settings.UpdateRolePermsRequest", [
            { no: 1, name: "id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 2, name: "perms", kind: "message", T: () => PermsUpdate },
            { no: 3, name: "attrs", kind: "message", T: () => AttrsUpdate }
        ]);
    }
    create(value?: PartialMessage<UpdateRolePermsRequest>): UpdateRolePermsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        if (value !== undefined)
            reflectionMergePartial<UpdateRolePermsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateRolePermsRequest): UpdateRolePermsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 id */ 1:
                    message.id = reader.int64().toNumber();
                    break;
                case /* optional resources.settings.PermsUpdate perms */ 2:
                    message.perms = PermsUpdate.internalBinaryRead(reader, reader.uint32(), options, message.perms);
                    break;
                case /* optional resources.settings.AttrsUpdate attrs */ 3:
                    message.attrs = AttrsUpdate.internalBinaryRead(reader, reader.uint32(), options, message.attrs);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateRolePermsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int64(message.id);
        /* optional resources.settings.PermsUpdate perms = 2; */
        if (message.perms)
            PermsUpdate.internalBinaryWrite(message.perms, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional resources.settings.AttrsUpdate attrs = 3; */
        if (message.attrs)
            AttrsUpdate.internalBinaryWrite(message.attrs, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.settings.UpdateRolePermsRequest
 */
export const UpdateRolePermsRequest = new UpdateRolePermsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateRolePermsResponse$Type extends MessageType<UpdateRolePermsResponse> {
    constructor() {
        super("services.settings.UpdateRolePermsResponse", []);
    }
    create(value?: PartialMessage<UpdateRolePermsResponse>): UpdateRolePermsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UpdateRolePermsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateRolePermsResponse): UpdateRolePermsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateRolePermsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.settings.UpdateRolePermsResponse
 */
export const UpdateRolePermsResponse = new UpdateRolePermsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPermissionsRequest$Type extends MessageType<GetPermissionsRequest> {
    constructor() {
        super("services.settings.GetPermissionsRequest", [
            { no: 1, name: "role_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<GetPermissionsRequest>): GetPermissionsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.roleId = 0;
        if (value !== undefined)
            reflectionMergePartial<GetPermissionsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPermissionsRequest): GetPermissionsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 role_id */ 1:
                    message.roleId = reader.int64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPermissionsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 role_id = 1; */
        if (message.roleId !== 0)
            writer.tag(1, WireType.Varint).int64(message.roleId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.settings.GetPermissionsRequest
 */
export const GetPermissionsRequest = new GetPermissionsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPermissionsResponse$Type extends MessageType<GetPermissionsResponse> {
    constructor() {
        super("services.settings.GetPermissionsResponse", [
            { no: 1, name: "permissions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Permission },
            { no: 2, name: "attributes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => RoleAttribute }
        ]);
    }
    create(value?: PartialMessage<GetPermissionsResponse>): GetPermissionsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.permissions = [];
        message.attributes = [];
        if (value !== undefined)
            reflectionMergePartial<GetPermissionsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPermissionsResponse): GetPermissionsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated resources.permissions.Permission permissions */ 1:
                    message.permissions.push(Permission.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated resources.permissions.RoleAttribute attributes */ 2:
                    message.attributes.push(RoleAttribute.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPermissionsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated resources.permissions.Permission permissions = 1; */
        for (let i = 0; i < message.permissions.length; i++)
            Permission.internalBinaryWrite(message.permissions[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated resources.permissions.RoleAttribute attributes = 2; */
        for (let i = 0; i < message.attributes.length; i++)
            RoleAttribute.internalBinaryWrite(message.attributes[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.settings.GetPermissionsResponse
 */
export const GetPermissionsResponse = new GetPermissionsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetEffectivePermissionsRequest$Type extends MessageType<GetEffectivePermissionsRequest> {
    constructor() {
        super("services.settings.GetEffectivePermissionsRequest", [
            { no: 1, name: "role_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<GetEffectivePermissionsRequest>): GetEffectivePermissionsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.roleId = 0;
        if (value !== undefined)
            reflectionMergePartial<GetEffectivePermissionsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetEffectivePermissionsRequest): GetEffectivePermissionsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 role_id */ 1:
                    message.roleId = reader.int64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetEffectivePermissionsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 role_id = 1; */
        if (message.roleId !== 0)
            writer.tag(1, WireType.Varint).int64(message.roleId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.settings.GetEffectivePermissionsRequest
 */
export const GetEffectivePermissionsRequest = new GetEffectivePermissionsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetEffectivePermissionsResponse$Type extends MessageType<GetEffectivePermissionsResponse> {
    constructor() {
        super("services.settings.GetEffectivePermissionsResponse", [
            { no: 1, name: "role", kind: "message", T: () => Role },
            { no: 2, name: "permissions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Permission },
            { no: 3, name: "attributes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => RoleAttribute }
        ]);
    }
    create(value?: PartialMessage<GetEffectivePermissionsResponse>): GetEffectivePermissionsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.permissions = [];
        message.attributes = [];
        if (value !== undefined)
            reflectionMergePartial<GetEffectivePermissionsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetEffectivePermissionsResponse): GetEffectivePermissionsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.permissions.Role role */ 1:
                    message.role = Role.internalBinaryRead(reader, reader.uint32(), options, message.role);
                    break;
                case /* repeated resources.permissions.Permission permissions */ 2:
                    message.permissions.push(Permission.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated resources.permissions.RoleAttribute attributes */ 3:
                    message.attributes.push(RoleAttribute.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetEffectivePermissionsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.permissions.Role role = 1; */
        if (message.role)
            Role.internalBinaryWrite(message.role, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated resources.permissions.Permission permissions = 2; */
        for (let i = 0; i < message.permissions.length; i++)
            Permission.internalBinaryWrite(message.permissions[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated resources.permissions.RoleAttribute attributes = 3; */
        for (let i = 0; i < message.attributes.length; i++)
            RoleAttribute.internalBinaryWrite(message.attributes[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.settings.GetEffectivePermissionsResponse
 */
export const GetEffectivePermissionsResponse = new GetEffectivePermissionsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ViewAuditLogRequest$Type extends MessageType<ViewAuditLogRequest> {
    constructor() {
        super("services.settings.ViewAuditLogRequest", [
            { no: 1, name: "pagination", kind: "message", T: () => PaginationRequest, options: { "buf.validate.field": { required: true } } },
            { no: 2, name: "sort", kind: "message", T: () => Sort },
            { no: 3, name: "user_ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "from", kind: "message", T: () => Timestamp },
            { no: 5, name: "to", kind: "message", T: () => Timestamp },
            { no: 6, name: "services", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { repeated: { maxItems: "10", items: { string: { maxLen: "64" } } } }, "codegen.sanitizer.sanitizer": { enabled: true, method: "StripTags" } } },
            { no: 7, name: "methods", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { repeated: { maxItems: "10", items: { string: { maxLen: "64" } } } }, "codegen.sanitizer.sanitizer": { enabled: true, method: "StripTags" } } },
            { no: 8, name: "search", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { string: { maxLen: "64" } } } },
            { no: 9, name: "states", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["resources.audit.EventType", EventType, "EVENT_TYPE_"], options: { "buf.validate.field": { repeated: { maxItems: "10", items: { enum: { definedOnly: true } } } } } }
        ]);
    }
    create(value?: PartialMessage<ViewAuditLogRequest>): ViewAuditLogRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userIds = [];
        message.services = [];
        message.methods = [];
        message.states = [];
        if (value !== undefined)
            reflectionMergePartial<ViewAuditLogRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ViewAuditLogRequest): ViewAuditLogRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.common.database.PaginationRequest pagination */ 1:
                    message.pagination = PaginationRequest.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                case /* optional resources.common.database.Sort sort */ 2:
                    message.sort = Sort.internalBinaryRead(reader, reader.uint32(), options, message.sort);
                    break;
                case /* repeated int32 user_ids */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.userIds.push(reader.int32());
                    else
                        message.userIds.push(reader.int32());
                    break;
                case /* optional resources.timestamp.Timestamp from */ 4:
                    message.from = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.from);
                    break;
                case /* optional resources.timestamp.Timestamp to */ 5:
                    message.to = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.to);
                    break;
                case /* repeated string services */ 6:
                    message.services.push(reader.string());
                    break;
                case /* repeated string methods */ 7:
                    message.methods.push(reader.string());
                    break;
                case /* optional string search */ 8:
                    message.search = reader.string();
                    break;
                case /* repeated resources.audit.EventType states */ 9:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.states.push(reader.int32());
                    else
                        message.states.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ViewAuditLogRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.common.database.PaginationRequest pagination = 1; */
        if (message.pagination)
            PaginationRequest.internalBinaryWrite(message.pagination, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional resources.common.database.Sort sort = 2; */
        if (message.sort)
            Sort.internalBinaryWrite(message.sort, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated int32 user_ids = 3; */
        if (message.userIds.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.userIds.length; i++)
                writer.int32(message.userIds[i]);
            writer.join();
        }
        /* optional resources.timestamp.Timestamp from = 4; */
        if (message.from)
            Timestamp.internalBinaryWrite(message.from, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional resources.timestamp.Timestamp to = 5; */
        if (message.to)
            Timestamp.internalBinaryWrite(message.to, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated string services = 6; */
        for (let i = 0; i < message.services.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.services[i]);
        /* repeated string methods = 7; */
        for (let i = 0; i < message.methods.length; i++)
            writer.tag(7, WireType.LengthDelimited).string(message.methods[i]);
        /* optional string search = 8; */
        if (message.search !== undefined)
            writer.tag(8, WireType.LengthDelimited).string(message.search);
        /* repeated resources.audit.EventType states = 9; */
        if (message.states.length) {
            writer.tag(9, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.states.length; i++)
                writer.int32(message.states[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.settings.ViewAuditLogRequest
 */
export const ViewAuditLogRequest = new ViewAuditLogRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ViewAuditLogResponse$Type extends MessageType<ViewAuditLogResponse> {
    constructor() {
        super("services.settings.ViewAuditLogResponse", [
            { no: 1, name: "pagination", kind: "message", T: () => PaginationResponse, options: { "buf.validate.field": { required: true } } },
            { no: 2, name: "logs", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => AuditEntry, options: { "codegen.itemslen.enabled": true } }
        ]);
    }
    create(value?: PartialMessage<ViewAuditLogResponse>): ViewAuditLogResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.logs = [];
        if (value !== undefined)
            reflectionMergePartial<ViewAuditLogResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ViewAuditLogResponse): ViewAuditLogResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.common.database.PaginationResponse pagination */ 1:
                    message.pagination = PaginationResponse.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                case /* repeated resources.audit.AuditEntry logs */ 2:
                    message.logs.push(AuditEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ViewAuditLogResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.common.database.PaginationResponse pagination = 1; */
        if (message.pagination)
            PaginationResponse.internalBinaryWrite(message.pagination, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated resources.audit.AuditEntry logs = 2; */
        for (let i = 0; i < message.logs.length; i++)
            AuditEntry.internalBinaryWrite(message.logs[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.settings.ViewAuditLogResponse
 */
export const ViewAuditLogResponse = new ViewAuditLogResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListDiscordChannelsRequest$Type extends MessageType<ListDiscordChannelsRequest> {
    constructor() {
        super("services.settings.ListDiscordChannelsRequest", []);
    }
    create(value?: PartialMessage<ListDiscordChannelsRequest>): ListDiscordChannelsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ListDiscordChannelsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListDiscordChannelsRequest): ListDiscordChannelsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListDiscordChannelsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.settings.ListDiscordChannelsRequest
 */
export const ListDiscordChannelsRequest = new ListDiscordChannelsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListDiscordChannelsResponse$Type extends MessageType<ListDiscordChannelsResponse> {
    constructor() {
        super("services.settings.ListDiscordChannelsResponse", [
            { no: 1, name: "channels", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Channel }
        ]);
    }
    create(value?: PartialMessage<ListDiscordChannelsResponse>): ListDiscordChannelsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.channels = [];
        if (value !== undefined)
            reflectionMergePartial<ListDiscordChannelsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListDiscordChannelsResponse): ListDiscordChannelsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated resources.discord.Channel channels */ 1:
                    message.channels.push(Channel.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListDiscordChannelsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated resources.discord.Channel channels = 1; */
        for (let i = 0; i < message.channels.length; i++)
            Channel.internalBinaryWrite(message.channels[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.settings.ListDiscordChannelsResponse
 */
export const ListDiscordChannelsResponse = new ListDiscordChannelsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListUserGuildsRequest$Type extends MessageType<ListUserGuildsRequest> {
    constructor() {
        super("services.settings.ListUserGuildsRequest", []);
    }
    create(value?: PartialMessage<ListUserGuildsRequest>): ListUserGuildsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ListUserGuildsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListUserGuildsRequest): ListUserGuildsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListUserGuildsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.settings.ListUserGuildsRequest
 */
export const ListUserGuildsRequest = new ListUserGuildsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListUserGuildsResponse$Type extends MessageType<ListUserGuildsResponse> {
    constructor() {
        super("services.settings.ListUserGuildsResponse", [
            { no: 1, name: "guilds", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Guild }
        ]);
    }
    create(value?: PartialMessage<ListUserGuildsResponse>): ListUserGuildsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.guilds = [];
        if (value !== undefined)
            reflectionMergePartial<ListUserGuildsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListUserGuildsResponse): ListUserGuildsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated resources.discord.Guild guilds */ 1:
                    message.guilds.push(Guild.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListUserGuildsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated resources.discord.Guild guilds = 1; */
        for (let i = 0; i < message.guilds.length; i++)
            Guild.internalBinaryWrite(message.guilds[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.settings.ListUserGuildsResponse
 */
export const ListUserGuildsResponse = new ListUserGuildsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteJobLogoRequest$Type extends MessageType<DeleteJobLogoRequest> {
    constructor() {
        super("services.settings.DeleteJobLogoRequest", []);
    }
    create(value?: PartialMessage<DeleteJobLogoRequest>): DeleteJobLogoRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DeleteJobLogoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteJobLogoRequest): DeleteJobLogoRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteJobLogoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.settings.DeleteJobLogoRequest
 */
export const DeleteJobLogoRequest = new DeleteJobLogoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteJobLogoResponse$Type extends MessageType<DeleteJobLogoResponse> {
    constructor() {
        super("services.settings.DeleteJobLogoResponse", []);
    }
    create(value?: PartialMessage<DeleteJobLogoResponse>): DeleteJobLogoResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DeleteJobLogoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteJobLogoResponse): DeleteJobLogoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteJobLogoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.settings.DeleteJobLogoResponse
 */
export const DeleteJobLogoResponse = new DeleteJobLogoResponse$Type();
/**
 * @generated ServiceType for protobuf service services.settings.SettingsService
 */
export const SettingsService = new ServiceType("services.settings.SettingsService", [
    { name: "GetJobProps", options: { "codegen.perms.perms": { enabled: true } }, I: GetJobPropsRequest, O: GetJobPropsResponse },
    { name: "SetJobProps", options: { "codegen.perms.perms": { enabled: true } }, I: SetJobPropsRequest, O: SetJobPropsResponse },
    { name: "GetRoles", options: { "codegen.perms.perms": { enabled: true } }, I: GetRolesRequest, O: GetRolesResponse },
    { name: "GetRole", options: { "codegen.perms.perms": { enabled: true, name: "GetRoles" } }, I: GetRoleRequest, O: GetRoleResponse },
    { name: "CreateRole", options: { "codegen.perms.perms": { enabled: true } }, I: CreateRoleRequest, O: CreateRoleResponse },
    { name: "DeleteRole", options: { "codegen.perms.perms": { enabled: true } }, I: DeleteRoleRequest, O: DeleteRoleResponse },
    { name: "UpdateRolePerms", options: { "codegen.perms.perms": { enabled: true } }, I: UpdateRolePermsRequest, O: UpdateRolePermsResponse },
    { name: "GetPermissions", options: { "codegen.perms.perms": { enabled: true, name: "GetRoles" } }, I: GetPermissionsRequest, O: GetPermissionsResponse },
    { name: "GetEffectivePermissions", options: { "codegen.perms.perms": { enabled: true, name: "GetRoles" } }, I: GetEffectivePermissionsRequest, O: GetEffectivePermissionsResponse },
    { name: "ViewAuditLog", options: { "codegen.perms.perms": { enabled: true } }, I: ViewAuditLogRequest, O: ViewAuditLogResponse },
    { name: "ListDiscordChannels", options: { "codegen.perms.perms": { enabled: true, name: "SetJobProps" } }, I: ListDiscordChannelsRequest, O: ListDiscordChannelsResponse },
    { name: "ListUserGuilds", options: { "codegen.perms.perms": { enabled: true, name: "SetJobProps" } }, I: ListUserGuildsRequest, O: ListUserGuildsResponse },
    { name: "UploadJobLogo", clientStreaming: true, options: { "codegen.perms.perms": { enabled: true, name: "SetJobProps" } }, I: UploadFileRequest, O: UploadFileResponse },
    { name: "DeleteJobLogo", options: { "codegen.perms.perms": { enabled: true, name: "SetJobProps" } }, I: DeleteJobLogoRequest, O: DeleteJobLogoResponse }
], { "codegen.perms.perms_svc": { order: 120, icon: "i-mdi-cog-outline" } });
