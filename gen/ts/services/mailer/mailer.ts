// @generated by protobuf-ts 2.9.4 with parameter optimize_speed,long_type_number,force_server_none
// @generated from protobuf file "services/mailer/mailer.proto" (package "services.mailer", syntax proto3)
// @ts-nocheck
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { EmailSettings } from "../../resources/mailer/settings";
import { ThreadState } from "../../resources/mailer/thread";
import { Message } from "../../resources/mailer/message";
import { Thread } from "../../resources/mailer/thread";
import { PaginationResponse } from "../../resources/common/database/database";
import { Timestamp } from "../../resources/timestamp/timestamp";
import { PaginationRequest } from "../../resources/common/database/database";
import { Template } from "../../resources/mailer/template";
import { Email } from "../../resources/mailer/email";
import { EmailShort } from "../../resources/mailer/email";
// Emails

/**
 * @generated from protobuf message services.mailer.ListEmailsRequest
 */
export interface ListEmailsRequest {
}
/**
 * @generated from protobuf message services.mailer.ListEmailsResponse
 */
export interface ListEmailsResponse {
    /**
     * @generated from protobuf field: repeated resources.mailer.EmailShort emails = 1;
     */
    emails: EmailShort[];
}
/**
 * @generated from protobuf message services.mailer.GetEmailRequest
 */
export interface GetEmailRequest {
    /**
     * @generated from protobuf field: uint64 id = 1 [jstype = JS_STRING];
     */
    id: string;
}
/**
 * @generated from protobuf message services.mailer.GetEmailResponse
 */
export interface GetEmailResponse {
    /**
     * @generated from protobuf field: resources.mailer.Email email = 1;
     */
    email?: Email;
}
/**
 * @generated from protobuf message services.mailer.CreateOrUpdateEmailRequest
 */
export interface CreateOrUpdateEmailRequest {
    /**
     * @generated from protobuf field: resources.mailer.Email email = 1;
     */
    email?: Email;
}
/**
 * @generated from protobuf message services.mailer.CreateOrUpdateEmailResponse
 */
export interface CreateOrUpdateEmailResponse {
    /**
     * @generated from protobuf field: resources.mailer.Email email = 1;
     */
    email?: Email;
}
/**
 * @generated from protobuf message services.mailer.DeleteEmailRequest
 */
export interface DeleteEmailRequest {
    /**
     * @generated from protobuf field: uint64 id = 1 [jstype = JS_STRING];
     */
    id: string;
}
/**
 * @generated from protobuf message services.mailer.DeleteEmailResponse
 */
export interface DeleteEmailResponse {
}
// Templates

/**
 * @generated from protobuf message services.mailer.ListTemplatesRequest
 */
export interface ListTemplatesRequest {
    /**
     * @generated from protobuf field: uint64 email_id = 1 [jstype = JS_STRING];
     */
    emailId: string;
}
/**
 * @generated from protobuf message services.mailer.ListTemplatesResponse
 */
export interface ListTemplatesResponse {
    /**
     * @generated from protobuf field: repeated resources.mailer.Template templates = 1;
     */
    templates: Template[];
}
/**
 * @generated from protobuf message services.mailer.GetTemplateRequest
 */
export interface GetTemplateRequest {
    /**
     * @generated from protobuf field: uint64 email_id = 1 [jstype = JS_STRING];
     */
    emailId: string;
    /**
     * @generated from protobuf field: uint64 template_id = 2 [jstype = JS_STRING];
     */
    templateId: string;
}
/**
 * @generated from protobuf message services.mailer.GetTemplateResponse
 */
export interface GetTemplateResponse {
    /**
     * @generated from protobuf field: resources.mailer.Template template = 1;
     */
    template?: Template;
}
/**
 * @generated from protobuf message services.mailer.CreateOrUpdateTemplateRequest
 */
export interface CreateOrUpdateTemplateRequest {
    /**
     * @generated from protobuf field: resources.mailer.Template template = 1;
     */
    template?: Template;
}
/**
 * @generated from protobuf message services.mailer.CreateOrUpdateTemplateResponse
 */
export interface CreateOrUpdateTemplateResponse {
    /**
     * @generated from protobuf field: resources.mailer.Template template = 1;
     */
    template?: Template;
}
/**
 * @generated from protobuf message services.mailer.DeleteTemplateRequest
 */
export interface DeleteTemplateRequest {
    /**
     * @generated from protobuf field: uint64 email_id = 1 [jstype = JS_STRING];
     */
    emailId: string;
    /**
     * @generated from protobuf field: uint64 id = 2 [jstype = JS_STRING];
     */
    id: string;
}
/**
 * @generated from protobuf message services.mailer.DeleteTemplateResponse
 */
export interface DeleteTemplateResponse {
}
// Threads

/**
 * @generated from protobuf message services.mailer.ListThreadsRequest
 */
export interface ListThreadsRequest {
    /**
     * @generated from protobuf field: resources.common.database.PaginationRequest pagination = 1;
     */
    pagination?: PaginationRequest;
    /**
     * Search params
     *
     * @generated from protobuf field: repeated uint64 email_ids = 2 [jstype = JS_STRING];
     */
    emailIds: string[];
    /**
     * @generated from protobuf field: optional resources.timestamp.Timestamp after = 3;
     */
    after?: Timestamp;
}
/**
 * @generated from protobuf message services.mailer.ListThreadsResponse
 */
export interface ListThreadsResponse {
    /**
     * @generated from protobuf field: resources.common.database.PaginationResponse pagination = 1;
     */
    pagination?: PaginationResponse;
    /**
     * @generated from protobuf field: repeated resources.mailer.Thread threads = 2;
     */
    threads: Thread[];
}
/**
 * @generated from protobuf message services.mailer.GetThreadRequest
 */
export interface GetThreadRequest {
    /**
     * @generated from protobuf field: uint64 email_id = 1 [jstype = JS_STRING];
     */
    emailId: string;
    /**
     * @generated from protobuf field: uint64 thread_id = 2 [jstype = JS_STRING];
     */
    threadId: string;
}
/**
 * @generated from protobuf message services.mailer.GetThreadResponse
 */
export interface GetThreadResponse {
    /**
     * @generated from protobuf field: resources.mailer.Thread thread = 1;
     */
    thread?: Thread;
}
/**
 * @generated from protobuf message services.mailer.CreateThreadRequest
 */
export interface CreateThreadRequest {
    /**
     * @generated from protobuf field: resources.mailer.Thread thread = 1;
     */
    thread?: Thread;
    /**
     * @generated from protobuf field: resources.mailer.Message message = 2;
     */
    message?: Message;
}
/**
 * @generated from protobuf message services.mailer.CreateThreadResponse
 */
export interface CreateThreadResponse {
    /**
     * @generated from protobuf field: resources.mailer.Thread thread = 1;
     */
    thread?: Thread;
}
/**
 * @generated from protobuf message services.mailer.DeleteThreadRequest
 */
export interface DeleteThreadRequest {
    /**
     * @generated from protobuf field: uint64 email_id = 1 [jstype = JS_STRING];
     */
    emailId: string;
    /**
     * @generated from protobuf field: uint64 thread_id = 2 [jstype = JS_STRING];
     */
    threadId: string;
}
/**
 * @generated from protobuf message services.mailer.DeleteThreadResponse
 */
export interface DeleteThreadResponse {
}
/**
 * @generated from protobuf message services.mailer.SetThreadStateRequest
 */
export interface SetThreadStateRequest {
    /**
     * @generated from protobuf field: resources.mailer.ThreadState state = 1;
     */
    state?: ThreadState;
}
/**
 * @generated from protobuf message services.mailer.SetThreadStateResponse
 */
export interface SetThreadStateResponse {
}
/**
 * @generated from protobuf message services.mailer.GetEmailSettingsRequest
 */
export interface GetEmailSettingsRequest {
}
/**
 * @generated from protobuf message services.mailer.GetEmailSettingsResponse
 */
export interface GetEmailSettingsResponse {
    /**
     * @generated from protobuf field: resources.mailer.EmailSettings settings = 1;
     */
    settings?: EmailSettings;
}
/**
 * @generated from protobuf message services.mailer.SetEmailSettingsRequest
 */
export interface SetEmailSettingsRequest {
    /**
     * @generated from protobuf field: resources.mailer.EmailSettings settings = 1;
     */
    settings?: EmailSettings;
}
/**
 * @generated from protobuf message services.mailer.SetEmailSettingsResponse
 */
export interface SetEmailSettingsResponse {
    /**
     * @generated from protobuf field: resources.mailer.EmailSettings settings = 1;
     */
    settings?: EmailSettings;
}
// Messages

/**
 * @generated from protobuf message services.mailer.ListThreadMessagesRequest
 */
export interface ListThreadMessagesRequest {
    /**
     * @generated from protobuf field: resources.common.database.PaginationRequest pagination = 1;
     */
    pagination?: PaginationRequest;
    /**
     * @generated from protobuf field: uint64 email_id = 2 [jstype = JS_STRING];
     */
    emailId: string;
    /**
     * @generated from protobuf field: uint64 thread_id = 3 [jstype = JS_STRING];
     */
    threadId: string;
    /**
     * @generated from protobuf field: resources.timestamp.Timestamp after = 4;
     */
    after?: Timestamp;
}
/**
 * @generated from protobuf message services.mailer.ListThreadMessagesResponse
 */
export interface ListThreadMessagesResponse {
    /**
     * @generated from protobuf field: resources.common.database.PaginationResponse pagination = 1;
     */
    pagination?: PaginationResponse;
    /**
     * @generated from protobuf field: repeated resources.mailer.Message messages = 2;
     */
    messages: Message[];
}
/**
 * @generated from protobuf message services.mailer.PostMessageRequest
 */
export interface PostMessageRequest {
    /**
     * @generated from protobuf field: resources.mailer.Message message = 1;
     */
    message?: Message;
}
/**
 * @generated from protobuf message services.mailer.PostMessageResponse
 */
export interface PostMessageResponse {
    /**
     * @generated from protobuf field: resources.mailer.Message message = 1;
     */
    message?: Message;
}
/**
 * @generated from protobuf message services.mailer.DeleteMessageRequest
 */
export interface DeleteMessageRequest {
    /**
     * @generated from protobuf field: uint64 email_id = 1 [jstype = JS_STRING];
     */
    emailId: string;
    /**
     * @generated from protobuf field: uint64 thread_id = 2 [jstype = JS_STRING];
     */
    threadId: string;
    /**
     * @generated from protobuf field: uint64 message_id = 3 [jstype = JS_STRING];
     */
    messageId: string;
}
/**
 * @generated from protobuf message services.mailer.DeleteMessageResponse
 */
export interface DeleteMessageResponse {
}
// @generated message type with reflection information, may provide speed optimized methods
class ListEmailsRequest$Type extends MessageType<ListEmailsRequest> {
    constructor() {
        super("services.mailer.ListEmailsRequest", []);
    }
    create(value?: PartialMessage<ListEmailsRequest>): ListEmailsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ListEmailsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListEmailsRequest): ListEmailsRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ListEmailsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.mailer.ListEmailsRequest
 */
export const ListEmailsRequest = new ListEmailsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEmailsResponse$Type extends MessageType<ListEmailsResponse> {
    constructor() {
        super("services.mailer.ListEmailsResponse", [
            { no: 1, name: "emails", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => EmailShort }
        ]);
    }
    create(value?: PartialMessage<ListEmailsResponse>): ListEmailsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.emails = [];
        if (value !== undefined)
            reflectionMergePartial<ListEmailsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListEmailsResponse): ListEmailsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated resources.mailer.EmailShort emails */ 1:
                    message.emails.push(EmailShort.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListEmailsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated resources.mailer.EmailShort emails = 1; */
        for (let i = 0; i < message.emails.length; i++)
            EmailShort.internalBinaryWrite(message.emails[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.mailer.ListEmailsResponse
 */
export const ListEmailsResponse = new ListEmailsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetEmailRequest$Type extends MessageType<GetEmailRequest> {
    constructor() {
        super("services.mailer.GetEmailRequest", [
            { no: 1, name: "id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, options: { "validate.rules": { uint64: { gt: "0" } } } }
        ]);
    }
    create(value?: PartialMessage<GetEmailRequest>): GetEmailRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "0";
        if (value !== undefined)
            reflectionMergePartial<GetEmailRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetEmailRequest): GetEmailRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 id = 1 [jstype = JS_STRING];*/ 1:
                    message.id = reader.uint64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetEmailRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 id = 1 [jstype = JS_STRING]; */
        if (message.id !== "0")
            writer.tag(1, WireType.Varint).uint64(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.mailer.GetEmailRequest
 */
export const GetEmailRequest = new GetEmailRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetEmailResponse$Type extends MessageType<GetEmailResponse> {
    constructor() {
        super("services.mailer.GetEmailResponse", [
            { no: 1, name: "email", kind: "message", T: () => Email, options: { "validate.rules": { message: { required: true } } } }
        ]);
    }
    create(value?: PartialMessage<GetEmailResponse>): GetEmailResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetEmailResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetEmailResponse): GetEmailResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.mailer.Email email */ 1:
                    message.email = Email.internalBinaryRead(reader, reader.uint32(), options, message.email);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetEmailResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.mailer.Email email = 1; */
        if (message.email)
            Email.internalBinaryWrite(message.email, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.mailer.GetEmailResponse
 */
export const GetEmailResponse = new GetEmailResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateOrUpdateEmailRequest$Type extends MessageType<CreateOrUpdateEmailRequest> {
    constructor() {
        super("services.mailer.CreateOrUpdateEmailRequest", [
            { no: 1, name: "email", kind: "message", T: () => Email, options: { "validate.rules": { message: { required: true } } } }
        ]);
    }
    create(value?: PartialMessage<CreateOrUpdateEmailRequest>): CreateOrUpdateEmailRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CreateOrUpdateEmailRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateOrUpdateEmailRequest): CreateOrUpdateEmailRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.mailer.Email email */ 1:
                    message.email = Email.internalBinaryRead(reader, reader.uint32(), options, message.email);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateOrUpdateEmailRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.mailer.Email email = 1; */
        if (message.email)
            Email.internalBinaryWrite(message.email, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.mailer.CreateOrUpdateEmailRequest
 */
export const CreateOrUpdateEmailRequest = new CreateOrUpdateEmailRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateOrUpdateEmailResponse$Type extends MessageType<CreateOrUpdateEmailResponse> {
    constructor() {
        super("services.mailer.CreateOrUpdateEmailResponse", [
            { no: 1, name: "email", kind: "message", T: () => Email }
        ]);
    }
    create(value?: PartialMessage<CreateOrUpdateEmailResponse>): CreateOrUpdateEmailResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CreateOrUpdateEmailResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateOrUpdateEmailResponse): CreateOrUpdateEmailResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.mailer.Email email */ 1:
                    message.email = Email.internalBinaryRead(reader, reader.uint32(), options, message.email);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateOrUpdateEmailResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.mailer.Email email = 1; */
        if (message.email)
            Email.internalBinaryWrite(message.email, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.mailer.CreateOrUpdateEmailResponse
 */
export const CreateOrUpdateEmailResponse = new CreateOrUpdateEmailResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteEmailRequest$Type extends MessageType<DeleteEmailRequest> {
    constructor() {
        super("services.mailer.DeleteEmailRequest", [
            { no: 1, name: "id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, options: { "validate.rules": { uint64: { gt: "0" } } } }
        ]);
    }
    create(value?: PartialMessage<DeleteEmailRequest>): DeleteEmailRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "0";
        if (value !== undefined)
            reflectionMergePartial<DeleteEmailRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteEmailRequest): DeleteEmailRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 id = 1 [jstype = JS_STRING];*/ 1:
                    message.id = reader.uint64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteEmailRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 id = 1 [jstype = JS_STRING]; */
        if (message.id !== "0")
            writer.tag(1, WireType.Varint).uint64(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.mailer.DeleteEmailRequest
 */
export const DeleteEmailRequest = new DeleteEmailRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteEmailResponse$Type extends MessageType<DeleteEmailResponse> {
    constructor() {
        super("services.mailer.DeleteEmailResponse", []);
    }
    create(value?: PartialMessage<DeleteEmailResponse>): DeleteEmailResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DeleteEmailResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteEmailResponse): DeleteEmailResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: DeleteEmailResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.mailer.DeleteEmailResponse
 */
export const DeleteEmailResponse = new DeleteEmailResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListTemplatesRequest$Type extends MessageType<ListTemplatesRequest> {
    constructor() {
        super("services.mailer.ListTemplatesRequest", [
            { no: 1, name: "email_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, options: { "validate.rules": { uint64: { gt: "0" } } } }
        ]);
    }
    create(value?: PartialMessage<ListTemplatesRequest>): ListTemplatesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.emailId = "0";
        if (value !== undefined)
            reflectionMergePartial<ListTemplatesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListTemplatesRequest): ListTemplatesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 email_id = 1 [jstype = JS_STRING];*/ 1:
                    message.emailId = reader.uint64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListTemplatesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 email_id = 1 [jstype = JS_STRING]; */
        if (message.emailId !== "0")
            writer.tag(1, WireType.Varint).uint64(message.emailId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.mailer.ListTemplatesRequest
 */
export const ListTemplatesRequest = new ListTemplatesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListTemplatesResponse$Type extends MessageType<ListTemplatesResponse> {
    constructor() {
        super("services.mailer.ListTemplatesResponse", [
            { no: 1, name: "templates", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Template }
        ]);
    }
    create(value?: PartialMessage<ListTemplatesResponse>): ListTemplatesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.templates = [];
        if (value !== undefined)
            reflectionMergePartial<ListTemplatesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListTemplatesResponse): ListTemplatesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated resources.mailer.Template templates */ 1:
                    message.templates.push(Template.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListTemplatesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated resources.mailer.Template templates = 1; */
        for (let i = 0; i < message.templates.length; i++)
            Template.internalBinaryWrite(message.templates[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.mailer.ListTemplatesResponse
 */
export const ListTemplatesResponse = new ListTemplatesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTemplateRequest$Type extends MessageType<GetTemplateRequest> {
    constructor() {
        super("services.mailer.GetTemplateRequest", [
            { no: 1, name: "email_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, options: { "validate.rules": { uint64: { gt: "0" } } } },
            { no: 2, name: "template_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, options: { "validate.rules": { uint64: { gt: "0" } } } }
        ]);
    }
    create(value?: PartialMessage<GetTemplateRequest>): GetTemplateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.emailId = "0";
        message.templateId = "0";
        if (value !== undefined)
            reflectionMergePartial<GetTemplateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTemplateRequest): GetTemplateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 email_id = 1 [jstype = JS_STRING];*/ 1:
                    message.emailId = reader.uint64().toString();
                    break;
                case /* uint64 template_id = 2 [jstype = JS_STRING];*/ 2:
                    message.templateId = reader.uint64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTemplateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 email_id = 1 [jstype = JS_STRING]; */
        if (message.emailId !== "0")
            writer.tag(1, WireType.Varint).uint64(message.emailId);
        /* uint64 template_id = 2 [jstype = JS_STRING]; */
        if (message.templateId !== "0")
            writer.tag(2, WireType.Varint).uint64(message.templateId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.mailer.GetTemplateRequest
 */
export const GetTemplateRequest = new GetTemplateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTemplateResponse$Type extends MessageType<GetTemplateResponse> {
    constructor() {
        super("services.mailer.GetTemplateResponse", [
            { no: 1, name: "template", kind: "message", T: () => Template, options: { "validate.rules": { message: { required: true } } } }
        ]);
    }
    create(value?: PartialMessage<GetTemplateResponse>): GetTemplateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetTemplateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTemplateResponse): GetTemplateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.mailer.Template template */ 1:
                    message.template = Template.internalBinaryRead(reader, reader.uint32(), options, message.template);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTemplateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.mailer.Template template = 1; */
        if (message.template)
            Template.internalBinaryWrite(message.template, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.mailer.GetTemplateResponse
 */
export const GetTemplateResponse = new GetTemplateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateOrUpdateTemplateRequest$Type extends MessageType<CreateOrUpdateTemplateRequest> {
    constructor() {
        super("services.mailer.CreateOrUpdateTemplateRequest", [
            { no: 1, name: "template", kind: "message", T: () => Template, options: { "validate.rules": { message: { required: true } } } }
        ]);
    }
    create(value?: PartialMessage<CreateOrUpdateTemplateRequest>): CreateOrUpdateTemplateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CreateOrUpdateTemplateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateOrUpdateTemplateRequest): CreateOrUpdateTemplateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.mailer.Template template */ 1:
                    message.template = Template.internalBinaryRead(reader, reader.uint32(), options, message.template);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateOrUpdateTemplateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.mailer.Template template = 1; */
        if (message.template)
            Template.internalBinaryWrite(message.template, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.mailer.CreateOrUpdateTemplateRequest
 */
export const CreateOrUpdateTemplateRequest = new CreateOrUpdateTemplateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateOrUpdateTemplateResponse$Type extends MessageType<CreateOrUpdateTemplateResponse> {
    constructor() {
        super("services.mailer.CreateOrUpdateTemplateResponse", [
            { no: 1, name: "template", kind: "message", T: () => Template, options: { "validate.rules": { message: { required: true } } } }
        ]);
    }
    create(value?: PartialMessage<CreateOrUpdateTemplateResponse>): CreateOrUpdateTemplateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CreateOrUpdateTemplateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateOrUpdateTemplateResponse): CreateOrUpdateTemplateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.mailer.Template template */ 1:
                    message.template = Template.internalBinaryRead(reader, reader.uint32(), options, message.template);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateOrUpdateTemplateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.mailer.Template template = 1; */
        if (message.template)
            Template.internalBinaryWrite(message.template, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.mailer.CreateOrUpdateTemplateResponse
 */
export const CreateOrUpdateTemplateResponse = new CreateOrUpdateTemplateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteTemplateRequest$Type extends MessageType<DeleteTemplateRequest> {
    constructor() {
        super("services.mailer.DeleteTemplateRequest", [
            { no: 1, name: "email_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, options: { "validate.rules": { uint64: { gt: "0" } } } },
            { no: 2, name: "id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, options: { "validate.rules": { uint64: { gt: "0" } } } }
        ]);
    }
    create(value?: PartialMessage<DeleteTemplateRequest>): DeleteTemplateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.emailId = "0";
        message.id = "0";
        if (value !== undefined)
            reflectionMergePartial<DeleteTemplateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteTemplateRequest): DeleteTemplateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 email_id = 1 [jstype = JS_STRING];*/ 1:
                    message.emailId = reader.uint64().toString();
                    break;
                case /* uint64 id = 2 [jstype = JS_STRING];*/ 2:
                    message.id = reader.uint64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteTemplateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 email_id = 1 [jstype = JS_STRING]; */
        if (message.emailId !== "0")
            writer.tag(1, WireType.Varint).uint64(message.emailId);
        /* uint64 id = 2 [jstype = JS_STRING]; */
        if (message.id !== "0")
            writer.tag(2, WireType.Varint).uint64(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.mailer.DeleteTemplateRequest
 */
export const DeleteTemplateRequest = new DeleteTemplateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteTemplateResponse$Type extends MessageType<DeleteTemplateResponse> {
    constructor() {
        super("services.mailer.DeleteTemplateResponse", []);
    }
    create(value?: PartialMessage<DeleteTemplateResponse>): DeleteTemplateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DeleteTemplateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteTemplateResponse): DeleteTemplateResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: DeleteTemplateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.mailer.DeleteTemplateResponse
 */
export const DeleteTemplateResponse = new DeleteTemplateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListThreadsRequest$Type extends MessageType<ListThreadsRequest> {
    constructor() {
        super("services.mailer.ListThreadsRequest", [
            { no: 1, name: "pagination", kind: "message", T: () => PaginationRequest, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "email_ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/ },
            { no: 3, name: "after", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<ListThreadsRequest>): ListThreadsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.emailIds = [];
        if (value !== undefined)
            reflectionMergePartial<ListThreadsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListThreadsRequest): ListThreadsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.common.database.PaginationRequest pagination */ 1:
                    message.pagination = PaginationRequest.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                case /* repeated uint64 email_ids = 2 [jstype = JS_STRING];*/ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.emailIds.push(reader.uint64().toString());
                    else
                        message.emailIds.push(reader.uint64().toString());
                    break;
                case /* optional resources.timestamp.Timestamp after */ 3:
                    message.after = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.after);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListThreadsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.common.database.PaginationRequest pagination = 1; */
        if (message.pagination)
            PaginationRequest.internalBinaryWrite(message.pagination, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated uint64 email_ids = 2 [jstype = JS_STRING]; */
        if (message.emailIds.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.emailIds.length; i++)
                writer.uint64(message.emailIds[i]);
            writer.join();
        }
        /* optional resources.timestamp.Timestamp after = 3; */
        if (message.after)
            Timestamp.internalBinaryWrite(message.after, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.mailer.ListThreadsRequest
 */
export const ListThreadsRequest = new ListThreadsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListThreadsResponse$Type extends MessageType<ListThreadsResponse> {
    constructor() {
        super("services.mailer.ListThreadsResponse", [
            { no: 1, name: "pagination", kind: "message", T: () => PaginationResponse, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "threads", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Thread }
        ]);
    }
    create(value?: PartialMessage<ListThreadsResponse>): ListThreadsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.threads = [];
        if (value !== undefined)
            reflectionMergePartial<ListThreadsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListThreadsResponse): ListThreadsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.common.database.PaginationResponse pagination */ 1:
                    message.pagination = PaginationResponse.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                case /* repeated resources.mailer.Thread threads */ 2:
                    message.threads.push(Thread.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListThreadsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.common.database.PaginationResponse pagination = 1; */
        if (message.pagination)
            PaginationResponse.internalBinaryWrite(message.pagination, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated resources.mailer.Thread threads = 2; */
        for (let i = 0; i < message.threads.length; i++)
            Thread.internalBinaryWrite(message.threads[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.mailer.ListThreadsResponse
 */
export const ListThreadsResponse = new ListThreadsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetThreadRequest$Type extends MessageType<GetThreadRequest> {
    constructor() {
        super("services.mailer.GetThreadRequest", [
            { no: 1, name: "email_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, options: { "validate.rules": { uint64: { gt: "0" } } } },
            { no: 2, name: "thread_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, options: { "validate.rules": { uint64: { gt: "0" } } } }
        ]);
    }
    create(value?: PartialMessage<GetThreadRequest>): GetThreadRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.emailId = "0";
        message.threadId = "0";
        if (value !== undefined)
            reflectionMergePartial<GetThreadRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetThreadRequest): GetThreadRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 email_id = 1 [jstype = JS_STRING];*/ 1:
                    message.emailId = reader.uint64().toString();
                    break;
                case /* uint64 thread_id = 2 [jstype = JS_STRING];*/ 2:
                    message.threadId = reader.uint64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetThreadRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 email_id = 1 [jstype = JS_STRING]; */
        if (message.emailId !== "0")
            writer.tag(1, WireType.Varint).uint64(message.emailId);
        /* uint64 thread_id = 2 [jstype = JS_STRING]; */
        if (message.threadId !== "0")
            writer.tag(2, WireType.Varint).uint64(message.threadId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.mailer.GetThreadRequest
 */
export const GetThreadRequest = new GetThreadRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetThreadResponse$Type extends MessageType<GetThreadResponse> {
    constructor() {
        super("services.mailer.GetThreadResponse", [
            { no: 1, name: "thread", kind: "message", T: () => Thread }
        ]);
    }
    create(value?: PartialMessage<GetThreadResponse>): GetThreadResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetThreadResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetThreadResponse): GetThreadResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.mailer.Thread thread */ 1:
                    message.thread = Thread.internalBinaryRead(reader, reader.uint32(), options, message.thread);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetThreadResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.mailer.Thread thread = 1; */
        if (message.thread)
            Thread.internalBinaryWrite(message.thread, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.mailer.GetThreadResponse
 */
export const GetThreadResponse = new GetThreadResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateThreadRequest$Type extends MessageType<CreateThreadRequest> {
    constructor() {
        super("services.mailer.CreateThreadRequest", [
            { no: 1, name: "thread", kind: "message", T: () => Thread, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "message", kind: "message", T: () => Message, options: { "validate.rules": { message: { required: true } } } }
        ]);
    }
    create(value?: PartialMessage<CreateThreadRequest>): CreateThreadRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CreateThreadRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateThreadRequest): CreateThreadRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.mailer.Thread thread */ 1:
                    message.thread = Thread.internalBinaryRead(reader, reader.uint32(), options, message.thread);
                    break;
                case /* resources.mailer.Message message */ 2:
                    message.message = Message.internalBinaryRead(reader, reader.uint32(), options, message.message);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateThreadRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.mailer.Thread thread = 1; */
        if (message.thread)
            Thread.internalBinaryWrite(message.thread, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* resources.mailer.Message message = 2; */
        if (message.message)
            Message.internalBinaryWrite(message.message, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.mailer.CreateThreadRequest
 */
export const CreateThreadRequest = new CreateThreadRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateThreadResponse$Type extends MessageType<CreateThreadResponse> {
    constructor() {
        super("services.mailer.CreateThreadResponse", [
            { no: 1, name: "thread", kind: "message", T: () => Thread }
        ]);
    }
    create(value?: PartialMessage<CreateThreadResponse>): CreateThreadResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CreateThreadResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateThreadResponse): CreateThreadResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.mailer.Thread thread */ 1:
                    message.thread = Thread.internalBinaryRead(reader, reader.uint32(), options, message.thread);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateThreadResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.mailer.Thread thread = 1; */
        if (message.thread)
            Thread.internalBinaryWrite(message.thread, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.mailer.CreateThreadResponse
 */
export const CreateThreadResponse = new CreateThreadResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteThreadRequest$Type extends MessageType<DeleteThreadRequest> {
    constructor() {
        super("services.mailer.DeleteThreadRequest", [
            { no: 1, name: "email_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, options: { "validate.rules": { uint64: { gt: "0" } } } },
            { no: 2, name: "thread_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, options: { "validate.rules": { uint64: { gt: "0" } } } }
        ]);
    }
    create(value?: PartialMessage<DeleteThreadRequest>): DeleteThreadRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.emailId = "0";
        message.threadId = "0";
        if (value !== undefined)
            reflectionMergePartial<DeleteThreadRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteThreadRequest): DeleteThreadRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 email_id = 1 [jstype = JS_STRING];*/ 1:
                    message.emailId = reader.uint64().toString();
                    break;
                case /* uint64 thread_id = 2 [jstype = JS_STRING];*/ 2:
                    message.threadId = reader.uint64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteThreadRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 email_id = 1 [jstype = JS_STRING]; */
        if (message.emailId !== "0")
            writer.tag(1, WireType.Varint).uint64(message.emailId);
        /* uint64 thread_id = 2 [jstype = JS_STRING]; */
        if (message.threadId !== "0")
            writer.tag(2, WireType.Varint).uint64(message.threadId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.mailer.DeleteThreadRequest
 */
export const DeleteThreadRequest = new DeleteThreadRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteThreadResponse$Type extends MessageType<DeleteThreadResponse> {
    constructor() {
        super("services.mailer.DeleteThreadResponse", []);
    }
    create(value?: PartialMessage<DeleteThreadResponse>): DeleteThreadResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DeleteThreadResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteThreadResponse): DeleteThreadResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: DeleteThreadResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.mailer.DeleteThreadResponse
 */
export const DeleteThreadResponse = new DeleteThreadResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetThreadStateRequest$Type extends MessageType<SetThreadStateRequest> {
    constructor() {
        super("services.mailer.SetThreadStateRequest", [
            { no: 1, name: "state", kind: "message", T: () => ThreadState }
        ]);
    }
    create(value?: PartialMessage<SetThreadStateRequest>): SetThreadStateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetThreadStateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetThreadStateRequest): SetThreadStateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.mailer.ThreadState state */ 1:
                    message.state = ThreadState.internalBinaryRead(reader, reader.uint32(), options, message.state);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetThreadStateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.mailer.ThreadState state = 1; */
        if (message.state)
            ThreadState.internalBinaryWrite(message.state, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.mailer.SetThreadStateRequest
 */
export const SetThreadStateRequest = new SetThreadStateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetThreadStateResponse$Type extends MessageType<SetThreadStateResponse> {
    constructor() {
        super("services.mailer.SetThreadStateResponse", []);
    }
    create(value?: PartialMessage<SetThreadStateResponse>): SetThreadStateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetThreadStateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetThreadStateResponse): SetThreadStateResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SetThreadStateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.mailer.SetThreadStateResponse
 */
export const SetThreadStateResponse = new SetThreadStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetEmailSettingsRequest$Type extends MessageType<GetEmailSettingsRequest> {
    constructor() {
        super("services.mailer.GetEmailSettingsRequest", []);
    }
    create(value?: PartialMessage<GetEmailSettingsRequest>): GetEmailSettingsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetEmailSettingsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetEmailSettingsRequest): GetEmailSettingsRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetEmailSettingsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.mailer.GetEmailSettingsRequest
 */
export const GetEmailSettingsRequest = new GetEmailSettingsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetEmailSettingsResponse$Type extends MessageType<GetEmailSettingsResponse> {
    constructor() {
        super("services.mailer.GetEmailSettingsResponse", [
            { no: 1, name: "settings", kind: "message", T: () => EmailSettings }
        ]);
    }
    create(value?: PartialMessage<GetEmailSettingsResponse>): GetEmailSettingsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetEmailSettingsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetEmailSettingsResponse): GetEmailSettingsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.mailer.EmailSettings settings */ 1:
                    message.settings = EmailSettings.internalBinaryRead(reader, reader.uint32(), options, message.settings);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetEmailSettingsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.mailer.EmailSettings settings = 1; */
        if (message.settings)
            EmailSettings.internalBinaryWrite(message.settings, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.mailer.GetEmailSettingsResponse
 */
export const GetEmailSettingsResponse = new GetEmailSettingsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetEmailSettingsRequest$Type extends MessageType<SetEmailSettingsRequest> {
    constructor() {
        super("services.mailer.SetEmailSettingsRequest", [
            { no: 1, name: "settings", kind: "message", T: () => EmailSettings, options: { "validate.rules": { message: { required: true } } } }
        ]);
    }
    create(value?: PartialMessage<SetEmailSettingsRequest>): SetEmailSettingsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetEmailSettingsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetEmailSettingsRequest): SetEmailSettingsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.mailer.EmailSettings settings */ 1:
                    message.settings = EmailSettings.internalBinaryRead(reader, reader.uint32(), options, message.settings);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetEmailSettingsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.mailer.EmailSettings settings = 1; */
        if (message.settings)
            EmailSettings.internalBinaryWrite(message.settings, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.mailer.SetEmailSettingsRequest
 */
export const SetEmailSettingsRequest = new SetEmailSettingsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetEmailSettingsResponse$Type extends MessageType<SetEmailSettingsResponse> {
    constructor() {
        super("services.mailer.SetEmailSettingsResponse", [
            { no: 1, name: "settings", kind: "message", T: () => EmailSettings }
        ]);
    }
    create(value?: PartialMessage<SetEmailSettingsResponse>): SetEmailSettingsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetEmailSettingsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetEmailSettingsResponse): SetEmailSettingsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.mailer.EmailSettings settings */ 1:
                    message.settings = EmailSettings.internalBinaryRead(reader, reader.uint32(), options, message.settings);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetEmailSettingsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.mailer.EmailSettings settings = 1; */
        if (message.settings)
            EmailSettings.internalBinaryWrite(message.settings, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.mailer.SetEmailSettingsResponse
 */
export const SetEmailSettingsResponse = new SetEmailSettingsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListThreadMessagesRequest$Type extends MessageType<ListThreadMessagesRequest> {
    constructor() {
        super("services.mailer.ListThreadMessagesRequest", [
            { no: 1, name: "pagination", kind: "message", T: () => PaginationRequest, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "email_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, options: { "validate.rules": { uint64: { gt: "0" } } } },
            { no: 3, name: "thread_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, options: { "validate.rules": { uint64: { gt: "0" } } } },
            { no: 4, name: "after", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<ListThreadMessagesRequest>): ListThreadMessagesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.emailId = "0";
        message.threadId = "0";
        if (value !== undefined)
            reflectionMergePartial<ListThreadMessagesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListThreadMessagesRequest): ListThreadMessagesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.common.database.PaginationRequest pagination */ 1:
                    message.pagination = PaginationRequest.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                case /* uint64 email_id = 2 [jstype = JS_STRING];*/ 2:
                    message.emailId = reader.uint64().toString();
                    break;
                case /* uint64 thread_id = 3 [jstype = JS_STRING];*/ 3:
                    message.threadId = reader.uint64().toString();
                    break;
                case /* resources.timestamp.Timestamp after */ 4:
                    message.after = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.after);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListThreadMessagesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.common.database.PaginationRequest pagination = 1; */
        if (message.pagination)
            PaginationRequest.internalBinaryWrite(message.pagination, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint64 email_id = 2 [jstype = JS_STRING]; */
        if (message.emailId !== "0")
            writer.tag(2, WireType.Varint).uint64(message.emailId);
        /* uint64 thread_id = 3 [jstype = JS_STRING]; */
        if (message.threadId !== "0")
            writer.tag(3, WireType.Varint).uint64(message.threadId);
        /* resources.timestamp.Timestamp after = 4; */
        if (message.after)
            Timestamp.internalBinaryWrite(message.after, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.mailer.ListThreadMessagesRequest
 */
export const ListThreadMessagesRequest = new ListThreadMessagesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListThreadMessagesResponse$Type extends MessageType<ListThreadMessagesResponse> {
    constructor() {
        super("services.mailer.ListThreadMessagesResponse", [
            { no: 1, name: "pagination", kind: "message", T: () => PaginationResponse, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "messages", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Message }
        ]);
    }
    create(value?: PartialMessage<ListThreadMessagesResponse>): ListThreadMessagesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.messages = [];
        if (value !== undefined)
            reflectionMergePartial<ListThreadMessagesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListThreadMessagesResponse): ListThreadMessagesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.common.database.PaginationResponse pagination */ 1:
                    message.pagination = PaginationResponse.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                case /* repeated resources.mailer.Message messages */ 2:
                    message.messages.push(Message.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListThreadMessagesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.common.database.PaginationResponse pagination = 1; */
        if (message.pagination)
            PaginationResponse.internalBinaryWrite(message.pagination, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated resources.mailer.Message messages = 2; */
        for (let i = 0; i < message.messages.length; i++)
            Message.internalBinaryWrite(message.messages[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.mailer.ListThreadMessagesResponse
 */
export const ListThreadMessagesResponse = new ListThreadMessagesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PostMessageRequest$Type extends MessageType<PostMessageRequest> {
    constructor() {
        super("services.mailer.PostMessageRequest", [
            { no: 1, name: "message", kind: "message", T: () => Message, options: { "validate.rules": { message: { required: true } } } }
        ]);
    }
    create(value?: PartialMessage<PostMessageRequest>): PostMessageRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PostMessageRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PostMessageRequest): PostMessageRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.mailer.Message message */ 1:
                    message.message = Message.internalBinaryRead(reader, reader.uint32(), options, message.message);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PostMessageRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.mailer.Message message = 1; */
        if (message.message)
            Message.internalBinaryWrite(message.message, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.mailer.PostMessageRequest
 */
export const PostMessageRequest = new PostMessageRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PostMessageResponse$Type extends MessageType<PostMessageResponse> {
    constructor() {
        super("services.mailer.PostMessageResponse", [
            { no: 1, name: "message", kind: "message", T: () => Message }
        ]);
    }
    create(value?: PartialMessage<PostMessageResponse>): PostMessageResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PostMessageResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PostMessageResponse): PostMessageResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.mailer.Message message */ 1:
                    message.message = Message.internalBinaryRead(reader, reader.uint32(), options, message.message);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PostMessageResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.mailer.Message message = 1; */
        if (message.message)
            Message.internalBinaryWrite(message.message, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.mailer.PostMessageResponse
 */
export const PostMessageResponse = new PostMessageResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteMessageRequest$Type extends MessageType<DeleteMessageRequest> {
    constructor() {
        super("services.mailer.DeleteMessageRequest", [
            { no: 1, name: "email_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, options: { "validate.rules": { uint64: { gt: "0" } } } },
            { no: 2, name: "thread_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, options: { "validate.rules": { uint64: { gt: "0" } } } },
            { no: 3, name: "message_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, options: { "validate.rules": { uint64: { gt: "0" } } } }
        ]);
    }
    create(value?: PartialMessage<DeleteMessageRequest>): DeleteMessageRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.emailId = "0";
        message.threadId = "0";
        message.messageId = "0";
        if (value !== undefined)
            reflectionMergePartial<DeleteMessageRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteMessageRequest): DeleteMessageRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 email_id = 1 [jstype = JS_STRING];*/ 1:
                    message.emailId = reader.uint64().toString();
                    break;
                case /* uint64 thread_id = 2 [jstype = JS_STRING];*/ 2:
                    message.threadId = reader.uint64().toString();
                    break;
                case /* uint64 message_id = 3 [jstype = JS_STRING];*/ 3:
                    message.messageId = reader.uint64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteMessageRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 email_id = 1 [jstype = JS_STRING]; */
        if (message.emailId !== "0")
            writer.tag(1, WireType.Varint).uint64(message.emailId);
        /* uint64 thread_id = 2 [jstype = JS_STRING]; */
        if (message.threadId !== "0")
            writer.tag(2, WireType.Varint).uint64(message.threadId);
        /* uint64 message_id = 3 [jstype = JS_STRING]; */
        if (message.messageId !== "0")
            writer.tag(3, WireType.Varint).uint64(message.messageId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.mailer.DeleteMessageRequest
 */
export const DeleteMessageRequest = new DeleteMessageRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteMessageResponse$Type extends MessageType<DeleteMessageResponse> {
    constructor() {
        super("services.mailer.DeleteMessageResponse", []);
    }
    create(value?: PartialMessage<DeleteMessageResponse>): DeleteMessageResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DeleteMessageResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteMessageResponse): DeleteMessageResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: DeleteMessageResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.mailer.DeleteMessageResponse
 */
export const DeleteMessageResponse = new DeleteMessageResponse$Type();
/**
 * @generated ServiceType for protobuf service services.mailer.MailerService
 */
export const MailerService = new ServiceType("services.mailer.MailerService", [
    { name: "ListEmails", options: {}, I: ListEmailsRequest, O: ListEmailsResponse },
    { name: "GetEmail", options: {}, I: GetEmailRequest, O: GetEmailResponse },
    { name: "CreateOrUpdateEmail", options: {}, I: CreateOrUpdateEmailRequest, O: CreateOrUpdateEmailResponse },
    { name: "DeleteEmail", options: {}, I: DeleteEmailRequest, O: DeleteEmailResponse },
    { name: "ListTemplates", options: {}, I: ListTemplatesRequest, O: ListTemplatesResponse },
    { name: "GetTemplate", options: {}, I: GetTemplateRequest, O: GetTemplateResponse },
    { name: "CreateOrUpdateTemplate", options: {}, I: CreateOrUpdateTemplateRequest, O: CreateOrUpdateTemplateResponse },
    { name: "DeleteTemplate", options: {}, I: DeleteTemplateRequest, O: DeleteTemplateResponse },
    { name: "ListThreads", options: {}, I: ListThreadsRequest, O: ListThreadsResponse },
    { name: "GetThread", options: {}, I: GetThreadRequest, O: GetThreadResponse },
    { name: "CreateThread", options: {}, I: CreateThreadRequest, O: CreateThreadResponse },
    { name: "DeleteThread", options: {}, I: DeleteThreadRequest, O: DeleteThreadResponse },
    { name: "SetThreadState", options: {}, I: SetThreadStateRequest, O: SetThreadStateResponse },
    { name: "ListThreadMessages", options: {}, I: ListThreadMessagesRequest, O: ListThreadMessagesResponse },
    { name: "PostMessage", options: {}, I: PostMessageRequest, O: PostMessageResponse },
    { name: "DeleteMessage", options: {}, I: DeleteMessageRequest, O: DeleteMessageResponse },
    { name: "GetEmailSettings", options: {}, I: GetEmailSettingsRequest, O: GetEmailSettingsResponse },
    { name: "SetEmailSettings", options: {}, I: SetEmailSettingsRequest, O: SetEmailSettingsResponse }
]);
