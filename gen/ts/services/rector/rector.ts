// @generated by protobuf-ts 2.10.0 with parameter optimize_speed,long_type_number,force_server_none
// @generated from protobuf file "services/rector/rector.proto" (package "services.rector", syntax proto3)
// @ts-nocheck
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { AuditEntry } from "../../resources/rector/audit";
import { PaginationResponse } from "../../resources/common/database/database";
import { Timestamp } from "../../resources/timestamp/timestamp";
import { Sort } from "../../resources/common/database/database";
import { PaginationRequest } from "../../resources/common/database/database";
import { Permission } from "../../resources/permissions/permissions";
import { RoleAttribute } from "../../resources/permissions/attributes";
import { Role } from "../../resources/permissions/permissions";
import { JobProps } from "../../resources/users/job_props";
/**
 * @generated from protobuf message services.rector.GetJobPropsRequest
 */
export interface GetJobPropsRequest {
}
/**
 * @generated from protobuf message services.rector.GetJobPropsResponse
 */
export interface GetJobPropsResponse {
    /**
     * @generated from protobuf field: resources.users.JobProps job_props = 1;
     */
    jobProps?: JobProps;
}
/**
 * @generated from protobuf message services.rector.SetJobPropsRequest
 */
export interface SetJobPropsRequest {
    /**
     * @generated from protobuf field: resources.users.JobProps job_props = 1;
     */
    jobProps?: JobProps;
}
/**
 * @generated from protobuf message services.rector.SetJobPropsResponse
 */
export interface SetJobPropsResponse {
    /**
     * @generated from protobuf field: resources.users.JobProps job_props = 1;
     */
    jobProps?: JobProps;
}
/**
 * @generated from protobuf message services.rector.GetRolesRequest
 */
export interface GetRolesRequest {
    /**
     * @generated from protobuf field: optional bool lowest_rank = 1;
     */
    lowestRank?: boolean;
}
/**
 * @generated from protobuf message services.rector.GetRolesResponse
 */
export interface GetRolesResponse {
    /**
     * @generated from protobuf field: repeated resources.permissions.Role roles = 1;
     */
    roles: Role[];
}
/**
 * @generated from protobuf message services.rector.GetRoleRequest
 */
export interface GetRoleRequest {
    /**
     * @generated from protobuf field: uint64 id = 1;
     */
    id: number;
    /**
     * @generated from protobuf field: optional bool filtered = 2;
     */
    filtered?: boolean;
}
/**
 * @generated from protobuf message services.rector.GetRoleResponse
 */
export interface GetRoleResponse {
    /**
     * @generated from protobuf field: resources.permissions.Role role = 1;
     */
    role?: Role;
}
/**
 * @generated from protobuf message services.rector.CreateRoleRequest
 */
export interface CreateRoleRequest {
    /**
     * @generated from protobuf field: string job = 1;
     */
    job: string;
    /**
     * @generated from protobuf field: int32 grade = 2;
     */
    grade: number;
}
/**
 * @generated from protobuf message services.rector.CreateRoleResponse
 */
export interface CreateRoleResponse {
    /**
     * @generated from protobuf field: resources.permissions.Role role = 1;
     */
    role?: Role;
}
/**
 * @generated from protobuf message services.rector.DeleteRoleRequest
 */
export interface DeleteRoleRequest {
    /**
     * @generated from protobuf field: uint64 id = 1;
     */
    id: number;
}
/**
 * @generated from protobuf message services.rector.DeleteRoleResponse
 */
export interface DeleteRoleResponse {
}
/**
 * @generated from protobuf message services.rector.UpdateRolePermsRequest
 */
export interface UpdateRolePermsRequest {
    /**
     * @generated from protobuf field: uint64 id = 1;
     */
    id: number;
    /**
     * @generated from protobuf field: optional services.rector.PermsUpdate perms = 2;
     */
    perms?: PermsUpdate;
    /**
     * @generated from protobuf field: optional services.rector.AttrsUpdate attrs = 3;
     */
    attrs?: AttrsUpdate;
}
/**
 * @generated from protobuf message services.rector.PermsUpdate
 */
export interface PermsUpdate {
    /**
     * @generated from protobuf field: repeated services.rector.PermItem to_update = 1;
     */
    toUpdate: PermItem[];
    /**
     * @generated from protobuf field: repeated uint64 to_remove = 2;
     */
    toRemove: number[];
}
/**
 * @generated from protobuf message services.rector.PermItem
 */
export interface PermItem {
    /**
     * @generated from protobuf field: uint64 id = 1;
     */
    id: number;
    /**
     * @generated from protobuf field: bool val = 2;
     */
    val: boolean;
}
/**
 * @generated from protobuf message services.rector.AttrsUpdate
 */
export interface AttrsUpdate {
    /**
     * @generated from protobuf field: repeated resources.permissions.RoleAttribute to_update = 1;
     */
    toUpdate: RoleAttribute[];
    /**
     * @generated from protobuf field: repeated resources.permissions.RoleAttribute to_remove = 2;
     */
    toRemove: RoleAttribute[];
}
/**
 * @generated from protobuf message services.rector.UpdateRolePermsResponse
 */
export interface UpdateRolePermsResponse {
}
/**
 * @generated from protobuf message services.rector.GetPermissionsRequest
 */
export interface GetPermissionsRequest {
    /**
     * @generated from protobuf field: uint64 role_id = 1;
     */
    roleId: number;
    /**
     * @generated from protobuf field: optional bool filtered = 2;
     */
    filtered?: boolean;
}
/**
 * @generated from protobuf message services.rector.GetPermissionsResponse
 */
export interface GetPermissionsResponse {
    /**
     * @generated from protobuf field: repeated resources.permissions.Permission permissions = 1;
     */
    permissions: Permission[];
    /**
     * @generated from protobuf field: repeated resources.permissions.RoleAttribute attributes = 2;
     */
    attributes: RoleAttribute[];
}
/**
 * @generated from protobuf message services.rector.GetEffectivePermissionsRequest
 */
export interface GetEffectivePermissionsRequest {
    /**
     * @generated from protobuf field: uint64 role_id = 1;
     */
    roleId: number;
}
/**
 * @generated from protobuf message services.rector.GetEffectivePermissionsResponse
 */
export interface GetEffectivePermissionsResponse {
    /**
     * @generated from protobuf field: resources.permissions.Role role = 1;
     */
    role?: Role;
    /**
     * @generated from protobuf field: repeated resources.permissions.Permission permissions = 2;
     */
    permissions: Permission[];
    /**
     * @generated from protobuf field: repeated resources.permissions.RoleAttribute attributes = 3;
     */
    attributes: RoleAttribute[];
}
/**
 * @generated from protobuf message services.rector.ViewAuditLogRequest
 */
export interface ViewAuditLogRequest {
    /**
     * @generated from protobuf field: resources.common.database.PaginationRequest pagination = 1;
     */
    pagination?: PaginationRequest;
    /**
     * @generated from protobuf field: optional resources.common.database.Sort sort = 2;
     */
    sort?: Sort;
    /**
     * Search params
     *
     * @generated from protobuf field: repeated int32 user_ids = 3;
     */
    userIds: number[];
    /**
     * @generated from protobuf field: optional resources.timestamp.Timestamp from = 4;
     */
    from?: Timestamp;
    /**
     * @generated from protobuf field: optional resources.timestamp.Timestamp to = 5;
     */
    to?: Timestamp;
    /**
     * @sanitize: method=StripTags
     *
     * @generated from protobuf field: repeated string services = 6;
     */
    services: string[];
    /**
     * @sanitize: method=StripTags
     *
     * @generated from protobuf field: repeated string methods = 7;
     */
    methods: string[];
    /**
     * @generated from protobuf field: optional string search = 8;
     */
    search?: string;
}
/**
 * @generated from protobuf message services.rector.ViewAuditLogResponse
 */
export interface ViewAuditLogResponse {
    /**
     * @generated from protobuf field: resources.common.database.PaginationResponse pagination = 1;
     */
    pagination?: PaginationResponse;
    /**
     * @generated from protobuf field: repeated resources.rector.AuditEntry logs = 2;
     */
    logs: AuditEntry[];
}
/**
 * @generated from protobuf message services.rector.GetAllPermissionsRequest
 */
export interface GetAllPermissionsRequest {
    /**
     * @generated from protobuf field: string job = 1;
     */
    job: string;
}
/**
 * @generated from protobuf message services.rector.GetAllPermissionsResponse
 */
export interface GetAllPermissionsResponse {
    /**
     * @generated from protobuf field: repeated resources.permissions.Permission permissions = 1;
     */
    permissions: Permission[];
    /**
     * @generated from protobuf field: repeated resources.permissions.RoleAttribute attributes = 2;
     */
    attributes: RoleAttribute[];
}
/**
 * @generated from protobuf message services.rector.GetJobLimitsRequest
 */
export interface GetJobLimitsRequest {
    /**
     * @generated from protobuf field: string job = 1;
     */
    job: string;
}
/**
 * @generated from protobuf message services.rector.GetJobLimitsResponse
 */
export interface GetJobLimitsResponse {
    /**
     * @generated from protobuf field: string job = 1;
     */
    job: string;
    /**
     * @generated from protobuf field: optional string job_label = 2;
     */
    jobLabel?: string;
    /**
     * @generated from protobuf field: repeated resources.permissions.Permission permissions = 3;
     */
    permissions: Permission[];
    /**
     * @generated from protobuf field: repeated resources.permissions.RoleAttribute attributes = 4;
     */
    attributes: RoleAttribute[];
}
/**
 * @generated from protobuf message services.rector.UpdateJobLimitsRequest
 */
export interface UpdateJobLimitsRequest {
    /**
     * @generated from protobuf field: string job = 1;
     */
    job: string;
    /**
     * @generated from protobuf field: optional services.rector.PermsUpdate perms = 2;
     */
    perms?: PermsUpdate;
    /**
     * @generated from protobuf field: optional services.rector.AttrsUpdate attrs = 3;
     */
    attrs?: AttrsUpdate;
}
/**
 * @generated from protobuf message services.rector.UpdateJobLimitsResponse
 */
export interface UpdateJobLimitsResponse {
}
/**
 * @generated from protobuf message services.rector.DeleteFactionRequest
 */
export interface DeleteFactionRequest {
    /**
     * @generated from protobuf field: string job = 1;
     */
    job: string;
}
/**
 * @generated from protobuf message services.rector.DeleteFactionResponse
 */
export interface DeleteFactionResponse {
}
// @generated message type with reflection information, may provide speed optimized methods
class GetJobPropsRequest$Type extends MessageType<GetJobPropsRequest> {
    constructor() {
        super("services.rector.GetJobPropsRequest", []);
    }
    create(value?: PartialMessage<GetJobPropsRequest>): GetJobPropsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetJobPropsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetJobPropsRequest): GetJobPropsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetJobPropsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.rector.GetJobPropsRequest
 */
export const GetJobPropsRequest = new GetJobPropsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetJobPropsResponse$Type extends MessageType<GetJobPropsResponse> {
    constructor() {
        super("services.rector.GetJobPropsResponse", [
            { no: 1, name: "job_props", kind: "message", T: () => JobProps }
        ]);
    }
    create(value?: PartialMessage<GetJobPropsResponse>): GetJobPropsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetJobPropsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetJobPropsResponse): GetJobPropsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.users.JobProps job_props */ 1:
                    message.jobProps = JobProps.internalBinaryRead(reader, reader.uint32(), options, message.jobProps);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetJobPropsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.users.JobProps job_props = 1; */
        if (message.jobProps)
            JobProps.internalBinaryWrite(message.jobProps, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.rector.GetJobPropsResponse
 */
export const GetJobPropsResponse = new GetJobPropsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetJobPropsRequest$Type extends MessageType<SetJobPropsRequest> {
    constructor() {
        super("services.rector.SetJobPropsRequest", [
            { no: 1, name: "job_props", kind: "message", T: () => JobProps }
        ]);
    }
    create(value?: PartialMessage<SetJobPropsRequest>): SetJobPropsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetJobPropsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetJobPropsRequest): SetJobPropsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.users.JobProps job_props */ 1:
                    message.jobProps = JobProps.internalBinaryRead(reader, reader.uint32(), options, message.jobProps);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetJobPropsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.users.JobProps job_props = 1; */
        if (message.jobProps)
            JobProps.internalBinaryWrite(message.jobProps, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.rector.SetJobPropsRequest
 */
export const SetJobPropsRequest = new SetJobPropsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetJobPropsResponse$Type extends MessageType<SetJobPropsResponse> {
    constructor() {
        super("services.rector.SetJobPropsResponse", [
            { no: 1, name: "job_props", kind: "message", T: () => JobProps }
        ]);
    }
    create(value?: PartialMessage<SetJobPropsResponse>): SetJobPropsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetJobPropsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetJobPropsResponse): SetJobPropsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.users.JobProps job_props */ 1:
                    message.jobProps = JobProps.internalBinaryRead(reader, reader.uint32(), options, message.jobProps);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetJobPropsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.users.JobProps job_props = 1; */
        if (message.jobProps)
            JobProps.internalBinaryWrite(message.jobProps, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.rector.SetJobPropsResponse
 */
export const SetJobPropsResponse = new SetJobPropsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetRolesRequest$Type extends MessageType<GetRolesRequest> {
    constructor() {
        super("services.rector.GetRolesRequest", [
            { no: 1, name: "lowest_rank", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<GetRolesRequest>): GetRolesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetRolesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetRolesRequest): GetRolesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool lowest_rank */ 1:
                    message.lowestRank = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetRolesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool lowest_rank = 1; */
        if (message.lowestRank !== undefined)
            writer.tag(1, WireType.Varint).bool(message.lowestRank);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.rector.GetRolesRequest
 */
export const GetRolesRequest = new GetRolesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetRolesResponse$Type extends MessageType<GetRolesResponse> {
    constructor() {
        super("services.rector.GetRolesResponse", [
            { no: 1, name: "roles", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Role }
        ]);
    }
    create(value?: PartialMessage<GetRolesResponse>): GetRolesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.roles = [];
        if (value !== undefined)
            reflectionMergePartial<GetRolesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetRolesResponse): GetRolesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated resources.permissions.Role roles */ 1:
                    message.roles.push(Role.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetRolesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated resources.permissions.Role roles = 1; */
        for (let i = 0; i < message.roles.length; i++)
            Role.internalBinaryWrite(message.roles[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.rector.GetRolesResponse
 */
export const GetRolesResponse = new GetRolesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetRoleRequest$Type extends MessageType<GetRoleRequest> {
    constructor() {
        super("services.rector.GetRoleRequest", [
            { no: 1, name: "id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 2, name: "filtered", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<GetRoleRequest>): GetRoleRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        if (value !== undefined)
            reflectionMergePartial<GetRoleRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetRoleRequest): GetRoleRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 id */ 1:
                    message.id = reader.uint64().toNumber();
                    break;
                case /* optional bool filtered */ 2:
                    message.filtered = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetRoleRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).uint64(message.id);
        /* optional bool filtered = 2; */
        if (message.filtered !== undefined)
            writer.tag(2, WireType.Varint).bool(message.filtered);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.rector.GetRoleRequest
 */
export const GetRoleRequest = new GetRoleRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetRoleResponse$Type extends MessageType<GetRoleResponse> {
    constructor() {
        super("services.rector.GetRoleResponse", [
            { no: 1, name: "role", kind: "message", T: () => Role }
        ]);
    }
    create(value?: PartialMessage<GetRoleResponse>): GetRoleResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetRoleResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetRoleResponse): GetRoleResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.permissions.Role role */ 1:
                    message.role = Role.internalBinaryRead(reader, reader.uint32(), options, message.role);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetRoleResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.permissions.Role role = 1; */
        if (message.role)
            Role.internalBinaryWrite(message.role, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.rector.GetRoleResponse
 */
export const GetRoleResponse = new GetRoleResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateRoleRequest$Type extends MessageType<CreateRoleRequest> {
    constructor() {
        super("services.rector.CreateRoleRequest", [
            { no: 1, name: "job", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxLen: "20" } } } },
            { no: 2, name: "grade", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "validate.rules": { int32: { gte: 0 } } } }
        ]);
    }
    create(value?: PartialMessage<CreateRoleRequest>): CreateRoleRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.job = "";
        message.grade = 0;
        if (value !== undefined)
            reflectionMergePartial<CreateRoleRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateRoleRequest): CreateRoleRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string job */ 1:
                    message.job = reader.string();
                    break;
                case /* int32 grade */ 2:
                    message.grade = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateRoleRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string job = 1; */
        if (message.job !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.job);
        /* int32 grade = 2; */
        if (message.grade !== 0)
            writer.tag(2, WireType.Varint).int32(message.grade);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.rector.CreateRoleRequest
 */
export const CreateRoleRequest = new CreateRoleRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateRoleResponse$Type extends MessageType<CreateRoleResponse> {
    constructor() {
        super("services.rector.CreateRoleResponse", [
            { no: 1, name: "role", kind: "message", T: () => Role }
        ]);
    }
    create(value?: PartialMessage<CreateRoleResponse>): CreateRoleResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CreateRoleResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateRoleResponse): CreateRoleResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.permissions.Role role */ 1:
                    message.role = Role.internalBinaryRead(reader, reader.uint32(), options, message.role);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateRoleResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.permissions.Role role = 1; */
        if (message.role)
            Role.internalBinaryWrite(message.role, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.rector.CreateRoleResponse
 */
export const CreateRoleResponse = new CreateRoleResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteRoleRequest$Type extends MessageType<DeleteRoleRequest> {
    constructor() {
        super("services.rector.DeleteRoleRequest", [
            { no: 1, name: "id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteRoleRequest>): DeleteRoleRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        if (value !== undefined)
            reflectionMergePartial<DeleteRoleRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteRoleRequest): DeleteRoleRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 id */ 1:
                    message.id = reader.uint64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteRoleRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).uint64(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.rector.DeleteRoleRequest
 */
export const DeleteRoleRequest = new DeleteRoleRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteRoleResponse$Type extends MessageType<DeleteRoleResponse> {
    constructor() {
        super("services.rector.DeleteRoleResponse", []);
    }
    create(value?: PartialMessage<DeleteRoleResponse>): DeleteRoleResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DeleteRoleResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteRoleResponse): DeleteRoleResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteRoleResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.rector.DeleteRoleResponse
 */
export const DeleteRoleResponse = new DeleteRoleResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateRolePermsRequest$Type extends MessageType<UpdateRolePermsRequest> {
    constructor() {
        super("services.rector.UpdateRolePermsRequest", [
            { no: 1, name: "id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 2, name: "perms", kind: "message", T: () => PermsUpdate },
            { no: 3, name: "attrs", kind: "message", T: () => AttrsUpdate }
        ]);
    }
    create(value?: PartialMessage<UpdateRolePermsRequest>): UpdateRolePermsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        if (value !== undefined)
            reflectionMergePartial<UpdateRolePermsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateRolePermsRequest): UpdateRolePermsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 id */ 1:
                    message.id = reader.uint64().toNumber();
                    break;
                case /* optional services.rector.PermsUpdate perms */ 2:
                    message.perms = PermsUpdate.internalBinaryRead(reader, reader.uint32(), options, message.perms);
                    break;
                case /* optional services.rector.AttrsUpdate attrs */ 3:
                    message.attrs = AttrsUpdate.internalBinaryRead(reader, reader.uint32(), options, message.attrs);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateRolePermsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).uint64(message.id);
        /* optional services.rector.PermsUpdate perms = 2; */
        if (message.perms)
            PermsUpdate.internalBinaryWrite(message.perms, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional services.rector.AttrsUpdate attrs = 3; */
        if (message.attrs)
            AttrsUpdate.internalBinaryWrite(message.attrs, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.rector.UpdateRolePermsRequest
 */
export const UpdateRolePermsRequest = new UpdateRolePermsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PermsUpdate$Type extends MessageType<PermsUpdate> {
    constructor() {
        super("services.rector.PermsUpdate", [
            { no: 1, name: "to_update", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PermItem },
            { no: 2, name: "to_remove", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<PermsUpdate>): PermsUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.toUpdate = [];
        message.toRemove = [];
        if (value !== undefined)
            reflectionMergePartial<PermsUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PermsUpdate): PermsUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated services.rector.PermItem to_update */ 1:
                    message.toUpdate.push(PermItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated uint64 to_remove */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.toRemove.push(reader.uint64().toNumber());
                    else
                        message.toRemove.push(reader.uint64().toNumber());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PermsUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated services.rector.PermItem to_update = 1; */
        for (let i = 0; i < message.toUpdate.length; i++)
            PermItem.internalBinaryWrite(message.toUpdate[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated uint64 to_remove = 2; */
        if (message.toRemove.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.toRemove.length; i++)
                writer.uint64(message.toRemove[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.rector.PermsUpdate
 */
export const PermsUpdate = new PermsUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PermItem$Type extends MessageType<PermItem> {
    constructor() {
        super("services.rector.PermItem", [
            { no: 1, name: "id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 2, name: "val", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<PermItem>): PermItem {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.val = false;
        if (value !== undefined)
            reflectionMergePartial<PermItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PermItem): PermItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 id */ 1:
                    message.id = reader.uint64().toNumber();
                    break;
                case /* bool val */ 2:
                    message.val = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PermItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).uint64(message.id);
        /* bool val = 2; */
        if (message.val !== false)
            writer.tag(2, WireType.Varint).bool(message.val);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.rector.PermItem
 */
export const PermItem = new PermItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AttrsUpdate$Type extends MessageType<AttrsUpdate> {
    constructor() {
        super("services.rector.AttrsUpdate", [
            { no: 1, name: "to_update", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => RoleAttribute },
            { no: 2, name: "to_remove", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => RoleAttribute }
        ]);
    }
    create(value?: PartialMessage<AttrsUpdate>): AttrsUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.toUpdate = [];
        message.toRemove = [];
        if (value !== undefined)
            reflectionMergePartial<AttrsUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AttrsUpdate): AttrsUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated resources.permissions.RoleAttribute to_update */ 1:
                    message.toUpdate.push(RoleAttribute.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated resources.permissions.RoleAttribute to_remove */ 2:
                    message.toRemove.push(RoleAttribute.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AttrsUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated resources.permissions.RoleAttribute to_update = 1; */
        for (let i = 0; i < message.toUpdate.length; i++)
            RoleAttribute.internalBinaryWrite(message.toUpdate[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated resources.permissions.RoleAttribute to_remove = 2; */
        for (let i = 0; i < message.toRemove.length; i++)
            RoleAttribute.internalBinaryWrite(message.toRemove[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.rector.AttrsUpdate
 */
export const AttrsUpdate = new AttrsUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateRolePermsResponse$Type extends MessageType<UpdateRolePermsResponse> {
    constructor() {
        super("services.rector.UpdateRolePermsResponse", []);
    }
    create(value?: PartialMessage<UpdateRolePermsResponse>): UpdateRolePermsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UpdateRolePermsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateRolePermsResponse): UpdateRolePermsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateRolePermsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.rector.UpdateRolePermsResponse
 */
export const UpdateRolePermsResponse = new UpdateRolePermsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPermissionsRequest$Type extends MessageType<GetPermissionsRequest> {
    constructor() {
        super("services.rector.GetPermissionsRequest", [
            { no: 1, name: "role_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 2, name: "filtered", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<GetPermissionsRequest>): GetPermissionsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.roleId = 0;
        if (value !== undefined)
            reflectionMergePartial<GetPermissionsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPermissionsRequest): GetPermissionsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 role_id */ 1:
                    message.roleId = reader.uint64().toNumber();
                    break;
                case /* optional bool filtered */ 2:
                    message.filtered = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPermissionsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 role_id = 1; */
        if (message.roleId !== 0)
            writer.tag(1, WireType.Varint).uint64(message.roleId);
        /* optional bool filtered = 2; */
        if (message.filtered !== undefined)
            writer.tag(2, WireType.Varint).bool(message.filtered);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.rector.GetPermissionsRequest
 */
export const GetPermissionsRequest = new GetPermissionsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPermissionsResponse$Type extends MessageType<GetPermissionsResponse> {
    constructor() {
        super("services.rector.GetPermissionsResponse", [
            { no: 1, name: "permissions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Permission },
            { no: 2, name: "attributes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => RoleAttribute }
        ]);
    }
    create(value?: PartialMessage<GetPermissionsResponse>): GetPermissionsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.permissions = [];
        message.attributes = [];
        if (value !== undefined)
            reflectionMergePartial<GetPermissionsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPermissionsResponse): GetPermissionsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated resources.permissions.Permission permissions */ 1:
                    message.permissions.push(Permission.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated resources.permissions.RoleAttribute attributes */ 2:
                    message.attributes.push(RoleAttribute.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPermissionsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated resources.permissions.Permission permissions = 1; */
        for (let i = 0; i < message.permissions.length; i++)
            Permission.internalBinaryWrite(message.permissions[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated resources.permissions.RoleAttribute attributes = 2; */
        for (let i = 0; i < message.attributes.length; i++)
            RoleAttribute.internalBinaryWrite(message.attributes[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.rector.GetPermissionsResponse
 */
export const GetPermissionsResponse = new GetPermissionsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetEffectivePermissionsRequest$Type extends MessageType<GetEffectivePermissionsRequest> {
    constructor() {
        super("services.rector.GetEffectivePermissionsRequest", [
            { no: 1, name: "role_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<GetEffectivePermissionsRequest>): GetEffectivePermissionsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.roleId = 0;
        if (value !== undefined)
            reflectionMergePartial<GetEffectivePermissionsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetEffectivePermissionsRequest): GetEffectivePermissionsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 role_id */ 1:
                    message.roleId = reader.uint64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetEffectivePermissionsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 role_id = 1; */
        if (message.roleId !== 0)
            writer.tag(1, WireType.Varint).uint64(message.roleId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.rector.GetEffectivePermissionsRequest
 */
export const GetEffectivePermissionsRequest = new GetEffectivePermissionsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetEffectivePermissionsResponse$Type extends MessageType<GetEffectivePermissionsResponse> {
    constructor() {
        super("services.rector.GetEffectivePermissionsResponse", [
            { no: 1, name: "role", kind: "message", T: () => Role },
            { no: 2, name: "permissions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Permission },
            { no: 3, name: "attributes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => RoleAttribute }
        ]);
    }
    create(value?: PartialMessage<GetEffectivePermissionsResponse>): GetEffectivePermissionsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.permissions = [];
        message.attributes = [];
        if (value !== undefined)
            reflectionMergePartial<GetEffectivePermissionsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetEffectivePermissionsResponse): GetEffectivePermissionsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.permissions.Role role */ 1:
                    message.role = Role.internalBinaryRead(reader, reader.uint32(), options, message.role);
                    break;
                case /* repeated resources.permissions.Permission permissions */ 2:
                    message.permissions.push(Permission.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated resources.permissions.RoleAttribute attributes */ 3:
                    message.attributes.push(RoleAttribute.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetEffectivePermissionsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.permissions.Role role = 1; */
        if (message.role)
            Role.internalBinaryWrite(message.role, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated resources.permissions.Permission permissions = 2; */
        for (let i = 0; i < message.permissions.length; i++)
            Permission.internalBinaryWrite(message.permissions[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated resources.permissions.RoleAttribute attributes = 3; */
        for (let i = 0; i < message.attributes.length; i++)
            RoleAttribute.internalBinaryWrite(message.attributes[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.rector.GetEffectivePermissionsResponse
 */
export const GetEffectivePermissionsResponse = new GetEffectivePermissionsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ViewAuditLogRequest$Type extends MessageType<ViewAuditLogRequest> {
    constructor() {
        super("services.rector.ViewAuditLogRequest", [
            { no: 1, name: "pagination", kind: "message", T: () => PaginationRequest, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "sort", kind: "message", T: () => Sort },
            { no: 3, name: "user_ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "from", kind: "message", T: () => Timestamp },
            { no: 5, name: "to", kind: "message", T: () => Timestamp },
            { no: 6, name: "services", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { repeated: { maxItems: "10", items: { string: { maxLen: "64" } } } } } },
            { no: 7, name: "methods", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { repeated: { maxItems: "10", items: { string: { maxLen: "64" } } } } } },
            { no: 8, name: "search", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxLen: "64" } } } }
        ]);
    }
    create(value?: PartialMessage<ViewAuditLogRequest>): ViewAuditLogRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userIds = [];
        message.services = [];
        message.methods = [];
        if (value !== undefined)
            reflectionMergePartial<ViewAuditLogRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ViewAuditLogRequest): ViewAuditLogRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.common.database.PaginationRequest pagination */ 1:
                    message.pagination = PaginationRequest.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                case /* optional resources.common.database.Sort sort */ 2:
                    message.sort = Sort.internalBinaryRead(reader, reader.uint32(), options, message.sort);
                    break;
                case /* repeated int32 user_ids */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.userIds.push(reader.int32());
                    else
                        message.userIds.push(reader.int32());
                    break;
                case /* optional resources.timestamp.Timestamp from */ 4:
                    message.from = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.from);
                    break;
                case /* optional resources.timestamp.Timestamp to */ 5:
                    message.to = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.to);
                    break;
                case /* repeated string services */ 6:
                    message.services.push(reader.string());
                    break;
                case /* repeated string methods */ 7:
                    message.methods.push(reader.string());
                    break;
                case /* optional string search */ 8:
                    message.search = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ViewAuditLogRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.common.database.PaginationRequest pagination = 1; */
        if (message.pagination)
            PaginationRequest.internalBinaryWrite(message.pagination, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional resources.common.database.Sort sort = 2; */
        if (message.sort)
            Sort.internalBinaryWrite(message.sort, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated int32 user_ids = 3; */
        if (message.userIds.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.userIds.length; i++)
                writer.int32(message.userIds[i]);
            writer.join();
        }
        /* optional resources.timestamp.Timestamp from = 4; */
        if (message.from)
            Timestamp.internalBinaryWrite(message.from, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional resources.timestamp.Timestamp to = 5; */
        if (message.to)
            Timestamp.internalBinaryWrite(message.to, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated string services = 6; */
        for (let i = 0; i < message.services.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.services[i]);
        /* repeated string methods = 7; */
        for (let i = 0; i < message.methods.length; i++)
            writer.tag(7, WireType.LengthDelimited).string(message.methods[i]);
        /* optional string search = 8; */
        if (message.search !== undefined)
            writer.tag(8, WireType.LengthDelimited).string(message.search);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.rector.ViewAuditLogRequest
 */
export const ViewAuditLogRequest = new ViewAuditLogRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ViewAuditLogResponse$Type extends MessageType<ViewAuditLogResponse> {
    constructor() {
        super("services.rector.ViewAuditLogResponse", [
            { no: 1, name: "pagination", kind: "message", T: () => PaginationResponse },
            { no: 2, name: "logs", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => AuditEntry }
        ]);
    }
    create(value?: PartialMessage<ViewAuditLogResponse>): ViewAuditLogResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.logs = [];
        if (value !== undefined)
            reflectionMergePartial<ViewAuditLogResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ViewAuditLogResponse): ViewAuditLogResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.common.database.PaginationResponse pagination */ 1:
                    message.pagination = PaginationResponse.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                case /* repeated resources.rector.AuditEntry logs */ 2:
                    message.logs.push(AuditEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ViewAuditLogResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.common.database.PaginationResponse pagination = 1; */
        if (message.pagination)
            PaginationResponse.internalBinaryWrite(message.pagination, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated resources.rector.AuditEntry logs = 2; */
        for (let i = 0; i < message.logs.length; i++)
            AuditEntry.internalBinaryWrite(message.logs[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.rector.ViewAuditLogResponse
 */
export const ViewAuditLogResponse = new ViewAuditLogResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAllPermissionsRequest$Type extends MessageType<GetAllPermissionsRequest> {
    constructor() {
        super("services.rector.GetAllPermissionsRequest", [
            { no: 1, name: "job", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxLen: "20" } } } }
        ]);
    }
    create(value?: PartialMessage<GetAllPermissionsRequest>): GetAllPermissionsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.job = "";
        if (value !== undefined)
            reflectionMergePartial<GetAllPermissionsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAllPermissionsRequest): GetAllPermissionsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string job */ 1:
                    message.job = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAllPermissionsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string job = 1; */
        if (message.job !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.job);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.rector.GetAllPermissionsRequest
 */
export const GetAllPermissionsRequest = new GetAllPermissionsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAllPermissionsResponse$Type extends MessageType<GetAllPermissionsResponse> {
    constructor() {
        super("services.rector.GetAllPermissionsResponse", [
            { no: 1, name: "permissions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Permission },
            { no: 2, name: "attributes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => RoleAttribute }
        ]);
    }
    create(value?: PartialMessage<GetAllPermissionsResponse>): GetAllPermissionsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.permissions = [];
        message.attributes = [];
        if (value !== undefined)
            reflectionMergePartial<GetAllPermissionsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAllPermissionsResponse): GetAllPermissionsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated resources.permissions.Permission permissions */ 1:
                    message.permissions.push(Permission.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated resources.permissions.RoleAttribute attributes */ 2:
                    message.attributes.push(RoleAttribute.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAllPermissionsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated resources.permissions.Permission permissions = 1; */
        for (let i = 0; i < message.permissions.length; i++)
            Permission.internalBinaryWrite(message.permissions[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated resources.permissions.RoleAttribute attributes = 2; */
        for (let i = 0; i < message.attributes.length; i++)
            RoleAttribute.internalBinaryWrite(message.attributes[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.rector.GetAllPermissionsResponse
 */
export const GetAllPermissionsResponse = new GetAllPermissionsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetJobLimitsRequest$Type extends MessageType<GetJobLimitsRequest> {
    constructor() {
        super("services.rector.GetJobLimitsRequest", [
            { no: 1, name: "job", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxLen: "20" } } } }
        ]);
    }
    create(value?: PartialMessage<GetJobLimitsRequest>): GetJobLimitsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.job = "";
        if (value !== undefined)
            reflectionMergePartial<GetJobLimitsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetJobLimitsRequest): GetJobLimitsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string job */ 1:
                    message.job = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetJobLimitsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string job = 1; */
        if (message.job !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.job);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.rector.GetJobLimitsRequest
 */
export const GetJobLimitsRequest = new GetJobLimitsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetJobLimitsResponse$Type extends MessageType<GetJobLimitsResponse> {
    constructor() {
        super("services.rector.GetJobLimitsResponse", [
            { no: 1, name: "job", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxLen: "20" } } } },
            { no: 2, name: "job_label", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "permissions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Permission },
            { no: 4, name: "attributes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => RoleAttribute }
        ]);
    }
    create(value?: PartialMessage<GetJobLimitsResponse>): GetJobLimitsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.job = "";
        message.permissions = [];
        message.attributes = [];
        if (value !== undefined)
            reflectionMergePartial<GetJobLimitsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetJobLimitsResponse): GetJobLimitsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string job */ 1:
                    message.job = reader.string();
                    break;
                case /* optional string job_label */ 2:
                    message.jobLabel = reader.string();
                    break;
                case /* repeated resources.permissions.Permission permissions */ 3:
                    message.permissions.push(Permission.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated resources.permissions.RoleAttribute attributes */ 4:
                    message.attributes.push(RoleAttribute.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetJobLimitsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string job = 1; */
        if (message.job !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.job);
        /* optional string job_label = 2; */
        if (message.jobLabel !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.jobLabel);
        /* repeated resources.permissions.Permission permissions = 3; */
        for (let i = 0; i < message.permissions.length; i++)
            Permission.internalBinaryWrite(message.permissions[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated resources.permissions.RoleAttribute attributes = 4; */
        for (let i = 0; i < message.attributes.length; i++)
            RoleAttribute.internalBinaryWrite(message.attributes[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.rector.GetJobLimitsResponse
 */
export const GetJobLimitsResponse = new GetJobLimitsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateJobLimitsRequest$Type extends MessageType<UpdateJobLimitsRequest> {
    constructor() {
        super("services.rector.UpdateJobLimitsRequest", [
            { no: 1, name: "job", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxLen: "20" } } } },
            { no: 2, name: "perms", kind: "message", T: () => PermsUpdate },
            { no: 3, name: "attrs", kind: "message", T: () => AttrsUpdate }
        ]);
    }
    create(value?: PartialMessage<UpdateJobLimitsRequest>): UpdateJobLimitsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.job = "";
        if (value !== undefined)
            reflectionMergePartial<UpdateJobLimitsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateJobLimitsRequest): UpdateJobLimitsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string job */ 1:
                    message.job = reader.string();
                    break;
                case /* optional services.rector.PermsUpdate perms */ 2:
                    message.perms = PermsUpdate.internalBinaryRead(reader, reader.uint32(), options, message.perms);
                    break;
                case /* optional services.rector.AttrsUpdate attrs */ 3:
                    message.attrs = AttrsUpdate.internalBinaryRead(reader, reader.uint32(), options, message.attrs);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateJobLimitsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string job = 1; */
        if (message.job !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.job);
        /* optional services.rector.PermsUpdate perms = 2; */
        if (message.perms)
            PermsUpdate.internalBinaryWrite(message.perms, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional services.rector.AttrsUpdate attrs = 3; */
        if (message.attrs)
            AttrsUpdate.internalBinaryWrite(message.attrs, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.rector.UpdateJobLimitsRequest
 */
export const UpdateJobLimitsRequest = new UpdateJobLimitsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateJobLimitsResponse$Type extends MessageType<UpdateJobLimitsResponse> {
    constructor() {
        super("services.rector.UpdateJobLimitsResponse", []);
    }
    create(value?: PartialMessage<UpdateJobLimitsResponse>): UpdateJobLimitsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UpdateJobLimitsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateJobLimitsResponse): UpdateJobLimitsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateJobLimitsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.rector.UpdateJobLimitsResponse
 */
export const UpdateJobLimitsResponse = new UpdateJobLimitsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteFactionRequest$Type extends MessageType<DeleteFactionRequest> {
    constructor() {
        super("services.rector.DeleteFactionRequest", [
            { no: 1, name: "job", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxLen: "20" } } } }
        ]);
    }
    create(value?: PartialMessage<DeleteFactionRequest>): DeleteFactionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.job = "";
        if (value !== undefined)
            reflectionMergePartial<DeleteFactionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteFactionRequest): DeleteFactionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string job */ 1:
                    message.job = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteFactionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string job = 1; */
        if (message.job !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.job);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.rector.DeleteFactionRequest
 */
export const DeleteFactionRequest = new DeleteFactionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteFactionResponse$Type extends MessageType<DeleteFactionResponse> {
    constructor() {
        super("services.rector.DeleteFactionResponse", []);
    }
    create(value?: PartialMessage<DeleteFactionResponse>): DeleteFactionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DeleteFactionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteFactionResponse): DeleteFactionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteFactionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message services.rector.DeleteFactionResponse
 */
export const DeleteFactionResponse = new DeleteFactionResponse$Type();
/**
 * @generated ServiceType for protobuf service services.rector.RectorService
 */
export const RectorService = new ServiceType("services.rector.RectorService", [
    { name: "GetJobProps", options: {}, I: GetJobPropsRequest, O: GetJobPropsResponse },
    { name: "SetJobProps", options: {}, I: SetJobPropsRequest, O: SetJobPropsResponse },
    { name: "GetRoles", options: {}, I: GetRolesRequest, O: GetRolesResponse },
    { name: "GetRole", options: {}, I: GetRoleRequest, O: GetRoleResponse },
    { name: "CreateRole", options: {}, I: CreateRoleRequest, O: CreateRoleResponse },
    { name: "DeleteRole", options: {}, I: DeleteRoleRequest, O: DeleteRoleResponse },
    { name: "UpdateRolePerms", options: {}, I: UpdateRolePermsRequest, O: UpdateRolePermsResponse },
    { name: "GetPermissions", options: {}, I: GetPermissionsRequest, O: GetPermissionsResponse },
    { name: "GetEffectivePermissions", options: {}, I: GetEffectivePermissionsRequest, O: GetEffectivePermissionsResponse },
    { name: "ViewAuditLog", options: {}, I: ViewAuditLogRequest, O: ViewAuditLogResponse },
    { name: "GetAllPermissions", options: {}, I: GetAllPermissionsRequest, O: GetAllPermissionsResponse },
    { name: "GetJobLimits", options: {}, I: GetJobLimitsRequest, O: GetJobLimitsResponse },
    { name: "UpdateJobLimits", options: {}, I: UpdateJobLimitsRequest, O: UpdateJobLimitsResponse },
    { name: "DeleteFaction", options: {}, I: DeleteFactionRequest, O: DeleteFactionResponse }
]);
