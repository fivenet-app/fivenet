// @generated by protobuf-ts 2.11.0 with parameter optimize_speed,long_type_number,force_server_none
// @generated from protobuf file "resources/settings/config.proto" (package "resources.settings", syntax proto3)
// @ts-nocheck
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { BannerMessage } from "./banner";
import { Duration } from "../../google/protobuf/duration";
/**
 * @dbscanner: json,partial
 *
 * @generated from protobuf message resources.settings.AppConfig
 */
export interface AppConfig {
    /**
     * @generated from protobuf field: optional string version = 1
     */
    version?: string;
    /**
     * @generated from protobuf field: string default_locale = 8
     */
    defaultLocale: string;
    /**
     * @generated from protobuf field: resources.settings.Auth auth = 2
     */
    auth?: Auth;
    /**
     * @generated from protobuf field: resources.settings.Perms perms = 3
     */
    perms?: Perms;
    /**
     * @generated from protobuf field: resources.settings.Website website = 4
     */
    website?: Website;
    /**
     * @generated from protobuf field: resources.settings.JobInfo job_info = 5
     */
    jobInfo?: JobInfo;
    /**
     * @generated from protobuf field: resources.settings.UserTracker user_tracker = 6
     */
    userTracker?: UserTracker;
    /**
     * @generated from protobuf field: resources.settings.Discord discord = 7
     */
    discord?: Discord;
    /**
     * @generated from protobuf field: resources.settings.System system = 9
     */
    system?: System;
}
/**
 * @generated from protobuf message resources.settings.Auth
 */
export interface Auth {
    /**
     * @generated from protobuf field: bool signup_enabled = 1
     */
    signupEnabled: boolean;
    /**
     * @generated from protobuf field: bool last_char_lock = 2
     */
    lastCharLock: boolean;
}
/**
 * @generated from protobuf message resources.settings.Perms
 */
export interface Perms {
    /**
     * @generated from protobuf field: repeated resources.settings.Perm default = 1
     */
    default: Perm[];
}
/**
 * @generated from protobuf message resources.settings.Perm
 */
export interface Perm {
    /**
     * @sanitize: method=StripTags
     *
     * @generated from protobuf field: string category = 1
     */
    category: string;
    /**
     * @sanitize: method=StripTags
     *
     * @generated from protobuf field: string name = 2
     */
    name: string;
}
/**
 * @generated from protobuf message resources.settings.Website
 */
export interface Website {
    /**
     * @generated from protobuf field: resources.settings.Links links = 1
     */
    links?: Links;
    /**
     * @generated from protobuf field: bool stats_page = 2
     */
    statsPage: boolean;
}
/**
 * @generated from protobuf message resources.settings.Links
 */
export interface Links {
    /**
     * @sanitize: method=StripTags
     *
     * @generated from protobuf field: optional string privacy_policy = 1
     */
    privacyPolicy?: string;
    /**
     * @sanitize: method=StripTags
     *
     * @generated from protobuf field: optional string imprint = 2
     */
    imprint?: string;
}
/**
 * @generated from protobuf message resources.settings.JobInfo
 */
export interface JobInfo {
    /**
     * @generated from protobuf field: resources.settings.UnemployedJob unemployed_job = 1
     */
    unemployedJob?: UnemployedJob;
    /**
     * @sanitize: method=StripTags
     *
     * @generated from protobuf field: repeated string public_jobs = 2
     */
    publicJobs: string[];
    /**
     * @sanitize: method=StripTags
     *
     * @generated from protobuf field: repeated string hidden_jobs = 3
     */
    hiddenJobs: string[];
}
/**
 * @generated from protobuf message resources.settings.UnemployedJob
 */
export interface UnemployedJob {
    /**
     * @generated from protobuf field: string name = 1
     */
    name: string;
    /**
     * @generated from protobuf field: int32 grade = 2
     */
    grade: number;
}
/**
 * @generated from protobuf message resources.settings.UserTracker
 */
export interface UserTracker {
    /**
     * @generated from protobuf field: google.protobuf.Duration refresh_time = 1
     */
    refreshTime?: Duration;
    /**
     * @generated from protobuf field: google.protobuf.Duration db_refresh_time = 2
     */
    dbRefreshTime?: Duration;
}
/**
 * @generated from protobuf message resources.settings.Discord
 */
export interface Discord {
    /**
     * @generated from protobuf field: bool enabled = 1
     */
    enabled: boolean;
    /**
     * @generated from protobuf field: google.protobuf.Duration sync_interval = 2
     */
    syncInterval?: Duration;
    /**
     * @sanitize: method=StripTags
     *
     * @generated from protobuf field: optional string invite_url = 3
     */
    inviteUrl?: string;
    /**
     * @sanitize: method=StripTags
     *
     * @generated from protobuf field: repeated string ignored_jobs = 4
     */
    ignoredJobs: string[];
    /**
     * @generated from protobuf field: optional resources.settings.DiscordBotPresence bot_presence = 5
     */
    botPresence?: DiscordBotPresence;
    /**
     * @sanitize: method=StripTags
     *
     * @generated from protobuf field: optional string bot_id = 6
     */
    botId?: string;
    /**
     * @generated from protobuf field: int64 bot_permissions = 7
     */
    botPermissions: number;
}
/**
 * @generated from protobuf message resources.settings.DiscordBotPresence
 */
export interface DiscordBotPresence {
    /**
     * @generated from protobuf field: resources.settings.DiscordBotPresenceType type = 1
     */
    type: DiscordBotPresenceType;
    /**
     * @sanitize: method=StripTags
     *
     * @generated from protobuf field: optional string status = 2
     */
    status?: string;
    /**
     * @sanitize: method=StripTags
     *
     * @generated from protobuf field: optional string url = 3
     */
    url?: string;
}
/**
 * @generated from protobuf message resources.settings.System
 */
export interface System {
    /**
     * @generated from protobuf field: bool banner_message_enabled = 1
     */
    bannerMessageEnabled: boolean;
    /**
     * @generated from protobuf field: resources.settings.BannerMessage banner_message = 2
     */
    bannerMessage?: BannerMessage;
}
/**
 * @generated from protobuf enum resources.settings.DiscordBotPresenceType
 */
export enum DiscordBotPresenceType {
    /**
     * @generated from protobuf enum value: DISCORD_BOT_PRESENCE_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: DISCORD_BOT_PRESENCE_TYPE_GAME = 1;
     */
    GAME = 1,
    /**
     * @generated from protobuf enum value: DISCORD_BOT_PRESENCE_TYPE_LISTENING = 2;
     */
    LISTENING = 2,
    /**
     * @generated from protobuf enum value: DISCORD_BOT_PRESENCE_TYPE_STREAMING = 3;
     */
    STREAMING = 3,
    /**
     * @generated from protobuf enum value: DISCORD_BOT_PRESENCE_TYPE_WATCH = 4;
     */
    WATCH = 4
}
// @generated message type with reflection information, may provide speed optimized methods
class AppConfig$Type extends MessageType<AppConfig> {
    constructor() {
        super("resources.settings.AppConfig", [
            { no: 1, name: "version", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "default_locale", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxLen: "20" } } } },
            { no: 2, name: "auth", kind: "message", T: () => Auth },
            { no: 3, name: "perms", kind: "message", T: () => Perms },
            { no: 4, name: "website", kind: "message", T: () => Website },
            { no: 5, name: "job_info", kind: "message", T: () => JobInfo },
            { no: 6, name: "user_tracker", kind: "message", T: () => UserTracker },
            { no: 7, name: "discord", kind: "message", T: () => Discord },
            { no: 9, name: "system", kind: "message", T: () => System }
        ]);
    }
    create(value?: PartialMessage<AppConfig>): AppConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.defaultLocale = "";
        if (value !== undefined)
            reflectionMergePartial<AppConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppConfig): AppConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string version */ 1:
                    message.version = reader.string();
                    break;
                case /* string default_locale */ 8:
                    message.defaultLocale = reader.string();
                    break;
                case /* resources.settings.Auth auth */ 2:
                    message.auth = Auth.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                case /* resources.settings.Perms perms */ 3:
                    message.perms = Perms.internalBinaryRead(reader, reader.uint32(), options, message.perms);
                    break;
                case /* resources.settings.Website website */ 4:
                    message.website = Website.internalBinaryRead(reader, reader.uint32(), options, message.website);
                    break;
                case /* resources.settings.JobInfo job_info */ 5:
                    message.jobInfo = JobInfo.internalBinaryRead(reader, reader.uint32(), options, message.jobInfo);
                    break;
                case /* resources.settings.UserTracker user_tracker */ 6:
                    message.userTracker = UserTracker.internalBinaryRead(reader, reader.uint32(), options, message.userTracker);
                    break;
                case /* resources.settings.Discord discord */ 7:
                    message.discord = Discord.internalBinaryRead(reader, reader.uint32(), options, message.discord);
                    break;
                case /* resources.settings.System system */ 9:
                    message.system = System.internalBinaryRead(reader, reader.uint32(), options, message.system);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string version = 1; */
        if (message.version !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.version);
        /* resources.settings.Auth auth = 2; */
        if (message.auth)
            Auth.internalBinaryWrite(message.auth, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* resources.settings.Perms perms = 3; */
        if (message.perms)
            Perms.internalBinaryWrite(message.perms, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* resources.settings.Website website = 4; */
        if (message.website)
            Website.internalBinaryWrite(message.website, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* resources.settings.JobInfo job_info = 5; */
        if (message.jobInfo)
            JobInfo.internalBinaryWrite(message.jobInfo, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* resources.settings.UserTracker user_tracker = 6; */
        if (message.userTracker)
            UserTracker.internalBinaryWrite(message.userTracker, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* resources.settings.Discord discord = 7; */
        if (message.discord)
            Discord.internalBinaryWrite(message.discord, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* string default_locale = 8; */
        if (message.defaultLocale !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.defaultLocale);
        /* resources.settings.System system = 9; */
        if (message.system)
            System.internalBinaryWrite(message.system, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message resources.settings.AppConfig
 */
export const AppConfig = new AppConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Auth$Type extends MessageType<Auth> {
    constructor() {
        super("resources.settings.Auth", [
            { no: 1, name: "signup_enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "last_char_lock", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Auth>): Auth {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.signupEnabled = false;
        message.lastCharLock = false;
        if (value !== undefined)
            reflectionMergePartial<Auth>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Auth): Auth {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool signup_enabled */ 1:
                    message.signupEnabled = reader.bool();
                    break;
                case /* bool last_char_lock */ 2:
                    message.lastCharLock = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Auth, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool signup_enabled = 1; */
        if (message.signupEnabled !== false)
            writer.tag(1, WireType.Varint).bool(message.signupEnabled);
        /* bool last_char_lock = 2; */
        if (message.lastCharLock !== false)
            writer.tag(2, WireType.Varint).bool(message.lastCharLock);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message resources.settings.Auth
 */
export const Auth = new Auth$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Perms$Type extends MessageType<Perms> {
    constructor() {
        super("resources.settings.Perms", [
            { no: 1, name: "default", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Perm, options: { "validate.rules": { repeated: { maxItems: "100" } } } }
        ]);
    }
    create(value?: PartialMessage<Perms>): Perms {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.default = [];
        if (value !== undefined)
            reflectionMergePartial<Perms>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Perms): Perms {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated resources.settings.Perm default */ 1:
                    message.default.push(Perm.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Perms, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated resources.settings.Perm default = 1; */
        for (let i = 0; i < message.default.length; i++)
            Perm.internalBinaryWrite(message.default[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message resources.settings.Perms
 */
export const Perms = new Perms$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Perm$Type extends MessageType<Perm> {
    constructor() {
        super("resources.settings.Perm", [
            { no: 1, name: "category", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxLen: "128" } } } },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxLen: "255" } } } }
        ]);
    }
    create(value?: PartialMessage<Perm>): Perm {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.category = "";
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<Perm>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Perm): Perm {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string category */ 1:
                    message.category = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Perm, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string category = 1; */
        if (message.category !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.category);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message resources.settings.Perm
 */
export const Perm = new Perm$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Website$Type extends MessageType<Website> {
    constructor() {
        super("resources.settings.Website", [
            { no: 1, name: "links", kind: "message", T: () => Links },
            { no: 2, name: "stats_page", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Website>): Website {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.statsPage = false;
        if (value !== undefined)
            reflectionMergePartial<Website>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Website): Website {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.settings.Links links */ 1:
                    message.links = Links.internalBinaryRead(reader, reader.uint32(), options, message.links);
                    break;
                case /* bool stats_page */ 2:
                    message.statsPage = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Website, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.settings.Links links = 1; */
        if (message.links)
            Links.internalBinaryWrite(message.links, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool stats_page = 2; */
        if (message.statsPage !== false)
            writer.tag(2, WireType.Varint).bool(message.statsPage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message resources.settings.Website
 */
export const Website = new Website$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Links$Type extends MessageType<Links> {
    constructor() {
        super("resources.settings.Links", [
            { no: 1, name: "privacy_policy", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxLen: "255" } } } },
            { no: 2, name: "imprint", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxLen: "255" } } } }
        ]);
    }
    create(value?: PartialMessage<Links>): Links {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Links>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Links): Links {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string privacy_policy */ 1:
                    message.privacyPolicy = reader.string();
                    break;
                case /* optional string imprint */ 2:
                    message.imprint = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Links, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string privacy_policy = 1; */
        if (message.privacyPolicy !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.privacyPolicy);
        /* optional string imprint = 2; */
        if (message.imprint !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.imprint);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message resources.settings.Links
 */
export const Links = new Links$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JobInfo$Type extends MessageType<JobInfo> {
    constructor() {
        super("resources.settings.JobInfo", [
            { no: 1, name: "unemployed_job", kind: "message", T: () => UnemployedJob, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "public_jobs", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { repeated: { maxItems: "100" } } } },
            { no: 3, name: "hidden_jobs", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { repeated: { maxItems: "100" } } } }
        ]);
    }
    create(value?: PartialMessage<JobInfo>): JobInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.publicJobs = [];
        message.hiddenJobs = [];
        if (value !== undefined)
            reflectionMergePartial<JobInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JobInfo): JobInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.settings.UnemployedJob unemployed_job */ 1:
                    message.unemployedJob = UnemployedJob.internalBinaryRead(reader, reader.uint32(), options, message.unemployedJob);
                    break;
                case /* repeated string public_jobs */ 2:
                    message.publicJobs.push(reader.string());
                    break;
                case /* repeated string hidden_jobs */ 3:
                    message.hiddenJobs.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JobInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.settings.UnemployedJob unemployed_job = 1; */
        if (message.unemployedJob)
            UnemployedJob.internalBinaryWrite(message.unemployedJob, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated string public_jobs = 2; */
        for (let i = 0; i < message.publicJobs.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.publicJobs[i]);
        /* repeated string hidden_jobs = 3; */
        for (let i = 0; i < message.hiddenJobs.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.hiddenJobs[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message resources.settings.JobInfo
 */
export const JobInfo = new JobInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UnemployedJob$Type extends MessageType<UnemployedJob> {
    constructor() {
        super("resources.settings.UnemployedJob", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxLen: "20" } } } },
            { no: 2, name: "grade", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "validate.rules": { int32: { gte: 0 } } } }
        ]);
    }
    create(value?: PartialMessage<UnemployedJob>): UnemployedJob {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.grade = 0;
        if (value !== undefined)
            reflectionMergePartial<UnemployedJob>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UnemployedJob): UnemployedJob {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* int32 grade */ 2:
                    message.grade = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UnemployedJob, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* int32 grade = 2; */
        if (message.grade !== 0)
            writer.tag(2, WireType.Varint).int32(message.grade);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message resources.settings.UnemployedJob
 */
export const UnemployedJob = new UnemployedJob$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserTracker$Type extends MessageType<UserTracker> {
    constructor() {
        super("resources.settings.UserTracker", [
            { no: 1, name: "refresh_time", kind: "message", T: () => Duration, options: { "validate.rules": { duration: { required: true, lt: { seconds: "60" }, gte: { nanos: 500000000 } } } } },
            { no: 2, name: "db_refresh_time", kind: "message", T: () => Duration, options: { "validate.rules": { duration: { required: true, lt: { seconds: "60" }, gte: { nanos: 500000000 } } } } }
        ]);
    }
    create(value?: PartialMessage<UserTracker>): UserTracker {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UserTracker>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserTracker): UserTracker {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Duration refresh_time */ 1:
                    message.refreshTime = Duration.internalBinaryRead(reader, reader.uint32(), options, message.refreshTime);
                    break;
                case /* google.protobuf.Duration db_refresh_time */ 2:
                    message.dbRefreshTime = Duration.internalBinaryRead(reader, reader.uint32(), options, message.dbRefreshTime);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserTracker, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Duration refresh_time = 1; */
        if (message.refreshTime)
            Duration.internalBinaryWrite(message.refreshTime, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration db_refresh_time = 2; */
        if (message.dbRefreshTime)
            Duration.internalBinaryWrite(message.dbRefreshTime, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message resources.settings.UserTracker
 */
export const UserTracker = new UserTracker$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Discord$Type extends MessageType<Discord> {
    constructor() {
        super("resources.settings.Discord", [
            { no: 1, name: "enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "sync_interval", kind: "message", T: () => Duration, options: { "validate.rules": { duration: { required: true, lt: { seconds: "180000000" }, gte: { seconds: "60" } } } } },
            { no: 3, name: "invite_url", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxLen: "255" } } } },
            { no: 4, name: "ignored_jobs", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { repeated: { maxItems: "100" } } } },
            { no: 5, name: "bot_presence", kind: "message", T: () => DiscordBotPresence },
            { no: 6, name: "bot_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxLen: "255" } } } },
            { no: 7, name: "bot_permissions", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<Discord>): Discord {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.enabled = false;
        message.ignoredJobs = [];
        message.botPermissions = 0;
        if (value !== undefined)
            reflectionMergePartial<Discord>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Discord): Discord {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool enabled */ 1:
                    message.enabled = reader.bool();
                    break;
                case /* google.protobuf.Duration sync_interval */ 2:
                    message.syncInterval = Duration.internalBinaryRead(reader, reader.uint32(), options, message.syncInterval);
                    break;
                case /* optional string invite_url */ 3:
                    message.inviteUrl = reader.string();
                    break;
                case /* repeated string ignored_jobs */ 4:
                    message.ignoredJobs.push(reader.string());
                    break;
                case /* optional resources.settings.DiscordBotPresence bot_presence */ 5:
                    message.botPresence = DiscordBotPresence.internalBinaryRead(reader, reader.uint32(), options, message.botPresence);
                    break;
                case /* optional string bot_id */ 6:
                    message.botId = reader.string();
                    break;
                case /* int64 bot_permissions */ 7:
                    message.botPermissions = reader.int64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Discord, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool enabled = 1; */
        if (message.enabled !== false)
            writer.tag(1, WireType.Varint).bool(message.enabled);
        /* google.protobuf.Duration sync_interval = 2; */
        if (message.syncInterval)
            Duration.internalBinaryWrite(message.syncInterval, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional string invite_url = 3; */
        if (message.inviteUrl !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.inviteUrl);
        /* repeated string ignored_jobs = 4; */
        for (let i = 0; i < message.ignoredJobs.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.ignoredJobs[i]);
        /* optional resources.settings.DiscordBotPresence bot_presence = 5; */
        if (message.botPresence)
            DiscordBotPresence.internalBinaryWrite(message.botPresence, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* optional string bot_id = 6; */
        if (message.botId !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.botId);
        /* int64 bot_permissions = 7; */
        if (message.botPermissions !== 0)
            writer.tag(7, WireType.Varint).int64(message.botPermissions);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message resources.settings.Discord
 */
export const Discord = new Discord$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DiscordBotPresence$Type extends MessageType<DiscordBotPresence> {
    constructor() {
        super("resources.settings.DiscordBotPresence", [
            { no: 1, name: "type", kind: "enum", T: () => ["resources.settings.DiscordBotPresenceType", DiscordBotPresenceType, "DISCORD_BOT_PRESENCE_TYPE_"] },
            { no: 2, name: "status", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "url", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DiscordBotPresence>): DiscordBotPresence {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = 0;
        if (value !== undefined)
            reflectionMergePartial<DiscordBotPresence>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DiscordBotPresence): DiscordBotPresence {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* resources.settings.DiscordBotPresenceType type */ 1:
                    message.type = reader.int32();
                    break;
                case /* optional string status */ 2:
                    message.status = reader.string();
                    break;
                case /* optional string url */ 3:
                    message.url = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DiscordBotPresence, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* resources.settings.DiscordBotPresenceType type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* optional string status = 2; */
        if (message.status !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.status);
        /* optional string url = 3; */
        if (message.url !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.url);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message resources.settings.DiscordBotPresence
 */
export const DiscordBotPresence = new DiscordBotPresence$Type();
// @generated message type with reflection information, may provide speed optimized methods
class System$Type extends MessageType<System> {
    constructor() {
        super("resources.settings.System", [
            { no: 1, name: "banner_message_enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "banner_message", kind: "message", T: () => BannerMessage }
        ]);
    }
    create(value?: PartialMessage<System>): System {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.bannerMessageEnabled = false;
        if (value !== undefined)
            reflectionMergePartial<System>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: System): System {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool banner_message_enabled */ 1:
                    message.bannerMessageEnabled = reader.bool();
                    break;
                case /* resources.settings.BannerMessage banner_message */ 2:
                    message.bannerMessage = BannerMessage.internalBinaryRead(reader, reader.uint32(), options, message.bannerMessage);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: System, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool banner_message_enabled = 1; */
        if (message.bannerMessageEnabled !== false)
            writer.tag(1, WireType.Varint).bool(message.bannerMessageEnabled);
        /* resources.settings.BannerMessage banner_message = 2; */
        if (message.bannerMessage)
            BannerMessage.internalBinaryWrite(message.bannerMessage, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message resources.settings.System
 */
export const System = new System$Type();
